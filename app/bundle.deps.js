System.registerDynamic("bower:angular-foundation@0.8.0/mm-foundation-tpls.js", [], false, function(__require, __exports, __module) {
  var _retrieveGlobal = System.get("@@global-helpers").prepareGlobal(__module.id, null, null);
  (function() {
    angular.module("mm.foundation", ["mm.foundation.tpls", "mm.foundation.accordion", "mm.foundation.alert", "mm.foundation.bindHtml", "mm.foundation.buttons", "mm.foundation.position", "mm.foundation.mediaQueries", "mm.foundation.dropdownToggle", "mm.foundation.interchange", "mm.foundation.transition", "mm.foundation.modal", "mm.foundation.offcanvas", "mm.foundation.pagination", "mm.foundation.tooltip", "mm.foundation.popover", "mm.foundation.progressbar", "mm.foundation.rating", "mm.foundation.tabs", "mm.foundation.topbar", "mm.foundation.tour", "mm.foundation.typeahead"]);
    angular.module("mm.foundation.tpls", ["template/accordion/accordion-group.html", "template/accordion/accordion.html", "template/alert/alert.html", "template/modal/backdrop.html", "template/modal/window.html", "template/pagination/pager.html", "template/pagination/pagination.html", "template/tooltip/tooltip-html-unsafe-popup.html", "template/tooltip/tooltip-popup.html", "template/popover/popover.html", "template/progressbar/bar.html", "template/progressbar/progress.html", "template/progressbar/progressbar.html", "template/rating/rating.html", "template/tabs/tab.html", "template/tabs/tabset.html", "template/topbar/has-dropdown.html", "template/topbar/toggle-top-bar.html", "template/topbar/top-bar-dropdown.html", "template/topbar/top-bar-section.html", "template/topbar/top-bar.html", "template/tour/tour.html", "template/typeahead/typeahead-match.html", "template/typeahead/typeahead-popup.html"]);
    angular.module('mm.foundation.accordion', []).constant('accordionConfig', {closeOthers: true}).controller('AccordionController', ['$scope', '$attrs', 'accordionConfig', function($scope, $attrs, accordionConfig) {
      this.groups = [];
      this.closeOthers = function(openGroup) {
        var closeOthers = angular.isDefined($attrs.closeOthers) ? $scope.$eval($attrs.closeOthers) : accordionConfig.closeOthers;
        if (closeOthers) {
          angular.forEach(this.groups, function(group) {
            if (group !== openGroup) {
              group.isOpen = false;
            }
          });
        }
      };
      this.addGroup = function(groupScope) {
        var that = this;
        this.groups.push(groupScope);
        groupScope.$on('$destroy', function(event) {
          that.removeGroup(groupScope);
        });
      };
      this.removeGroup = function(group) {
        var index = this.groups.indexOf(group);
        if (index !== -1) {
          this.groups.splice(index, 1);
        }
      };
    }]).directive('accordion', function() {
      return {
        restrict: 'EA',
        controller: 'AccordionController',
        transclude: true,
        replace: false,
        templateUrl: 'template/accordion/accordion.html'
      };
    }).directive('accordionGroup', ['$parse', function($parse) {
      return {
        require: '^accordion',
        restrict: 'EA',
        transclude: true,
        replace: true,
        templateUrl: 'template/accordion/accordion-group.html',
        scope: {heading: '@'},
        controller: function() {
          this.setHeading = function(element) {
            this.heading = element;
          };
        },
        link: function(scope, element, attrs, accordionCtrl) {
          var getIsOpen,
              setIsOpen;
          accordionCtrl.addGroup(scope);
          scope.isOpen = false;
          if (attrs.isOpen) {
            getIsOpen = $parse(attrs.isOpen);
            setIsOpen = getIsOpen.assign;
            scope.$parent.$watch(getIsOpen, function(value) {
              scope.isOpen = !!value;
            });
          }
          scope.$watch('isOpen', function(value) {
            if (value) {
              accordionCtrl.closeOthers(scope);
            }
            if (setIsOpen) {
              setIsOpen(scope.$parent, value);
            }
          });
        }
      };
    }]).directive('accordionHeading', function() {
      return {
        restrict: 'EA',
        transclude: true,
        template: '',
        replace: true,
        require: '^accordionGroup',
        compile: function(element, attr, transclude) {
          return function link(scope, element, attr, accordionGroupCtrl) {
            accordionGroupCtrl.setHeading(transclude(scope, function() {}));
          };
        }
      };
    }).directive('accordionTransclude', function() {
      return {
        require: '^accordionGroup',
        link: function(scope, element, attr, controller) {
          scope.$watch(function() {
            return controller[attr.accordionTransclude];
          }, function(heading) {
            if (heading) {
              element.html('');
              element.append(heading);
            }
          });
        }
      };
    });
    angular.module("mm.foundation.alert", []).controller('AlertController', ['$scope', '$attrs', function($scope, $attrs) {
      $scope.closeable = 'close' in $attrs && typeof $attrs.close !== "undefined";
    }]).directive('alert', function() {
      return {
        restrict: 'EA',
        controller: 'AlertController',
        templateUrl: 'template/alert/alert.html',
        transclude: true,
        replace: true,
        scope: {
          type: '=',
          close: '&'
        }
      };
    });
    angular.module('mm.foundation.bindHtml', []).directive('bindHtmlUnsafe', function() {
      return function(scope, element, attr) {
        element.addClass('ng-binding').data('$binding', attr.bindHtmlUnsafe);
        scope.$watch(attr.bindHtmlUnsafe, function bindHtmlUnsafeWatchAction(value) {
          element.html(value || '');
        });
      };
    });
    angular.module('mm.foundation.buttons', []).constant('buttonConfig', {
      activeClass: 'active',
      toggleEvent: 'click'
    }).controller('ButtonsController', ['buttonConfig', function(buttonConfig) {
      this.activeClass = buttonConfig.activeClass;
      this.toggleEvent = buttonConfig.toggleEvent;
    }]).directive('btnRadio', function() {
      return {
        require: ['btnRadio', 'ngModel'],
        controller: 'ButtonsController',
        link: function(scope, element, attrs, ctrls) {
          var buttonsCtrl = ctrls[0],
              ngModelCtrl = ctrls[1];
          ngModelCtrl.$render = function() {
            element.toggleClass(buttonsCtrl.activeClass, angular.equals(ngModelCtrl.$modelValue, scope.$eval(attrs.btnRadio)));
          };
          element.bind(buttonsCtrl.toggleEvent, function() {
            if (!element.hasClass(buttonsCtrl.activeClass)) {
              scope.$apply(function() {
                ngModelCtrl.$setViewValue(scope.$eval(attrs.btnRadio));
                ngModelCtrl.$render();
              });
            }
          });
        }
      };
    }).directive('btnCheckbox', function() {
      return {
        require: ['btnCheckbox', 'ngModel'],
        controller: 'ButtonsController',
        link: function(scope, element, attrs, ctrls) {
          var buttonsCtrl = ctrls[0],
              ngModelCtrl = ctrls[1];
          function getTrueValue() {
            return getCheckboxValue(attrs.btnCheckboxTrue, true);
          }
          function getFalseValue() {
            return getCheckboxValue(attrs.btnCheckboxFalse, false);
          }
          function getCheckboxValue(attributeValue, defaultValue) {
            var val = scope.$eval(attributeValue);
            return angular.isDefined(val) ? val : defaultValue;
          }
          ngModelCtrl.$render = function() {
            element.toggleClass(buttonsCtrl.activeClass, angular.equals(ngModelCtrl.$modelValue, getTrueValue()));
          };
          element.bind(buttonsCtrl.toggleEvent, function() {
            scope.$apply(function() {
              ngModelCtrl.$setViewValue(element.hasClass(buttonsCtrl.activeClass) ? getFalseValue() : getTrueValue());
              ngModelCtrl.$render();
            });
          });
        }
      };
    });
    angular.module('mm.foundation.position', []).factory('$position', ['$document', '$window', function($document, $window) {
      function getStyle(el, cssprop) {
        if (el.currentStyle) {
          return el.currentStyle[cssprop];
        } else if ($window.getComputedStyle) {
          return $window.getComputedStyle(el)[cssprop];
        }
        return el.style[cssprop];
      }
      function isStaticPositioned(element) {
        return (getStyle(element, "position") || 'static') === 'static';
      }
      var parentOffsetEl = function(element) {
        var docDomEl = $document[0];
        var offsetParent = element.offsetParent || docDomEl;
        while (offsetParent && offsetParent !== docDomEl && isStaticPositioned(offsetParent)) {
          offsetParent = offsetParent.offsetParent;
        }
        return offsetParent || docDomEl;
      };
      return {
        position: function(element) {
          var elBCR = this.offset(element);
          var offsetParentBCR = {
            top: 0,
            left: 0
          };
          var offsetParentEl = parentOffsetEl(element[0]);
          if (offsetParentEl != $document[0]) {
            offsetParentBCR = this.offset(angular.element(offsetParentEl));
            offsetParentBCR.top += offsetParentEl.clientTop - offsetParentEl.scrollTop;
            offsetParentBCR.left += offsetParentEl.clientLeft - offsetParentEl.scrollLeft;
          }
          var boundingClientRect = element[0].getBoundingClientRect();
          return {
            width: boundingClientRect.width || element.prop('offsetWidth'),
            height: boundingClientRect.height || element.prop('offsetHeight'),
            top: elBCR.top - offsetParentBCR.top,
            left: elBCR.left - offsetParentBCR.left
          };
        },
        offset: function(element) {
          var boundingClientRect = element[0].getBoundingClientRect();
          return {
            width: boundingClientRect.width || element.prop('offsetWidth'),
            height: boundingClientRect.height || element.prop('offsetHeight'),
            top: boundingClientRect.top + ($window.pageYOffset || $document[0].body.scrollTop || $document[0].documentElement.scrollTop),
            left: boundingClientRect.left + ($window.pageXOffset || $document[0].body.scrollLeft || $document[0].documentElement.scrollLeft)
          };
        }
      };
    }]);
    angular.module("mm.foundation.mediaQueries", []).factory('matchMedia', ['$document', '$window', function($document, $window) {
      return $window.matchMedia || (function matchMedia(doc, undefined) {
        var bool,
            docElem = doc.documentElement,
            refNode = docElem.firstElementChild || docElem.firstChild,
            fakeBody = doc.createElement("body"),
            div = doc.createElement("div");
        div.id = "mq-test-1";
        div.style.cssText = "position:absolute;top:-100em";
        fakeBody.style.background = "none";
        fakeBody.appendChild(div);
        return function(q) {
          div.innerHTML = "&shy;<style media=\"" + q + "\"> #mq-test-1 { width: 42px; }</style>";
          docElem.insertBefore(fakeBody, refNode);
          bool = div.offsetWidth === 42;
          docElem.removeChild(fakeBody);
          return {
            matches: bool,
            media: q
          };
        };
      }($document[0]));
    }]).factory('mediaQueries', ['$document', 'matchMedia', function($document, matchMedia) {
      var head = angular.element($document[0].querySelector('head'));
      head.append('<meta class="foundation-mq-topbar" />');
      head.append('<meta class="foundation-mq-small" />');
      head.append('<meta class="foundation-mq-medium" />');
      head.append('<meta class="foundation-mq-large" />');
      var regex = /^[\/\\'"]+|(;\s?})+|[\/\\'"]+$/g;
      var queries = {
        topbar: getComputedStyle(head[0].querySelector('meta.foundation-mq-topbar')).fontFamily.replace(regex, ''),
        small: getComputedStyle(head[0].querySelector('meta.foundation-mq-small')).fontFamily.replace(regex, ''),
        medium: getComputedStyle(head[0].querySelector('meta.foundation-mq-medium')).fontFamily.replace(regex, ''),
        large: getComputedStyle(head[0].querySelector('meta.foundation-mq-large')).fontFamily.replace(regex, '')
      };
      return {
        topbarBreakpoint: function() {
          return !matchMedia(queries.topbar).matches;
        },
        small: function() {
          return matchMedia(queries.small).matches;
        },
        medium: function() {
          return matchMedia(queries.medium).matches;
        },
        large: function() {
          return matchMedia(queries.large).matches;
        }
      };
    }]);
    angular.module('mm.foundation.dropdownToggle', ['mm.foundation.position', 'mm.foundation.mediaQueries']).controller('DropdownToggleController', ['$scope', '$attrs', 'mediaQueries', function($scope, $attrs, mediaQueries) {
      this.small = function() {
        return mediaQueries.small() && !mediaQueries.medium();
      };
    }]).directive('dropdownToggle', ['$document', '$window', '$location', '$position', function($document, $window, $location, $position) {
      var openElement = null,
          closeMenu = angular.noop;
      return {
        restrict: 'CA',
        controller: 'DropdownToggleController',
        link: function(scope, element, attrs, controller) {
          var parent = element.parent(),
              dropdown = angular.element($document[0].querySelector(attrs.dropdownToggle));
          var parentHasDropdown = function() {
            return parent.hasClass('has-dropdown');
          };
          var onClick = function(event) {
            dropdown = angular.element($document[0].querySelector(attrs.dropdownToggle));
            var elementWasOpen = (element === openElement);
            event.preventDefault();
            event.stopPropagation();
            if (!!openElement) {
              closeMenu();
            }
            if (!elementWasOpen && !element.hasClass('disabled') && !element.prop('disabled')) {
              dropdown.css('display', 'block');
              dropdown.addClass('f-open-dropdown');
              var offset = $position.offset(element);
              var parentOffset = $position.offset(angular.element(dropdown[0].offsetParent));
              var dropdownWidth = dropdown.prop('offsetWidth');
              var css = {top: offset.top - parentOffset.top + offset.height + 'px'};
              if (controller.small()) {
                css.left = Math.max((parentOffset.width - dropdownWidth) / 2, 8) + 'px';
                css.position = 'absolute';
                css.width = '95%';
                css['max-width'] = 'none';
              } else {
                var left = Math.round(offset.left - parentOffset.left);
                var rightThreshold = $window.innerWidth - dropdownWidth - 8;
                if (left > rightThreshold) {
                  left = rightThreshold;
                  dropdown.removeClass('left').addClass('right');
                }
                css.left = left + 'px';
                css.position = null;
                css['max-width'] = null;
              }
              dropdown.css(css);
              element.addClass('expanded');
              if (parentHasDropdown()) {
                parent.addClass('hover');
              }
              openElement = element;
              closeMenu = function(event) {
                $document.off('click', closeMenu);
                dropdown.css('display', 'none');
                dropdown.removeClass('f-open-dropdown');
                element.removeClass('expanded');
                closeMenu = angular.noop;
                openElement = null;
                if (parent.hasClass('hover')) {
                  parent.removeClass('hover');
                }
              };
              $document.on('click', closeMenu);
            }
          };
          if (dropdown) {
            dropdown.css('display', 'none');
          }
          scope.$watch('$location.path', function() {
            closeMenu();
          });
          element.on('click', onClick);
          element.on('$destroy', function() {
            element.off('click', onClick);
          });
        }
      };
    }]);
    angular.module('mm.foundation.interchange', ['mm.foundation.mediaQueries']).factory('interchangeQueries', ['$document', function($document) {
      var element,
          mediaSize,
          formatList = {
            'default': 'only screen',
            landscape: 'only screen and (orientation: landscape)',
            portrait: 'only screen and (orientation: portrait)',
            retina: 'only screen and (-webkit-min-device-pixel-ratio: 2),' + 'only screen and (min--moz-device-pixel-ratio: 2),' + 'only screen and (-o-min-device-pixel-ratio: 2/1),' + 'only screen and (min-device-pixel-ratio: 2),' + 'only screen and (min-resolution: 192dpi),' + 'only screen and (min-resolution: 2dppx)'
          },
          classPrefix = 'foundation-mq-',
          classList = ['small', 'medium', 'large', 'xlarge', 'xxlarge'],
          head = angular.element($document[0].querySelector('head'));
      for (var i = 0; i < classList.length; i++) {
        head.append('<meta class="' + classPrefix + classList[i] + '" />');
        element = getComputedStyle(head[0].querySelector('meta.' + classPrefix + classList[i]));
        mediaSize = element.fontFamily.replace(/^[\/\\'"]+|(;\s?})+|[\/\\'"]+$/g, '');
        formatList[classList[i]] = mediaSize;
      }
      return formatList;
    }]).factory('interchangeQueriesManager', ['interchangeQueries', function(interchangeQueries) {
      return {add: function(name, media) {
          if (!name || !media || !angular.isString(name) || !angular.isString(media) || !!interchangeQueries[name]) {
            return false;
          }
          interchangeQueries[name] = media;
          return true;
        }};
    }]).factory('interchangeTools', ['$window', 'matchMedia', 'interchangeQueries', function($window, matchMedia, namedQueries) {
      var parseAttribute = function(value) {
        var raw = value.split(/\[(.*?)\]/),
            i = raw.length,
            breaker = /^(.+)\,\ \((.+)\)$/,
            breaked,
            output = {};
        while (i--) {
          if (raw[i].replace(/[\W\d]+/, '').length > 4) {
            breaked = breaker.exec(raw[i]);
            if (!!breaked && breaked.length === 3) {
              output[breaked[2]] = breaked[1];
            }
          }
        }
        return output;
      };
      var findCurrentMediaFile = function(files) {
        var file,
            media,
            match;
        for (file in files) {
          media = namedQueries[file] || file;
          match = matchMedia(media);
          if (match.matches) {
            return files[file];
          }
        }
        return;
      };
      return {
        parseAttribute: parseAttribute,
        findCurrentMediaFile: findCurrentMediaFile
      };
    }]).directive('interchange', ['$window', '$rootScope', 'interchangeTools', function($window, $rootScope, interchangeTools) {
      var pictureFilePattern = /[A-Za-z0-9-_]+\.(jpg|jpeg|png|gif|bmp|tiff)\ *,/i;
      return {
        restrict: 'A',
        scope: true,
        priority: 450,
        compile: function compile($element, attrs) {
          if ($element[0].nodeName === 'DIV' && !pictureFilePattern.test(attrs.interchange)) {
            $element.html('<ng-include src="currentFile"></ng-include>');
          }
          return {
            pre: function preLink($scope, $element, attrs) {},
            post: function postLink($scope, $element, attrs) {
              var currentFile,
                  nodeName;
              nodeName = $element && $element[0] && $element[0].nodeName;
              $scope.fileMap = interchangeTools.parseAttribute(attrs.interchange);
              switch (nodeName) {
                case 'DIV':
                  currentFile = interchangeTools.findCurrentMediaFile($scope.fileMap);
                  if (/[A-Za-z0-9-_]+\.(jpg|jpeg|png|gif|bmp|tiff)$/i.test(currentFile)) {
                    $scope.type = 'background';
                  } else {
                    $scope.type = 'include';
                  }
                  break;
                case 'IMG':
                  $scope.type = 'image';
                  break;
                default:
                  return;
              }
              var replace = function(e) {
                var currentFile = interchangeTools.findCurrentMediaFile($scope.fileMap);
                if (!!$scope.currentFile && $scope.currentFile === currentFile) {
                  return;
                }
                $scope.currentFile = currentFile;
                switch ($scope.type) {
                  case 'image':
                    $element.attr('src', $scope.currentFile);
                    break;
                  case 'background':
                    $element.css('background-image', 'url(' + $scope.currentFile + ')');
                    break;
                }
                $rootScope.$emit('replace', $element, $scope);
                if (!!e) {
                  $scope.$apply();
                }
              };
              replace();
              $window.addEventListener('resize', replace);
              $scope.$on('$destroy', function() {
                $window.removeEventListener('resize', replace);
              });
            }
          };
        }
      };
    }]);
    angular.module('mm.foundation.transition', []).factory('$transition', ['$q', '$timeout', '$rootScope', function($q, $timeout, $rootScope) {
      var $transition = function(element, trigger, options) {
        options = options || {};
        var deferred = $q.defer();
        var endEventName = $transition[options.animation ? "animationEndEventName" : "transitionEndEventName"];
        var transitionEndHandler = function(event) {
          $rootScope.$apply(function() {
            element.unbind(endEventName, transitionEndHandler);
            deferred.resolve(element);
          });
        };
        if (endEventName) {
          element.bind(endEventName, transitionEndHandler);
        }
        $timeout(function() {
          if (angular.isString(trigger)) {
            element.addClass(trigger);
          } else if (angular.isFunction(trigger)) {
            trigger(element);
          } else if (angular.isObject(trigger)) {
            element.css(trigger);
          }
          if (!endEventName) {
            deferred.resolve(element);
          }
        });
        deferred.promise.cancel = function() {
          if (endEventName) {
            element.unbind(endEventName, transitionEndHandler);
          }
          deferred.reject('Transition cancelled');
        };
        return deferred.promise;
      };
      var transElement = document.createElement('trans');
      var transitionEndEventNames = {
        'WebkitTransition': 'webkitTransitionEnd',
        'MozTransition': 'transitionend',
        'OTransition': 'oTransitionEnd',
        'transition': 'transitionend'
      };
      var animationEndEventNames = {
        'WebkitTransition': 'webkitAnimationEnd',
        'MozTransition': 'animationend',
        'OTransition': 'oAnimationEnd',
        'transition': 'animationend'
      };
      function findEndEventName(endEventNames) {
        for (var name in endEventNames) {
          if (transElement.style[name] !== undefined) {
            return endEventNames[name];
          }
        }
      }
      $transition.transitionEndEventName = findEndEventName(transitionEndEventNames);
      $transition.animationEndEventName = findEndEventName(animationEndEventNames);
      return $transition;
    }]);
    angular.module('mm.foundation.modal', ['mm.foundation.transition']).factory('$$stackedMap', function() {
      return {createNew: function() {
          var stack = [];
          return {
            add: function(key, value) {
              stack.push({
                key: key,
                value: value
              });
            },
            get: function(key) {
              for (var i = 0; i < stack.length; i++) {
                if (key == stack[i].key) {
                  return stack[i];
                }
              }
            },
            keys: function() {
              var keys = [];
              for (var i = 0; i < stack.length; i++) {
                keys.push(stack[i].key);
              }
              return keys;
            },
            top: function() {
              return stack[stack.length - 1];
            },
            remove: function(key) {
              var idx = -1;
              for (var i = 0; i < stack.length; i++) {
                if (key == stack[i].key) {
                  idx = i;
                  break;
                }
              }
              return stack.splice(idx, 1)[0];
            },
            removeTop: function() {
              return stack.splice(stack.length - 1, 1)[0];
            },
            length: function() {
              return stack.length;
            }
          };
        }};
    }).directive('modalBackdrop', ['$modalStack', '$timeout', function($modalStack, $timeout) {
      return {
        restrict: 'EA',
        replace: true,
        templateUrl: 'template/modal/backdrop.html',
        link: function(scope) {
          scope.animate = false;
          $timeout(function() {
            scope.animate = true;
          });
          scope.close = function(evt) {
            var modal = $modalStack.getTop();
            if (modal && modal.value.backdrop && modal.value.backdrop != 'static' && (evt.target === evt.currentTarget)) {
              evt.preventDefault();
              evt.stopPropagation();
              $modalStack.dismiss(modal.key, 'backdrop click');
            }
          };
        }
      };
    }]).directive('modalWindow', ['$modalStack', '$timeout', function($modalStack, $timeout) {
      return {
        restrict: 'EA',
        scope: {
          index: '@',
          animate: '='
        },
        replace: true,
        transclude: true,
        templateUrl: 'template/modal/window.html',
        link: function(scope, element, attrs) {
          scope.windowClass = attrs.windowClass || '';
          $timeout(function() {
            scope.animate = true;
            if (element[0].querySelectorAll('[autofocus]').length > 0) {
              element[0].querySelectorAll('[autofocus]')[0].focus();
            } else {
              element[0].focus();
            }
          });
        }
      };
    }]).factory('$modalStack', ['$window', '$transition', '$timeout', '$document', '$compile', '$rootScope', '$$stackedMap', function($window, $transition, $timeout, $document, $compile, $rootScope, $$stackedMap) {
      var OPENED_MODAL_CLASS = 'modal-open';
      var backdropDomEl,
          backdropScope,
          cssTop;
      var openedWindows = $$stackedMap.createNew();
      var $modalStack = {};
      function backdropIndex() {
        var topBackdropIndex = -1;
        var opened = openedWindows.keys();
        for (var i = 0; i < opened.length; i++) {
          if (openedWindows.get(opened[i]).value.backdrop) {
            topBackdropIndex = i;
          }
        }
        return topBackdropIndex;
      }
      $rootScope.$watch(backdropIndex, function(newBackdropIndex) {
        if (backdropScope) {
          backdropScope.index = newBackdropIndex;
        }
      });
      function removeModalWindow(modalInstance) {
        var parent = $document.find(modalInstance.options.parent).eq(0);
        var modalWindow = openedWindows.get(modalInstance).value;
        openedWindows.remove(modalInstance);
        removeAfterAnimate(modalWindow.modalDomEl, modalWindow.modalScope, 300, function() {
          modalWindow.modalScope.$destroy();
          parent.toggleClass(OPENED_MODAL_CLASS, openedWindows.length() > 0);
          checkRemoveBackdrop();
        });
      }
      function checkRemoveBackdrop() {
        if (backdropDomEl && backdropIndex() == -1) {
          var backdropScopeRef = backdropScope;
          removeAfterAnimate(backdropDomEl, backdropScope, 150, function() {
            backdropScopeRef.$destroy();
            backdropScopeRef = null;
          });
          backdropDomEl = undefined;
          backdropScope = undefined;
        }
      }
      function removeAfterAnimate(domEl, scope, emulateTime, done) {
        scope.animate = false;
        var transitionEndEventName = $transition.transitionEndEventName;
        if (transitionEndEventName) {
          var timeout = $timeout(afterAnimating, emulateTime);
          domEl.bind(transitionEndEventName, function() {
            $timeout.cancel(timeout);
            afterAnimating();
            scope.$apply();
          });
        } else {
          $timeout(afterAnimating, 0);
        }
        function afterAnimating() {
          if (afterAnimating.done) {
            return;
          }
          afterAnimating.done = true;
          domEl.remove();
          if (done) {
            done();
          }
        }
      }
      function calculateModalTop(modalElement, offset) {
        if (angular.isUndefined(offset)) {
          offset = 0;
        }
        var scrollY = $window.pageYOffset || 0;
        return offset + scrollY;
      }
      $document.bind('keydown', function(evt) {
        var modal;
        if (evt.which === 27) {
          modal = openedWindows.top();
          if (modal && modal.value.keyboard) {
            $rootScope.$apply(function() {
              $modalStack.dismiss(modal.key);
            });
          }
        }
      });
      $modalStack.open = function(modalInstance, modal) {
        modalInstance.options = {
          deferred: modal.deferred,
          modalScope: modal.scope,
          backdrop: modal.backdrop,
          keyboard: modal.keyboard,
          parent: modal.parent
        };
        openedWindows.add(modalInstance, modalInstance.options);
        var parent = $document.find(modal.parent).eq(0),
            currBackdropIndex = backdropIndex();
        if (currBackdropIndex >= 0 && !backdropDomEl) {
          backdropScope = $rootScope.$new(true);
          backdropScope.index = currBackdropIndex;
          backdropDomEl = $compile('<div modal-backdrop></div>')(backdropScope);
          parent.append(backdropDomEl);
        }
        var faux = angular.element('<div class="reveal-modal" style="z-index:-1""></div>');
        parent.append(faux[0]);
        cssTop = parseInt($window.getComputedStyle(faux[0]).top) || 0;
        var openAt = calculateModalTop(faux, cssTop);
        faux.remove();
        var angularDomEl = angular.element('<div modal-window style="visibility: visible; top:' + openAt + 'px;"></div>').attr({
          'window-class': modal.windowClass,
          'index': openedWindows.length() - 1,
          'animate': 'animate'
        });
        angularDomEl.html(modal.content);
        var modalDomEl = $compile(angularDomEl)(modal.scope);
        openedWindows.top().value.modalDomEl = modalDomEl;
        parent.append(modalDomEl);
        parent.addClass(OPENED_MODAL_CLASS);
      };
      $modalStack.reposition = function(modalInstance) {
        var modalWindow = openedWindows.get(modalInstance).value;
        if (modalWindow) {
          var modalDomEl = modalWindow.modalDomEl;
          var top = calculateModalTop(modalDomEl, cssTop);
          modalDomEl.css('top', top + "px");
        }
      };
      $modalStack.close = function(modalInstance, result) {
        var modalWindow = openedWindows.get(modalInstance);
        if (modalWindow) {
          modalWindow.value.deferred.resolve(result);
          removeModalWindow(modalInstance);
        }
      };
      $modalStack.dismiss = function(modalInstance, reason) {
        var modalWindow = openedWindows.get(modalInstance);
        if (modalWindow) {
          modalWindow.value.deferred.reject(reason);
          removeModalWindow(modalInstance);
        }
      };
      $modalStack.dismissAll = function(reason) {
        var topModal = this.getTop();
        while (topModal) {
          this.dismiss(topModal.key, reason);
          topModal = this.getTop();
        }
      };
      $modalStack.getTop = function() {
        return openedWindows.top();
      };
      return $modalStack;
    }]).provider('$modal', function() {
      var $modalProvider = {
        options: {
          backdrop: true,
          keyboard: true
        },
        $get: ['$injector', '$rootScope', '$q', '$http', '$templateCache', '$controller', '$modalStack', function($injector, $rootScope, $q, $http, $templateCache, $controller, $modalStack) {
          var $modal = {};
          function getTemplatePromise(options) {
            return options.template ? $q.when(options.template) : $http.get(options.templateUrl, {cache: $templateCache}).then(function(result) {
              return result.data;
            });
          }
          function getResolvePromises(resolves) {
            var promisesArr = [];
            angular.forEach(resolves, function(value, key) {
              if (angular.isFunction(value) || angular.isArray(value)) {
                promisesArr.push($q.when($injector.invoke(value)));
              }
            });
            return promisesArr;
          }
          $modal.open = function(modalOptions) {
            var modalResultDeferred = $q.defer();
            var modalOpenedDeferred = $q.defer();
            var modalInstance = {
              result: modalResultDeferred.promise,
              opened: modalOpenedDeferred.promise,
              close: function(result) {
                $modalStack.close(modalInstance, result);
              },
              dismiss: function(reason) {
                $modalStack.dismiss(modalInstance, reason);
              },
              reposition: function() {
                $modalStack.reposition(modalInstance);
              }
            };
            modalOptions = angular.extend({}, $modalProvider.options, modalOptions);
            modalOptions.resolve = modalOptions.resolve || {};
            if (!modalOptions.template && !modalOptions.templateUrl) {
              throw new Error('One of template or templateUrl options is required.');
            }
            var templateAndResolvePromise = $q.all([getTemplatePromise(modalOptions)].concat(getResolvePromises(modalOptions.resolve)));
            templateAndResolvePromise.then(function resolveSuccess(tplAndVars) {
              var modalScope = (modalOptions.scope || $rootScope).$new();
              modalScope.$close = modalInstance.close;
              modalScope.$dismiss = modalInstance.dismiss;
              var ctrlInstance,
                  ctrlLocals = {};
              var resolveIter = 1;
              if (modalOptions.controller) {
                ctrlLocals.$scope = modalScope;
                ctrlLocals.$modalInstance = modalInstance;
                angular.forEach(modalOptions.resolve, function(value, key) {
                  ctrlLocals[key] = tplAndVars[resolveIter++];
                });
                ctrlInstance = $controller(modalOptions.controller, ctrlLocals);
                if (modalOptions.controllerAs) {
                  modalScope[modalOptions.controllerAs] = ctrlInstance;
                }
              }
              $modalStack.open(modalInstance, {
                scope: modalScope,
                deferred: modalResultDeferred,
                content: tplAndVars[0],
                backdrop: modalOptions.backdrop,
                keyboard: modalOptions.keyboard,
                windowClass: modalOptions.windowClass,
                parent: modalOptions.parent || 'body'
              });
            }, function resolveError(reason) {
              modalResultDeferred.reject(reason);
            });
            templateAndResolvePromise.then(function() {
              modalOpenedDeferred.resolve(true);
            }, function() {
              modalOpenedDeferred.reject(false);
            });
            return modalInstance;
          };
          return $modal;
        }]
      };
      return $modalProvider;
    });
    angular.module("mm.foundation.offcanvas", []).directive('offCanvasWrap', ['$window', function($window) {
      return {
        scope: {},
        restrict: 'C',
        link: function($scope, element, attrs) {
          var win = angular.element($window);
          var sidebar = $scope.sidebar = element;
          $scope.hide = function() {
            sidebar.removeClass('move-left');
            sidebar.removeClass('move-right');
          };
          win.bind("resize.body", $scope.hide);
          $scope.$on('$destroy', function() {
            win.unbind("resize.body", $scope.hide);
          });
        },
        controller: ['$scope', function($scope) {
          this.leftToggle = function() {
            $scope.sidebar.toggleClass("move-right");
          };
          this.rightToggle = function() {
            $scope.sidebar.toggleClass("move-left");
          };
          this.hide = function() {
            $scope.hide();
          };
        }]
      };
    }]).directive('leftOffCanvasToggle', [function() {
      return {
        require: '^offCanvasWrap',
        restrict: 'C',
        link: function($scope, element, attrs, offCanvasWrap) {
          element.on('click', function() {
            offCanvasWrap.leftToggle();
          });
        }
      };
    }]).directive('rightOffCanvasToggle', [function() {
      return {
        require: '^offCanvasWrap',
        restrict: 'C',
        link: function($scope, element, attrs, offCanvasWrap) {
          element.on('click', function() {
            offCanvasWrap.rightToggle();
          });
        }
      };
    }]).directive('exitOffCanvas', [function() {
      return {
        require: '^offCanvasWrap',
        restrict: 'C',
        link: function($scope, element, attrs, offCanvasWrap) {
          element.on('click', function() {
            offCanvasWrap.hide();
          });
        }
      };
    }]).directive('offCanvasList', [function() {
      return {
        require: '^offCanvasWrap',
        restrict: 'C',
        link: function($scope, element, attrs, offCanvasWrap) {
          element.on('click', function() {
            offCanvasWrap.hide();
          });
        }
      };
    }]);
    angular.module('mm.foundation.pagination', []).controller('PaginationController', ['$scope', '$attrs', '$parse', '$interpolate', function($scope, $attrs, $parse, $interpolate) {
      var self = this,
          setNumPages = $attrs.numPages ? $parse($attrs.numPages).assign : angular.noop;
      this.init = function(defaultItemsPerPage) {
        if ($attrs.itemsPerPage) {
          $scope.$parent.$watch($parse($attrs.itemsPerPage), function(value) {
            self.itemsPerPage = parseInt(value, 10);
            $scope.totalPages = self.calculateTotalPages();
          });
        } else {
          this.itemsPerPage = defaultItemsPerPage;
        }
      };
      this.noPrevious = function() {
        return this.page === 1;
      };
      this.noNext = function() {
        return this.page === $scope.totalPages;
      };
      this.isActive = function(page) {
        return this.page === page;
      };
      this.calculateTotalPages = function() {
        var totalPages = this.itemsPerPage < 1 ? 1 : Math.ceil($scope.totalItems / this.itemsPerPage);
        return Math.max(totalPages || 0, 1);
      };
      this.getAttributeValue = function(attribute, defaultValue, interpolate) {
        return angular.isDefined(attribute) ? (interpolate ? $interpolate(attribute)($scope.$parent) : $scope.$parent.$eval(attribute)) : defaultValue;
      };
      this.render = function() {
        this.page = parseInt($scope.page, 10) || 1;
        if (this.page > 0 && this.page <= $scope.totalPages) {
          $scope.pages = this.getPages(this.page, $scope.totalPages);
        }
      };
      $scope.selectPage = function(page) {
        if (!self.isActive(page) && page > 0 && page <= $scope.totalPages) {
          $scope.page = page;
          $scope.onSelectPage({page: page});
        }
      };
      $scope.$watch('page', function() {
        self.render();
      });
      $scope.$watch('totalItems', function() {
        $scope.totalPages = self.calculateTotalPages();
      });
      $scope.$watch('totalPages', function(value) {
        setNumPages($scope.$parent, value);
        if (self.page > value) {
          $scope.selectPage(value);
        } else {
          self.render();
        }
      });
    }]).constant('paginationConfig', {
      itemsPerPage: 10,
      boundaryLinks: false,
      directionLinks: true,
      firstText: 'First',
      previousText: 'Previous',
      nextText: 'Next',
      lastText: 'Last',
      rotate: true
    }).directive('pagination', ['$parse', 'paginationConfig', function($parse, config) {
      return {
        restrict: 'EA',
        scope: {
          page: '=',
          totalItems: '=',
          onSelectPage: ' &'
        },
        controller: 'PaginationController',
        templateUrl: 'template/pagination/pagination.html',
        replace: true,
        link: function(scope, element, attrs, paginationCtrl) {
          var maxSize,
              boundaryLinks = paginationCtrl.getAttributeValue(attrs.boundaryLinks, config.boundaryLinks),
              directionLinks = paginationCtrl.getAttributeValue(attrs.directionLinks, config.directionLinks),
              firstText = paginationCtrl.getAttributeValue(attrs.firstText, config.firstText, true),
              previousText = paginationCtrl.getAttributeValue(attrs.previousText, config.previousText, true),
              nextText = paginationCtrl.getAttributeValue(attrs.nextText, config.nextText, true),
              lastText = paginationCtrl.getAttributeValue(attrs.lastText, config.lastText, true),
              rotate = paginationCtrl.getAttributeValue(attrs.rotate, config.rotate);
          paginationCtrl.init(config.itemsPerPage);
          if (attrs.maxSize) {
            scope.$parent.$watch($parse(attrs.maxSize), function(value) {
              maxSize = parseInt(value, 10);
              paginationCtrl.render();
            });
          }
          function makePage(number, text, isActive, isDisabled) {
            return {
              number: number,
              text: text,
              active: isActive,
              disabled: isDisabled
            };
          }
          paginationCtrl.getPages = function(currentPage, totalPages) {
            var pages = [];
            var startPage = 1,
                endPage = totalPages;
            var isMaxSized = (angular.isDefined(maxSize) && maxSize < totalPages);
            if (isMaxSized) {
              if (rotate) {
                startPage = Math.max(currentPage - Math.floor(maxSize / 2), 1);
                endPage = startPage + maxSize - 1;
                if (endPage > totalPages) {
                  endPage = totalPages;
                  startPage = endPage - maxSize + 1;
                }
              } else {
                startPage = ((Math.ceil(currentPage / maxSize) - 1) * maxSize) + 1;
                endPage = Math.min(startPage + maxSize - 1, totalPages);
              }
            }
            for (var number = startPage; number <= endPage; number++) {
              var page = makePage(number, number, paginationCtrl.isActive(number), false);
              pages.push(page);
            }
            if (isMaxSized && !rotate) {
              if (startPage > 1) {
                var previousPageSet = makePage(startPage - 1, '...', false, false);
                pages.unshift(previousPageSet);
              }
              if (endPage < totalPages) {
                var nextPageSet = makePage(endPage + 1, '...', false, false);
                pages.push(nextPageSet);
              }
            }
            if (directionLinks) {
              var previousPage = makePage(currentPage - 1, previousText, false, paginationCtrl.noPrevious());
              pages.unshift(previousPage);
              var nextPage = makePage(currentPage + 1, nextText, false, paginationCtrl.noNext());
              pages.push(nextPage);
            }
            if (boundaryLinks) {
              var firstPage = makePage(1, firstText, false, paginationCtrl.noPrevious());
              pages.unshift(firstPage);
              var lastPage = makePage(totalPages, lastText, false, paginationCtrl.noNext());
              pages.push(lastPage);
            }
            return pages;
          };
        }
      };
    }]).constant('pagerConfig', {
      itemsPerPage: 10,
      previousText: '« Previous',
      nextText: 'Next »',
      align: true
    }).directive('pager', ['pagerConfig', function(config) {
      return {
        restrict: 'EA',
        scope: {
          page: '=',
          totalItems: '=',
          onSelectPage: ' &'
        },
        controller: 'PaginationController',
        templateUrl: 'template/pagination/pager.html',
        replace: true,
        link: function(scope, element, attrs, paginationCtrl) {
          var previousText = paginationCtrl.getAttributeValue(attrs.previousText, config.previousText, true),
              nextText = paginationCtrl.getAttributeValue(attrs.nextText, config.nextText, true),
              align = paginationCtrl.getAttributeValue(attrs.align, config.align);
          paginationCtrl.init(config.itemsPerPage);
          function makePage(number, text, isDisabled, isPrevious, isNext) {
            return {
              number: number,
              text: text,
              disabled: isDisabled,
              previous: (align && isPrevious),
              next: (align && isNext)
            };
          }
          paginationCtrl.getPages = function(currentPage) {
            return [makePage(currentPage - 1, previousText, paginationCtrl.noPrevious(), true, false), makePage(currentPage + 1, nextText, paginationCtrl.noNext(), false, true)];
          };
        }
      };
    }]);
    angular.module('mm.foundation.tooltip', ['mm.foundation.position', 'mm.foundation.bindHtml']).provider('$tooltip', function() {
      var defaultOptions = {
        placement: 'top',
        animation: true,
        popupDelay: 0
      };
      var triggerMap = {
        'mouseenter': 'mouseleave',
        'click': 'click',
        'focus': 'blur'
      };
      var globalOptions = {};
      this.options = function(value) {
        angular.extend(globalOptions, value);
      };
      this.setTriggers = function setTriggers(triggers) {
        angular.extend(triggerMap, triggers);
      };
      function snake_case(name) {
        var regexp = /[A-Z]/g;
        var separator = '-';
        return name.replace(regexp, function(letter, pos) {
          return (pos ? separator : '') + letter.toLowerCase();
        });
      }
      this.$get = ['$window', '$compile', '$timeout', '$parse', '$document', '$position', '$interpolate', function($window, $compile, $timeout, $parse, $document, $position, $interpolate) {
        return function $tooltip(type, prefix, defaultTriggerShow) {
          var options = angular.extend({}, defaultOptions, globalOptions);
          function getTriggers(trigger) {
            var show = trigger || options.trigger || defaultTriggerShow;
            var hide = triggerMap[show] || show;
            return {
              show: show,
              hide: hide
            };
          }
          var directiveName = snake_case(type);
          var startSym = $interpolate.startSymbol();
          var endSym = $interpolate.endSymbol();
          var template = '<div ' + directiveName + '-popup ' + 'title="' + startSym + 'tt_title' + endSym + '" ' + 'content="' + startSym + 'tt_content' + endSym + '" ' + 'placement="' + startSym + 'tt_placement' + endSym + '" ' + 'animation="tt_animation" ' + 'is-open="tt_isOpen"' + '>' + '</div>';
          return {
            restrict: 'EA',
            scope: true,
            compile: function(tElem, tAttrs) {
              var tooltipLinker = $compile(template);
              return function link(scope, element, attrs) {
                var tooltip;
                var transitionTimeout;
                var popupTimeout;
                var appendToBody = angular.isDefined(options.appendToBody) ? options.appendToBody : false;
                var triggers = getTriggers(undefined);
                var hasRegisteredTriggers = false;
                var hasEnableExp = angular.isDefined(attrs[prefix + 'Enable']);
                var positionTooltip = function() {
                  var position,
                      ttWidth,
                      ttHeight,
                      ttPosition;
                  position = appendToBody ? $position.offset(element) : $position.position(element);
                  ttWidth = tooltip.prop('offsetWidth');
                  ttHeight = tooltip.prop('offsetHeight');
                  switch (scope.tt_placement) {
                    case 'right':
                      ttPosition = {
                        top: position.top + position.height / 2 - ttHeight / 2,
                        left: position.left + position.width + 10
                      };
                      break;
                    case 'bottom':
                      ttPosition = {
                        top: position.top + position.height + 10,
                        left: position.left
                      };
                      break;
                    case 'left':
                      ttPosition = {
                        top: position.top + position.height / 2 - ttHeight / 2,
                        left: position.left - ttWidth - 10
                      };
                      break;
                    default:
                      ttPosition = {
                        top: position.top - ttHeight - 10,
                        left: position.left
                      };
                      break;
                  }
                  ttPosition.top += 'px';
                  ttPosition.left += 'px';
                  tooltip.css(ttPosition);
                };
                scope.tt_isOpen = false;
                function toggleTooltipBind() {
                  if (!scope.tt_isOpen) {
                    showTooltipBind();
                  } else {
                    hideTooltipBind();
                  }
                }
                function showTooltipBind() {
                  if (hasEnableExp && !scope.$eval(attrs[prefix + 'Enable'])) {
                    return;
                  }
                  if (scope.tt_popupDelay) {
                    popupTimeout = $timeout(show, scope.tt_popupDelay, false);
                    popupTimeout.then(function(reposition) {
                      reposition();
                    });
                  } else {
                    show()();
                  }
                }
                function hideTooltipBind() {
                  scope.$apply(function() {
                    hide();
                  });
                }
                function show() {
                  if (!scope.tt_content) {
                    return angular.noop;
                  }
                  createTooltip();
                  if (transitionTimeout) {
                    $timeout.cancel(transitionTimeout);
                  }
                  tooltip.css({
                    top: 0,
                    left: 0,
                    display: 'block'
                  });
                  if (appendToBody) {
                    $document.find('body').append(tooltip);
                  } else {
                    element.after(tooltip);
                  }
                  positionTooltip();
                  scope.tt_isOpen = true;
                  scope.$digest();
                  return positionTooltip;
                }
                function hide() {
                  scope.tt_isOpen = false;
                  $timeout.cancel(popupTimeout);
                  if (scope.tt_animation) {
                    transitionTimeout = $timeout(removeTooltip, 500);
                  } else {
                    removeTooltip();
                  }
                }
                function createTooltip() {
                  if (tooltip) {
                    removeTooltip();
                  }
                  tooltip = tooltipLinker(scope, function() {});
                  scope.$digest();
                }
                function removeTooltip() {
                  if (tooltip) {
                    tooltip.remove();
                    tooltip = null;
                  }
                }
                attrs.$observe(type, function(val) {
                  scope.tt_content = val;
                  if (!val && scope.tt_isOpen) {
                    hide();
                  }
                });
                attrs.$observe(prefix + 'Title', function(val) {
                  scope.tt_title = val;
                });
                attrs[prefix + 'Placement'] = attrs[prefix + 'Placement'] || null;
                attrs.$observe(prefix + 'Placement', function(val) {
                  scope.tt_placement = angular.isDefined(val) && val ? val : options.placement;
                });
                attrs[prefix + 'PopupDelay'] = attrs[prefix + 'PopupDelay'] || null;
                attrs.$observe(prefix + 'PopupDelay', function(val) {
                  var delay = parseInt(val, 10);
                  scope.tt_popupDelay = !isNaN(delay) ? delay : options.popupDelay;
                });
                var unregisterTriggers = function() {
                  if (hasRegisteredTriggers) {
                    if (angular.isFunction(triggers.show)) {
                      unregisterTriggerFunction();
                    } else {
                      element.unbind(triggers.show, showTooltipBind);
                      element.unbind(triggers.hide, hideTooltipBind);
                    }
                  }
                };
                var unregisterTriggerFunction = function() {};
                attrs[prefix + 'Trigger'] = attrs[prefix + 'Trigger'] || null;
                attrs.$observe(prefix + 'Trigger', function(val) {
                  unregisterTriggers();
                  unregisterTriggerFunction();
                  triggers = getTriggers(val);
                  if (angular.isFunction(triggers.show)) {
                    unregisterTriggerFunction = scope.$watch(function() {
                      return triggers.show(scope, element, attrs);
                    }, function(val) {
                      return val ? $timeout(show) : $timeout(hide);
                    });
                  } else {
                    if (triggers.show === triggers.hide) {
                      element.bind(triggers.show, toggleTooltipBind);
                    } else {
                      element.bind(triggers.show, showTooltipBind);
                      element.bind(triggers.hide, hideTooltipBind);
                    }
                  }
                  hasRegisteredTriggers = true;
                });
                var animation = scope.$eval(attrs[prefix + 'Animation']);
                scope.tt_animation = angular.isDefined(animation) ? !!animation : options.animation;
                attrs.$observe(prefix + 'AppendToBody', function(val) {
                  appendToBody = angular.isDefined(val) ? $parse(val)(scope) : appendToBody;
                });
                if (appendToBody) {
                  scope.$on('$locationChangeSuccess', function closeTooltipOnLocationChangeSuccess() {
                    if (scope.tt_isOpen) {
                      hide();
                    }
                  });
                }
                scope.$on('$destroy', function onDestroyTooltip() {
                  $timeout.cancel(transitionTimeout);
                  $timeout.cancel(popupTimeout);
                  unregisterTriggers();
                  unregisterTriggerFunction();
                  removeTooltip();
                });
              };
            }
          };
        };
      }];
    }).directive('tooltipPopup', function() {
      return {
        restrict: 'EA',
        replace: true,
        scope: {
          content: '@',
          placement: '@',
          animation: '&',
          isOpen: '&'
        },
        templateUrl: 'template/tooltip/tooltip-popup.html'
      };
    }).directive('tooltip', ['$tooltip', function($tooltip) {
      return $tooltip('tooltip', 'tooltip', 'mouseenter');
    }]).directive('tooltipHtmlUnsafePopup', function() {
      return {
        restrict: 'EA',
        replace: true,
        scope: {
          content: '@',
          placement: '@',
          animation: '&',
          isOpen: '&'
        },
        templateUrl: 'template/tooltip/tooltip-html-unsafe-popup.html'
      };
    }).directive('tooltipHtmlUnsafe', ['$tooltip', function($tooltip) {
      return $tooltip('tooltipHtmlUnsafe', 'tooltip', 'mouseenter');
    }]);
    angular.module('mm.foundation.popover', ['mm.foundation.tooltip']).directive('popoverPopup', function() {
      return {
        restrict: 'EA',
        replace: true,
        scope: {
          title: '@',
          content: '@',
          placement: '@',
          animation: '&',
          isOpen: '&'
        },
        templateUrl: 'template/popover/popover.html'
      };
    }).directive('popover', ['$tooltip', function($tooltip) {
      return $tooltip('popover', 'popover', 'click');
    }]);
    angular.module('mm.foundation.progressbar', ['mm.foundation.transition']).constant('progressConfig', {
      animate: true,
      max: 100
    }).controller('ProgressController', ['$scope', '$attrs', 'progressConfig', '$transition', function($scope, $attrs, progressConfig, $transition) {
      var self = this,
          bars = [],
          max = angular.isDefined($attrs.max) ? $scope.$parent.$eval($attrs.max) : progressConfig.max,
          animate = angular.isDefined($attrs.animate) ? $scope.$parent.$eval($attrs.animate) : progressConfig.animate;
      this.addBar = function(bar, element) {
        var oldValue = 0,
            index = bar.$parent.$index;
        if (angular.isDefined(index) && bars[index]) {
          oldValue = bars[index].value;
        }
        bars.push(bar);
        this.update(element, bar.value, oldValue);
        bar.$watch('value', function(value, oldValue) {
          if (value !== oldValue) {
            self.update(element, value, oldValue);
          }
        });
        bar.$on('$destroy', function() {
          self.removeBar(bar);
        });
      };
      this.update = function(element, newValue, oldValue) {
        var percent = this.getPercentage(newValue);
        if (animate) {
          element.css('width', this.getPercentage(oldValue) + '%');
          $transition(element, {width: percent + '%'});
        } else {
          element.css({
            'transition': 'none',
            'width': percent + '%'
          });
        }
      };
      this.removeBar = function(bar) {
        bars.splice(bars.indexOf(bar), 1);
      };
      this.getPercentage = function(value) {
        return Math.round(100 * value / max);
      };
    }]).directive('progress', function() {
      return {
        restrict: 'EA',
        replace: true,
        transclude: true,
        controller: 'ProgressController',
        require: 'progress',
        scope: {},
        template: '<div class="progress" ng-transclude></div>'
      };
    }).directive('bar', function() {
      return {
        restrict: 'EA',
        replace: true,
        transclude: true,
        require: '^progress',
        scope: {
          value: '=',
          type: '@'
        },
        templateUrl: 'template/progressbar/bar.html',
        link: function(scope, element, attrs, progressCtrl) {
          progressCtrl.addBar(scope, element);
        }
      };
    }).directive('progressbar', function() {
      return {
        restrict: 'EA',
        replace: true,
        transclude: true,
        controller: 'ProgressController',
        scope: {
          value: '=',
          type: '@'
        },
        templateUrl: 'template/progressbar/progressbar.html',
        link: function(scope, element, attrs, progressCtrl) {
          progressCtrl.addBar(scope, angular.element(element.children()[0]));
        }
      };
    });
    angular.module('mm.foundation.rating', []).constant('ratingConfig', {
      max: 5,
      stateOn: null,
      stateOff: null
    }).controller('RatingController', ['$scope', '$attrs', '$parse', 'ratingConfig', function($scope, $attrs, $parse, ratingConfig) {
      this.maxRange = angular.isDefined($attrs.max) ? $scope.$parent.$eval($attrs.max) : ratingConfig.max;
      this.stateOn = angular.isDefined($attrs.stateOn) ? $scope.$parent.$eval($attrs.stateOn) : ratingConfig.stateOn;
      this.stateOff = angular.isDefined($attrs.stateOff) ? $scope.$parent.$eval($attrs.stateOff) : ratingConfig.stateOff;
      this.createRateObjects = function(states) {
        var defaultOptions = {
          stateOn: this.stateOn,
          stateOff: this.stateOff
        };
        for (var i = 0,
            n = states.length; i < n; i++) {
          states[i] = angular.extend({index: i}, defaultOptions, states[i]);
        }
        return states;
      };
      $scope.range = angular.isDefined($attrs.ratingStates) ? this.createRateObjects(angular.copy($scope.$parent.$eval($attrs.ratingStates))) : this.createRateObjects(new Array(this.maxRange));
      $scope.rate = function(value) {
        if ($scope.value !== value && !$scope.readonly) {
          $scope.value = value;
        }
      };
      $scope.enter = function(value) {
        if (!$scope.readonly) {
          $scope.val = value;
        }
        $scope.onHover({value: value});
      };
      $scope.reset = function() {
        $scope.val = angular.copy($scope.value);
        $scope.onLeave();
      };
      $scope.$watch('value', function(value) {
        $scope.val = value;
      });
      $scope.readonly = false;
      if ($attrs.readonly) {
        $scope.$parent.$watch($parse($attrs.readonly), function(value) {
          $scope.readonly = !!value;
        });
      }
    }]).directive('rating', function() {
      return {
        restrict: 'EA',
        scope: {
          value: '=',
          onHover: '&',
          onLeave: '&'
        },
        controller: 'RatingController',
        templateUrl: 'template/rating/rating.html',
        replace: true
      };
    });
    angular.module('mm.foundation.tabs', []).controller('TabsetController', ['$scope', function TabsetCtrl($scope) {
      var ctrl = this,
          tabs = ctrl.tabs = $scope.tabs = [];
      if (angular.isUndefined($scope.openOnLoad)) {
        $scope.openOnLoad = true;
      }
      ctrl.select = function(tab) {
        angular.forEach(tabs, function(tab) {
          tab.active = false;
        });
        tab.active = true;
      };
      ctrl.addTab = function addTab(tab) {
        tabs.push(tab);
        if ($scope.openOnLoad && (tabs.length === 1 || tab.active)) {
          ctrl.select(tab);
        }
      };
      ctrl.removeTab = function removeTab(tab) {
        var index = tabs.indexOf(tab);
        if (tab.active && tabs.length > 1) {
          var newActiveIndex = index == tabs.length - 1 ? index - 1 : index + 1;
          ctrl.select(tabs[newActiveIndex]);
        }
        tabs.splice(index, 1);
      };
    }]).directive('tabset', function() {
      return {
        restrict: 'EA',
        transclude: true,
        replace: true,
        scope: {openOnLoad: '=?'},
        controller: 'TabsetController',
        templateUrl: 'template/tabs/tabset.html',
        link: function(scope, element, attrs) {
          scope.vertical = angular.isDefined(attrs.vertical) ? scope.$parent.$eval(attrs.vertical) : false;
          scope.justified = angular.isDefined(attrs.justified) ? scope.$parent.$eval(attrs.justified) : false;
          scope.type = angular.isDefined(attrs.type) ? scope.$parent.$eval(attrs.type) : 'tabs';
        }
      };
    }).directive('tab', ['$parse', function($parse) {
      return {
        require: '^tabset',
        restrict: 'EA',
        replace: true,
        templateUrl: 'template/tabs/tab.html',
        transclude: true,
        scope: {
          heading: '@',
          onSelect: '&select',
          onDeselect: '&deselect'
        },
        controller: function() {},
        compile: function(elm, attrs, transclude) {
          return function postLink(scope, elm, attrs, tabsetCtrl) {
            var getActive,
                setActive;
            if (attrs.active) {
              getActive = $parse(attrs.active);
              setActive = getActive.assign;
              scope.$parent.$watch(getActive, function updateActive(value, oldVal) {
                if (value !== oldVal) {
                  scope.active = !!value;
                }
              });
              scope.active = getActive(scope.$parent);
            } else {
              setActive = getActive = angular.noop;
            }
            scope.$watch('active', function(active) {
              if (!angular.isFunction(setActive)) {
                return;
              }
              setActive(scope.$parent, active);
              if (active) {
                tabsetCtrl.select(scope);
                scope.onSelect();
              } else {
                scope.onDeselect();
              }
            });
            scope.disabled = false;
            if (attrs.disabled) {
              scope.$parent.$watch($parse(attrs.disabled), function(value) {
                scope.disabled = !!value;
              });
            }
            scope.select = function() {
              if (!scope.disabled) {
                scope.active = true;
              }
            };
            tabsetCtrl.addTab(scope);
            scope.$on('$destroy', function() {
              tabsetCtrl.removeTab(scope);
            });
            scope.$transcludeFn = transclude;
          };
        }
      };
    }]).directive('tabHeadingTransclude', [function() {
      return {
        restrict: 'A',
        require: '^tab',
        link: function(scope, elm, attrs, tabCtrl) {
          scope.$watch('headingElement', function updateHeadingElement(heading) {
            if (heading) {
              elm.html('');
              elm.append(heading);
            }
          });
        }
      };
    }]).directive('tabContentTransclude', function() {
      return {
        restrict: 'A',
        require: '^tabset',
        link: function(scope, elm, attrs) {
          var tab = scope.$eval(attrs.tabContentTransclude);
          tab.$transcludeFn(tab.$parent, function(contents) {
            angular.forEach(contents, function(node) {
              if (isTabHeading(node)) {
                tab.headingElement = node;
              } else {
                elm.append(node);
              }
            });
          });
        }
      };
      function isTabHeading(node) {
        return node.tagName && (node.hasAttribute('tab-heading') || node.hasAttribute('data-tab-heading') || node.tagName.toLowerCase() === 'tab-heading' || node.tagName.toLowerCase() === 'data-tab-heading');
      }
    });
    ;
    angular.module("mm.foundation.topbar", ['mm.foundation.mediaQueries']).factory('closest', [function() {
      return function(el, selector) {
        var matchesSelector = function(node, selector) {
          var nodes = (node.parentNode || node.document).querySelectorAll(selector);
          var i = -1;
          while (nodes[++i] && nodes[i] != node) {}
          return !!nodes[i];
        };
        var element = el[0];
        while (element) {
          if (matchesSelector(element, selector)) {
            return angular.element(element);
          } else {
            element = element.parentElement;
          }
        }
        return false;
      };
    }]).directive('topBar', ['$timeout', '$compile', '$window', '$document', 'mediaQueries', function($timeout, $compile, $window, $document, mediaQueries) {
      return {
        scope: {
          stickyClass: '@',
          backText: '@',
          stickyOn: '=',
          customBackText: '=',
          isHover: '=',
          mobileShowParentLink: '=',
          scrolltop: '='
        },
        restrict: 'EA',
        replace: true,
        templateUrl: 'template/topbar/top-bar.html',
        transclude: true,
        controller: ['$window', '$scope', 'closest', function($window, $scope, closest) {
          $scope.settings = {};
          $scope.settings.stickyClass = $scope.stickyClass || 'sticky';
          $scope.settings.backText = $scope.backText || 'Back';
          $scope.settings.stickyOn = $scope.stickyOn || 'all';
          $scope.settings.customBackText = $scope.customBackText === undefined ? true : $scope.customBackText;
          $scope.settings.isHover = $scope.isHover === undefined ? true : $scope.isHover;
          $scope.settings.mobileShowParentLink = $scope.mobileShowParentLink === undefined ? true : $scope.mobileShowParentLink;
          $scope.settings.scrolltop = $scope.scrolltop === undefined ? true : $scope.scrolltop;
          this.settings = $scope.settings;
          $scope.index = 0;
          var outerHeight = function(el) {
            var height = el.offsetHeight;
            var style = el.currentStyle || getComputedStyle(el);
            height += parseInt(style.marginTop, 10) + parseInt(style.marginBottom, 10);
            return height;
          };
          var sections = [];
          this.addSection = function(section) {
            sections.push(section);
          };
          this.removeSection = function(section) {
            var index = sections.indexOf(section);
            if (index > -1) {
              sections.splice(index, 1);
            }
          };
          var dir = /rtl/i.test($document.find('html').attr('dir')) ? 'right' : 'left';
          $scope.$watch('index', function(index) {
            for (var i = 0; i < sections.length; i++) {
              sections[i].move(dir, index);
            }
          });
          this.toggle = function(on) {
            $scope.toggle(on);
            for (var i = 0; i < sections.length; i++) {
              sections[i].reset();
            }
            $scope.index = 0;
            $scope.height = '';
            $scope.$apply();
          };
          this.back = function(event) {
            if ($scope.index < 1 || !mediaQueries.topbarBreakpoint()) {
              return;
            }
            var $link = angular.element(event.currentTarget);
            var $movedLi = closest($link, 'li.moved');
            var $previousLevelUl = $movedLi.parent();
            $scope.index = $scope.index - 1;
            if ($scope.index === 0) {
              $scope.height = '';
            } else {
              $scope.height = $scope.originalHeight + outerHeight($previousLevelUl[0]);
            }
            $timeout(function() {
              $movedLi.removeClass('moved');
            }, 300);
          };
          this.forward = function(event) {
            if (!mediaQueries.topbarBreakpoint()) {
              return false;
            }
            var $link = angular.element(event.currentTarget);
            var $selectedLi = closest($link, 'li');
            $selectedLi.addClass('moved');
            $scope.height = $scope.originalHeight + outerHeight($link.parent()[0].querySelector('ul'));
            $scope.index = $scope.index + 1;
            $scope.$apply();
          };
        }],
        link: function(scope, element, attrs) {
          var topbar = scope.topbar = element;
          var topbarContainer = topbar.parent();
          var body = angular.element($document[0].querySelector('body'));
          var lastBreakpoint = mediaQueries.topbarBreakpoint();
          var isSticky = scope.isSticky = function() {
            var sticky = topbarContainer.hasClass(scope.settings.stickyClass);
            if (sticky && scope.settings.stickyOn === 'all') {
              return true;
            } else if (sticky && mediaQueries.small() && scope.settings.stickyOn === 'small') {
              return true;
            } else if (sticky && mediaQueries.medium() && scope.settings.stickyOn === 'medium') {
              return true;
            } else if (sticky && mediaQueries.large() && scope.settings.stickyOn === 'large') {
              return true;
            }
            return false;
          };
          var updateStickyPositioning = function() {
            if (!scope.stickyTopbar || !scope.isSticky()) {
              return;
            }
            var distance = stickyoffset;
            if ($window.pageYOffset > distance && !topbarContainer.hasClass('fixed')) {
              topbarContainer.addClass('fixed');
              body.css('padding-top', scope.originalHeight + 'px');
            } else if ($window.pageYOffset <= distance && topbarContainer.hasClass('fixed')) {
              topbarContainer.removeClass('fixed');
              body.css('padding-top', '');
            }
          };
          var onResize = function() {
            var currentBreakpoint = mediaQueries.topbarBreakpoint();
            if (lastBreakpoint === currentBreakpoint) {
              return;
            }
            lastBreakpoint = mediaQueries.topbarBreakpoint();
            topbar.removeClass('expanded');
            topbar.parent().removeClass('expanded');
            scope.height = '';
            var sections = angular.element(topbar[0].querySelectorAll('section'));
            angular.forEach(sections, function(section) {
              angular.element(section.querySelectorAll('li.moved')).removeClass('moved');
            });
            scope.$apply();
          };
          var onScroll = function() {
            updateStickyPositioning();
            scope.$apply();
          };
          scope.toggle = function(on) {
            if (!mediaQueries.topbarBreakpoint()) {
              return false;
            }
            var expand = (on === undefined) ? !topbar.hasClass('expanded') : on;
            if (expand) {
              topbar.addClass('expanded');
            } else {
              topbar.removeClass('expanded');
            }
            if (scope.settings.scrolltop) {
              if (!expand && topbar.hasClass('fixed')) {
                topbar.parent().addClass('fixed');
                topbar.removeClass('fixed');
                body.css('padding-top', scope.originalHeight + 'px');
              } else if (expand && topbar.parent().hasClass('fixed')) {
                topbar.parent().removeClass('fixed');
                topbar.addClass('fixed');
                body.css('padding-top', '');
                $window.scrollTo(0, 0);
              }
            } else {
              if (isSticky()) {
                topbar.parent().addClass('fixed');
              }
              if (topbar.parent().hasClass('fixed')) {
                if (!expand) {
                  topbar.removeClass('fixed');
                  topbar.parent().removeClass('expanded');
                  updateStickyPositioning();
                } else {
                  topbar.addClass('fixed');
                  topbar.parent().addClass('expanded');
                  body.css('padding-top', scope.originalHeight + 'px');
                }
              }
            }
          };
          if (topbarContainer.hasClass('fixed') || isSticky()) {
            scope.stickyTopbar = true;
            scope.height = topbarContainer[0].offsetHeight;
            var stickyoffset = topbarContainer[0].getBoundingClientRect().top + $window.pageYOffset;
          } else {
            scope.height = topbar[0].offsetHeight;
          }
          scope.originalHeight = scope.height;
          scope.$watch('height', function(h) {
            if (h) {
              topbar.css('height', h + 'px');
            } else {
              topbar.css('height', '');
            }
          });
          angular.element($window).bind('resize', onResize);
          angular.element($window).bind('scroll', onScroll);
          scope.$on('$destroy', function() {
            angular.element($window).unbind('scroll', onResize);
            angular.element($window).unbind('resize', onScroll);
          });
          if (topbarContainer.hasClass('fixed')) {
            body.css('padding-top', scope.originalHeight + 'px');
          }
        }
      };
    }]).directive('toggleTopBar', ['closest', function(closest) {
      return {
        scope: {},
        require: '^topBar',
        restrict: 'A',
        replace: true,
        templateUrl: 'template/topbar/toggle-top-bar.html',
        transclude: true,
        link: function(scope, element, attrs, topBar) {
          element.bind('click', function(event) {
            var li = closest(angular.element(event.currentTarget), 'li');
            if (!li.hasClass('back') && !li.hasClass('has-dropdown')) {
              topBar.toggle();
            }
          });
          scope.$on('$destroy', function() {
            element.unbind('click');
          });
        }
      };
    }]).directive('topBarSection', ['$compile', 'closest', function($compile, closest) {
      return {
        scope: {},
        require: '^topBar',
        restrict: 'EA',
        replace: true,
        templateUrl: 'template/topbar/top-bar-section.html',
        transclude: true,
        link: function(scope, element, attrs, topBar) {
          var section = element;
          scope.reset = function() {
            angular.element(section[0].querySelectorAll('li.moved')).removeClass('moved');
          };
          scope.move = function(dir, index) {
            if (dir === 'left') {
              section.css({"left": index * -100 + '%'});
            } else {
              section.css({"right": index * -100 + '%'});
            }
          };
          topBar.addSection(scope);
          scope.$on("$destroy", function() {
            topBar.removeSection(scope);
          });
          var links = section[0].querySelectorAll('li>a');
          angular.forEach(links, function(link) {
            var $link = angular.element(link);
            var li = closest($link, 'li');
            if (li.hasClass('has-dropdown') || li.hasClass('back') || li.hasClass('title')) {
              return;
            }
            $link.bind('click', function() {
              topBar.toggle(false);
            });
            scope.$on('$destroy', function() {
              $link.bind('click');
            });
          });
        }
      };
    }]).directive('hasDropdown', ['mediaQueries', function(mediaQueries) {
      return {
        scope: {},
        require: '^topBar',
        restrict: 'A',
        templateUrl: 'template/topbar/has-dropdown.html',
        replace: true,
        transclude: true,
        link: function(scope, element, attrs, topBar) {
          scope.triggerLink = element.children('a')[0];
          var $link = angular.element(scope.triggerLink);
          $link.bind('click', function(event) {
            topBar.forward(event);
          });
          scope.$on('$destroy', function() {
            $link.unbind('click');
          });
          element.bind('mouseenter', function() {
            if (topBar.settings.isHover && !mediaQueries.topbarBreakpoint()) {
              element.addClass('not-click');
            }
          });
          element.bind('click', function(event) {
            if (!topBar.settings.isHover && !mediaQueries.topbarBreakpoint()) {
              element.toggleClass('not-click');
            }
          });
          element.bind('mouseleave', function() {
            element.removeClass('not-click');
          });
          scope.$on('$destroy', function() {
            element.unbind('click');
            element.unbind('mouseenter');
            element.unbind('mouseleave');
          });
        },
        controller: ['$window', '$scope', function($window, $scope) {
          this.triggerLink = $scope.triggerLink;
        }]
      };
    }]).directive('topBarDropdown', ['$compile', function($compile) {
      return {
        scope: {},
        require: ['^topBar', '^hasDropdown'],
        restrict: 'A',
        replace: true,
        templateUrl: 'template/topbar/top-bar-dropdown.html',
        transclude: true,
        link: function(scope, element, attrs, ctrls) {
          var topBar = ctrls[0];
          var hasDropdown = ctrls[1];
          var $link = angular.element(hasDropdown.triggerLink);
          var url = $link.attr('href');
          var $titleLi;
          scope.linkText = $link.text();
          scope.back = function(event) {
            topBar.back(event);
          };
          if (topBar.settings.customBackText) {
            scope.backText = topBar.settings.backText;
          } else {
            scope.backText = '&laquo; ' + $link.html();
          }
          if (topBar.settings.mobileShowParentLink && url && url.length > 1) {
            $titleLi = angular.element('<li class="title back js-generated">' + '<h5><a href="#" ng-click="back($event);">{{backText}}</a></h5></li>' + '<li><a class="parent-link js-generated" href="' + url + '">{{linkText}}</a></li>');
          } else {
            $titleLi = angular.element('<li class="title back js-generated">' + '<h5><a href="" ng-click="back($event);">{{backText}}</a></h5></li>');
          }
          $compile($titleLi)(scope);
          element.prepend($titleLi);
        }
      };
    }]);
    angular.module('mm.foundation.tour', ['mm.foundation.position', 'mm.foundation.tooltip']).service('$tour', ['$window', function($window) {
      var currentIndex = getStoredCurrentStep();
      var ended = false;
      var steps = {};
      function getStoredCurrentStep() {
        try {
          return parseInt($window.localStorage.getItem('mm.tour.step'), 10);
        } catch (e) {
          if (e.name !== "SecurityError") {
            throw e;
          }
        }
      }
      function storeCurrentStep() {
        try {
          $window.localStorage.setItem('mm.tour.step', currentIndex);
        } catch (e) {
          if (e.name !== "SecurityError") {
            throw e;
          }
        }
      }
      function setCurrentStep(step) {
        currentIndex = step;
        storeCurrentStep();
      }
      this.add = function(index, attrs) {
        steps[index] = attrs;
      };
      this.has = function(index) {
        return !!steps[index];
      };
      this.isActive = function() {
        return currentIndex > 0;
      };
      this.current = function(index) {
        if (index) {
          setCurrentStep(currentIndex);
        } else {
          return currentIndex;
        }
      };
      this.start = function() {
        setCurrentStep(1);
      };
      this.next = function() {
        setCurrentStep(currentIndex + 1);
      };
      this.end = function() {
        setCurrentStep(0);
      };
    }]).directive('stepTextPopup', ['$tour', function($tour) {
      return {
        restrict: 'EA',
        replace: true,
        scope: {
          title: '@',
          content: '@',
          placement: '@',
          animation: '&',
          isOpen: '&'
        },
        templateUrl: 'template/tour/tour.html',
        link: function(scope, element) {
          scope.isLastStep = function() {
            return !$tour.has($tour.current() + 1);
          };
          scope.endTour = function() {
            element.remove();
            $tour.end();
          };
          scope.nextStep = function() {
            element.remove();
            $tour.next();
          };
          scope.$on('$locationChangeSuccess', scope.endTour);
        }
      };
    }]).directive('stepText', ['$position', '$tooltip', '$tour', '$window', function($position, $tooltip, $tour, $window) {
      function isElementInViewport(element) {
        var rect = element[0].getBoundingClientRect();
        return (rect.top >= 0 && rect.left >= 0 && rect.bottom <= ($window.innerHeight - 80) && rect.right <= $window.innerWidth);
      }
      function show(scope, element, attrs) {
        var index = parseInt(attrs.stepIndex, 10);
        if ($tour.isActive() && index) {
          $tour.add(index, attrs);
          if (index === $tour.current()) {
            if (!isElementInViewport(element)) {
              var offset = $position.offset(element);
              $window.scrollTo(0, offset.top - $window.innerHeight / 2);
            }
            return true;
          }
        }
        return false;
      }
      return $tooltip('stepText', 'step', show);
    }]);
    angular.module('mm.foundation.typeahead', ['mm.foundation.position', 'mm.foundation.bindHtml']).factory('typeaheadParser', ['$parse', function($parse) {
      var TYPEAHEAD_REGEXP = /^\s*(.*?)(?:\s+as\s+(.*?))?\s+for\s+(?:([\$\w][\$\w\d]*))\s+in\s+(.*)$/;
      return {parse: function(input) {
          var match = input.match(TYPEAHEAD_REGEXP);
          if (!match) {
            throw new Error("Expected typeahead specification in form of '_modelValue_ (as _label_)? for _item_ in _collection_'" + " but got '" + input + "'.");
          }
          return {
            itemName: match[3],
            source: $parse(match[4]),
            viewMapper: $parse(match[2] || match[1]),
            modelMapper: $parse(match[1])
          };
        }};
    }]).directive('typeahead', ['$compile', '$parse', '$q', '$timeout', '$document', '$position', 'typeaheadParser', function($compile, $parse, $q, $timeout, $document, $position, typeaheadParser) {
      var HOT_KEYS = [9, 13, 27, 38, 40];
      return {
        require: 'ngModel',
        link: function(originalScope, element, attrs, modelCtrl) {
          var minSearch = originalScope.$eval(attrs.typeaheadMinLength) || 1;
          var waitTime = originalScope.$eval(attrs.typeaheadWaitMs) || 0;
          var isEditable = originalScope.$eval(attrs.typeaheadEditable) !== false;
          var isLoadingSetter = $parse(attrs.typeaheadLoading).assign || angular.noop;
          var onSelectCallback = $parse(attrs.typeaheadOnSelect);
          var inputFormatter = attrs.typeaheadInputFormatter ? $parse(attrs.typeaheadInputFormatter) : undefined;
          var appendToBody = attrs.typeaheadAppendToBody ? $parse(attrs.typeaheadAppendToBody) : false;
          var $setModelValue = $parse(attrs.ngModel).assign;
          var parserResult = typeaheadParser.parse(attrs.typeahead);
          var hasFocus;
          var popUpEl = angular.element('<div typeahead-popup></div>');
          popUpEl.attr({
            matches: 'matches',
            active: 'activeIdx',
            select: 'select(activeIdx)',
            query: 'query',
            position: 'position'
          });
          if (angular.isDefined(attrs.typeaheadTemplateUrl)) {
            popUpEl.attr('template-url', attrs.typeaheadTemplateUrl);
          }
          var scope = originalScope.$new();
          originalScope.$on('$destroy', function() {
            scope.$destroy();
          });
          var resetMatches = function() {
            scope.matches = [];
            scope.activeIdx = -1;
          };
          var getMatchesAsync = function(inputValue) {
            var locals = {$viewValue: inputValue};
            isLoadingSetter(originalScope, true);
            $q.when(parserResult.source(originalScope, locals)).then(function(matches) {
              if (inputValue === modelCtrl.$viewValue && hasFocus) {
                if (matches.length > 0) {
                  scope.activeIdx = 0;
                  scope.matches.length = 0;
                  for (var i = 0; i < matches.length; i++) {
                    locals[parserResult.itemName] = matches[i];
                    scope.matches.push({
                      label: parserResult.viewMapper(scope, locals),
                      model: matches[i]
                    });
                  }
                  scope.query = inputValue;
                  scope.position = appendToBody ? $position.offset(element) : $position.position(element);
                  scope.position.top = scope.position.top + element.prop('offsetHeight');
                } else {
                  resetMatches();
                }
              }
            }, function() {
              resetMatches();
            }).finally(function() {
              isLoadingSetter(originalScope, false);
            });
          };
          resetMatches();
          scope.query = undefined;
          var timeoutPromise;
          modelCtrl.$parsers.unshift(function(inputValue) {
            if (inputValue && inputValue.length >= minSearch) {
              if (waitTime > 0) {
                if (timeoutPromise) {
                  $timeout.cancel(timeoutPromise);
                }
                timeoutPromise = $timeout(function() {
                  getMatchesAsync(inputValue);
                }, waitTime);
              } else {
                getMatchesAsync(inputValue);
              }
            } else {
              isLoadingSetter(originalScope, false);
              resetMatches();
            }
            if (isEditable) {
              return inputValue;
            } else {
              if (!inputValue) {
                modelCtrl.$setValidity('editable', true);
                return inputValue;
              } else {
                modelCtrl.$setValidity('editable', false);
                return undefined;
              }
            }
          });
          modelCtrl.$formatters.push(function(modelValue) {
            var candidateViewValue,
                emptyViewValue;
            var locals = {};
            if (inputFormatter) {
              locals['$model'] = modelValue;
              return inputFormatter(originalScope, locals);
            } else {
              locals[parserResult.itemName] = modelValue;
              candidateViewValue = parserResult.viewMapper(originalScope, locals);
              locals[parserResult.itemName] = undefined;
              emptyViewValue = parserResult.viewMapper(originalScope, locals);
              return candidateViewValue !== emptyViewValue ? candidateViewValue : modelValue;
            }
          });
          scope.select = function(activeIdx) {
            var locals = {};
            var model,
                item;
            locals[parserResult.itemName] = item = scope.matches[activeIdx].model;
            model = parserResult.modelMapper(originalScope, locals);
            $setModelValue(originalScope, model);
            modelCtrl.$setValidity('editable', true);
            onSelectCallback(originalScope, {
              $item: item,
              $model: model,
              $label: parserResult.viewMapper(originalScope, locals)
            });
            resetMatches();
            element[0].focus();
          };
          element.bind('keydown', function(evt) {
            if (scope.matches.length === 0 || HOT_KEYS.indexOf(evt.which) === -1) {
              return;
            }
            evt.preventDefault();
            if (evt.which === 40) {
              scope.activeIdx = (scope.activeIdx + 1) % scope.matches.length;
              scope.$digest();
            } else if (evt.which === 38) {
              scope.activeIdx = (scope.activeIdx ? scope.activeIdx : scope.matches.length) - 1;
              scope.$digest();
            } else if (evt.which === 13 || evt.which === 9) {
              scope.$apply(function() {
                scope.select(scope.activeIdx);
              });
            } else if (evt.which === 27) {
              evt.stopPropagation();
              resetMatches();
              scope.$digest();
            }
          });
          element.bind('blur', function(evt) {
            hasFocus = false;
          });
          element.bind('focus', function(evt) {
            hasFocus = true;
          });
          var dismissClickHandler = function(evt) {
            if (element[0] !== evt.target) {
              resetMatches();
              scope.$digest();
            }
          };
          $document.bind('click', dismissClickHandler);
          originalScope.$on('$destroy', function() {
            $document.unbind('click', dismissClickHandler);
          });
          var $popup = $compile(popUpEl)(scope);
          if (appendToBody) {
            $document.find('body').append($popup);
          } else {
            element.after($popup);
          }
        }
      };
    }]).directive('typeaheadPopup', function() {
      return {
        restrict: 'EA',
        scope: {
          matches: '=',
          query: '=',
          active: '=',
          position: '=',
          select: '&'
        },
        replace: true,
        templateUrl: 'template/typeahead/typeahead-popup.html',
        link: function(scope, element, attrs) {
          scope.templateUrl = attrs.templateUrl;
          scope.isOpen = function() {
            return scope.matches.length > 0;
          };
          scope.isActive = function(matchIdx) {
            return scope.active == matchIdx;
          };
          scope.selectActive = function(matchIdx) {
            scope.active = matchIdx;
          };
          scope.selectMatch = function(activeIdx) {
            scope.select({activeIdx: activeIdx});
          };
        }
      };
    }).directive('typeaheadMatch', ['$http', '$templateCache', '$compile', '$parse', function($http, $templateCache, $compile, $parse) {
      return {
        restrict: 'EA',
        scope: {
          index: '=',
          match: '=',
          query: '='
        },
        link: function(scope, element, attrs) {
          var tplUrl = $parse(attrs.templateUrl)(scope.$parent) || 'template/typeahead/typeahead-match.html';
          $http.get(tplUrl, {cache: $templateCache}).success(function(tplContent) {
            element.replaceWith($compile(tplContent.trim())(scope));
          });
        }
      };
    }]).filter('typeaheadHighlight', function() {
      function escapeRegexp(queryToEscape) {
        return queryToEscape.replace(/([.?*+^$[\]\\(){}|-])/g, "\\$1");
      }
      return function(matchItem, query) {
        return query ? matchItem.replace(new RegExp(escapeRegexp(query), 'gi'), '<strong>$&</strong>') : matchItem;
      };
    });
    angular.module("template/accordion/accordion-group.html", []).run(["$templateCache", function($templateCache) {
      $templateCache.put("template/accordion/accordion-group.html", "<dd>\n" + "  <a ng-click=\"isOpen = !isOpen\" ng-class=\"{ active: isOpen }\"  accordion-transclude=\"heading\">{{heading}}</a>\n" + "  <div class=\"content\" ng-class=\"{ active: isOpen }\" ng-transclude></div>\n" + "</dd>\n" + "");
    }]);
    angular.module("template/accordion/accordion.html", []).run(["$templateCache", function($templateCache) {
      $templateCache.put("template/accordion/accordion.html", "<dl class=\"accordion\" ng-transclude></dl>\n" + "");
    }]);
    angular.module("template/alert/alert.html", []).run(["$templateCache", function($templateCache) {
      $templateCache.put("template/alert/alert.html", "<div class='alert-box' ng-class='(type || \"\")'>\n" + "  <span ng-transclude></span>\n" + "  <a ng-show='closeable' class='close' ng-click='close()'>&times;</a>\n" + "</div>\n" + "");
    }]);
    angular.module("template/modal/backdrop.html", []).run(["$templateCache", function($templateCache) {
      $templateCache.put("template/modal/backdrop.html", "<div class=\"reveal-modal-bg fade\" ng-class=\"{in: animate}\" ng-click=\"close($event)\" style=\"display: block\"></div>\n" + "");
    }]);
    angular.module("template/modal/window.html", []).run(["$templateCache", function($templateCache) {
      $templateCache.put("template/modal/window.html", "<div tabindex=\"-1\" class=\"reveal-modal fade {{ windowClass }}\"\n" + "  ng-class=\"{in: animate}\" style=\"display: block; visibility: visible\">\n" + "  <div ng-transclude></div>\n" + "</div>\n" + "");
    }]);
    angular.module("template/pagination/pager.html", []).run(["$templateCache", function($templateCache) {
      $templateCache.put("template/pagination/pager.html", "<ul class=\"pagination\">\n" + "  <li ng-repeat=\"page in pages\" class=\"arrow\" ng-class=\"{unavailable: page.disabled, left: page.previous, right: page.next}\"><a ng-click=\"selectPage(page.number)\">{{page.text}}</a></li>\n" + "</ul>\n" + "");
    }]);
    angular.module("template/pagination/pagination.html", []).run(["$templateCache", function($templateCache) {
      $templateCache.put("template/pagination/pagination.html", "<ul class=\"pagination\">\n" + "  <li ng-repeat=\"page in pages\" ng-class=\"{arrow: $first || $last, current: page.active, unavailable: page.disabled}\"><a ng-click=\"selectPage(page.number)\">{{page.text}}</a></li>\n" + "</ul>\n" + "");
    }]);
    angular.module("template/tooltip/tooltip-html-unsafe-popup.html", []).run(["$templateCache", function($templateCache) {
      $templateCache.put("template/tooltip/tooltip-html-unsafe-popup.html", "<span class=\"tooltip tip-{{placement}}\"\n" + "  ng-class=\"{ in: isOpen(), fade: animation() }\"\n" + "  style=\"width: auto\">\n" + "  <span bind-html-unsafe=\"content\"></span>\n" + "  <span class=\"nub\"></span>\n" + "</span>\n" + "");
    }]);
    angular.module("template/tooltip/tooltip-popup.html", []).run(["$templateCache", function($templateCache) {
      $templateCache.put("template/tooltip/tooltip-popup.html", "<span class=\"tooltip tip-{{placement}}\"\n" + "  ng-class=\"{ in: isOpen(), fade: animation() }\"\n" + "  style=\"width: auto\">\n" + "  <span ng-bind=\"content\"></span>\n" + "  <span class=\"nub\"></span>\n" + "</span>\n" + "");
    }]);
    angular.module("template/popover/popover.html", []).run(["$templateCache", function($templateCache) {
      $templateCache.put("template/popover/popover.html", "<div class=\"joyride-tip-guide\" ng-class=\"{ in: isOpen(), fade: animation() }\">\n" + "  <span class=\"joyride-nub\" ng-class=\"{\n" + "    bottom: placement === 'top',\n" + "    left: placement === 'right',\n" + "    right: placement === 'left',\n" + "    top: placement === 'bottom'\n" + "  }\"></span>\n" + "  <div class=\"joyride-content-wrapper\">\n" + "    <h4 ng-bind=\"title\" ng-show=\"title\"></h4>\n" + "    <p ng-bind=\"content\"></p>\n" + "  </div>\n" + "</div>\n" + "");
    }]);
    angular.module("template/progressbar/bar.html", []).run(["$templateCache", function($templateCache) {
      $templateCache.put("template/progressbar/bar.html", "<span class=\"meter\" ng-transclude></span>\n" + "");
    }]);
    angular.module("template/progressbar/progress.html", []).run(["$templateCache", function($templateCache) {
      $templateCache.put("template/progressbar/progress.html", "<div class=\"progress\" ng-class=\"type\" ng-transclude></div>\n" + "");
    }]);
    angular.module("template/progressbar/progressbar.html", []).run(["$templateCache", function($templateCache) {
      $templateCache.put("template/progressbar/progressbar.html", "<div class=\"progress\" ng-class=\"type\">\n" + "  <span class=\"meter\" ng-transclude></span>\n" + "</div>\n" + "");
    }]);
    angular.module("template/rating/rating.html", []).run(["$templateCache", function($templateCache) {
      $templateCache.put("template/rating/rating.html", "<span ng-mouseleave=\"reset()\">\n" + "  <i ng-repeat=\"r in range\" ng-mouseenter=\"enter($index + 1)\" ng-click=\"rate($index + 1)\" class=\"fa\"\n" + "    ng-class=\"$index < val && (r.stateOn || 'fa-star') || (r.stateOff || 'fa-star-o')\"></i>\n" + "</span>\n" + "");
    }]);
    angular.module("template/tabs/tab.html", []).run(["$templateCache", function($templateCache) {
      $templateCache.put("template/tabs/tab.html", "<dd ng-class=\"{active: active}\">\n" + "  <a ng-click=\"select()\" tab-heading-transclude>{{heading}}</a>\n" + "</dd>\n" + "");
    }]);
    angular.module("template/tabs/tabset.html", []).run(["$templateCache", function($templateCache) {
      $templateCache.put("template/tabs/tabset.html", "<div class=\"tabbable\">\n" + "  <dl class=\"tabs\" ng-class=\"{'vertical': vertical}\" ng-transclude></dl>\n" + "  <div class=\"tabs-content\" ng-class=\"{'vertical': vertical}\">\n" + "    <div class=\"content\" \n" + "      ng-repeat=\"tab in tabs\" \n" + "      ng-class=\"{active: tab.active}\">\n" + "      <div tab-content-transclude=\"tab\"></div>\n" + "    </div>\n" + "  </div>\n" + "</div>\n" + "");
    }]);
    angular.module("template/topbar/has-dropdown.html", []).run(["$templateCache", function($templateCache) {
      $templateCache.put("template/topbar/has-dropdown.html", "<li class=\"has-dropdown\" ng-transclude></li>");
    }]);
    angular.module("template/topbar/toggle-top-bar.html", []).run(["$templateCache", function($templateCache) {
      $templateCache.put("template/topbar/toggle-top-bar.html", "<li class=\"toggle-topbar menu-icon\" ng-transclude></li>");
    }]);
    angular.module("template/topbar/top-bar-dropdown.html", []).run(["$templateCache", function($templateCache) {
      $templateCache.put("template/topbar/top-bar-dropdown.html", "<ul class=\"dropdown\" ng-transclude></ul>");
    }]);
    angular.module("template/topbar/top-bar-section.html", []).run(["$templateCache", function($templateCache) {
      $templateCache.put("template/topbar/top-bar-section.html", "<section class=\"top-bar-section\" ng-transclude></section>");
    }]);
    angular.module("template/topbar/top-bar.html", []).run(["$templateCache", function($templateCache) {
      $templateCache.put("template/topbar/top-bar.html", "<nav class=\"top-bar\" ng-transclude></nav>");
    }]);
    angular.module("template/tour/tour.html", []).run(["$templateCache", function($templateCache) {
      $templateCache.put("template/tour/tour.html", "<div class=\"joyride-tip-guide\" ng-class=\"{ in: isOpen(), fade: animation() }\">\n" + "  <span class=\"joyride-nub\" ng-class=\"{\n" + "    bottom: placement === 'top',\n" + "    left: placement === 'right',\n" + "    right: placement === 'left',\n" + "    top: placement === 'bottom'\n" + "  }\"></span>\n" + "  <div class=\"joyride-content-wrapper\">\n" + "    <h4 ng-bind=\"title\" ng-show=\"title\"></h4>\n" + "    <p ng-bind=\"content\"></p>\n" + "    <a class=\"small button joyride-next-tip\" ng-show=\"!isLastStep()\" ng-click=\"nextStep()\">Next</a>\n" + "    <a class=\"small button joyride-next-tip\" ng-show=\"isLastStep()\" ng-click=\"endTour()\">End</a>\n" + "    <a class=\"joyride-close-tip\" ng-click=\"endTour()\">&times;</a>\n" + "  </div>\n" + "</div>\n" + "");
    }]);
    angular.module("template/typeahead/typeahead-match.html", []).run(["$templateCache", function($templateCache) {
      $templateCache.put("template/typeahead/typeahead-match.html", "<a tabindex=\"-1\" bind-html-unsafe=\"match.label | typeaheadHighlight:query\"></a>");
    }]);
    angular.module("template/typeahead/typeahead-popup.html", []).run(["$templateCache", function($templateCache) {
      $templateCache.put("template/typeahead/typeahead-popup.html", "<ul class=\"f-dropdown\" ng-style=\"{display: isOpen()&&'block' || 'none', top: position.top+'px', left: position.left+'px'}\">\n" + "    <li ng-repeat=\"match in matches\" ng-class=\"{active: isActive($index) }\" ng-mouseenter=\"selectActive($index)\" ng-click=\"selectMatch($index)\">\n" + "        <div typeahead-match index=\"$index\" match=\"match\" query=\"query\" template-url=\"templateUrl\"></div>\n" + "    </li>\n" + "</ul>\n" + "");
    }]);
  })();
  return _retrieveGlobal();
});

System.registerDynamic("bower:angular-foundation@0.8.0.js", ["bower:angular-foundation@0.8.0/mm-foundation-tpls.js"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = $__require('bower:angular-foundation@0.8.0/mm-foundation-tpls.js');
  global.define = __define;
  return module.exports;
});

System.registerDynamic("bower:angular-inform@0.0.18/dist/angular-inform.js", [], false, function(__require, __exports, __module) {
  var _retrieveGlobal = System.get("@@global-helpers").prepareGlobal(__module.id, null, null);
  (function() {
    (function(angular) {
      var inform = angular.module('inform', []);
      inform.controller('InformCtrl', ["$scope", "inform", function($scope, inform) {
        $scope.messages = inform.messages();
        $scope.remove = inform.remove;
        $scope.cancelTimeout = inform.cancelTimeout;
        $scope.setTimeout = inform.setTimeout;
      }]);
      inform.directive('inform', function() {
        return {
          restrict: 'AE',
          templateUrl: 'angular-inform/directive.ng.html',
          controller: 'InformCtrl'
        };
      });
      inform.provider('inform', function() {
        var provider = this;
        this._defaults = {
          type: 'default',
          ttl: 5000
        };
        this.defaults = function(options) {
          provider._defaults = angular.extend(provider._defaults, options || {});
          return provider._defaults;
        };
        this.$get = ['$timeout', '$sce', function($timeout, $sce) {
          var _messages = [];
          function _indexOf(predicate) {
            var i = _messages.length;
            while (i--) {
              if (predicate(_messages[i])) {
                return i;
              }
            }
            return -1;
          }
          function cancelTimeout(msg) {
            if (msg.timeout) {
              $timeout.cancel(msg.timeout);
              delete msg.timeout;
            }
          }
          function setTimeout(msg) {
            cancelTimeout(msg);
            if (msg.ttl > 0) {
              msg.timeout = $timeout(function() {
                remove(msg);
              }, msg.ttl);
            }
          }
          function add(content, options) {
            var msg = angular.extend({}, provider._defaults, options);
            if (!angular.isString(content)) {
              content = '<pre><code>' + JSON.stringify(content, null, '  ') + '</code></pre>';
              msg.html = true;
            }
            var idx = _indexOf(function(x) {
              return x.content.toString() === content && x.type == msg.type;
            });
            if (idx >= 0) {
              msg = _messages[idx];
              msg.count += 1;
            } else {
              msg.content = content;
              if (msg.html) {
                msg.content = $sce.trustAsHtml(content);
              }
              msg.tickCount = +new Date();
              msg.count = 1;
              _messages.push(msg);
            }
            setTimeout(msg);
            return msg;
          }
          function remove(msg) {
            var idx = _indexOf(function(x) {
              return x === msg;
            });
            if (idx >= 0) {
              _messages.splice(idx, 1);
              cancelTimeout(msg);
            }
          }
          function clear() {
            _messages.length = 0;
          }
          return {
            messages: function() {
              return _messages;
            },
            add: add,
            remove: remove,
            clear: clear,
            cancelTimeout: cancelTimeout,
            setTimeout: setTimeout
          };
        }];
      });
      angular.module('inform-exception', ['inform']).config(["$provide", function($provide) {
        $provide.decorator('$exceptionHandler', ['$delegate', '$injector', function($delegate, $injector) {
          var inform;
          return function(exception, cause) {
            try {
              inform = inform || $injector.get('inform');
              inform.add(exception.toString(), {
                type: 'danger',
                ttl: 0
              });
            } catch (ex) {
              console.log('$exceptionHandler', ex);
            }
            $delegate(exception, cause);
          };
        }]);
      }]);
      angular.module('inform-http-exception', ['inform']).factory('informHttpInterceptor', ["$q", "inform", function($q, inform) {
        function interceptor(rejection) {
          try {
            var msg = 'Network error (' + rejection.status + '): ' + rejection.statusText;
            inform.add(msg, {
              type: 'danger',
              ttl: 0
            });
          } catch (ex) {
            console.log('$httpProvider', ex);
          }
          return $q.reject(rejection);
        }
        return {
          requestError: interceptor,
          responseError: interceptor
        };
      }]).config(["$httpProvider", function($httpProvider) {
        $httpProvider.interceptors.push('informHttpInterceptor');
      }]);
      angular.module('inform').run(['$templateCache', function($templateCache) {
        $templateCache.put('angular-inform/directive.ng.html', '<div class=\"inform\"><div ng-repeat=\"msg in messages | orderBy:\'-tickCount\'\" class=\"inform-message-wrap\"><div class=\"inform-message alert alert-{{ msg.type }} alert-dismissible\" role=\"alert\" ng-mouseenter=\"cancelTimeout(msg)\" ng-mouseleave=\"setTimeout(msg)\"><button type=\"button\" class=\"close\" ng-click=\"remove(msg)\"><span>&times;</span></button> <span class=\"inform-message-content\"><span class=\"badge inform-badge\" ng-if=\"msg.count > 1\">{{ msg.count }}</span> <span ng-if=\"msg.html\" ng-bind-html=\"msg.content\"></span> <span ng-if=\"!msg.html\" ng-bind=\"msg.content\"></span></span></div></div></div>');
      }]);
    })(angular);
  })();
  return _retrieveGlobal();
});

System.registerDynamic("bower:angular-inform@0.0.18.js", ["bower:angular-inform@0.0.18/dist/angular-inform.js"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = $__require('bower:angular-inform@0.0.18/dist/angular-inform.js');
  global.define = __define;
  return module.exports;
});

System.registerDynamic("bower:angular-input-masks@2.1.1/angular-input-masks-standalone.min.js", [], false, function(__require, __exports, __module) {
  var _retrieveGlobal = System.get("@@global-helpers").prepareGlobal(__module.id, null, null);
  (function() {
    "format global";
    require = function e(t, n, r) {
      function i(a, o) {
        if (!n[a]) {
          if (!t[a]) {
            var u = "function" == typeof require && require;
            if (!o && u)
              return u(a, !0);
            if (s)
              return s(a, !0);
            var l = new Error("Cannot find module '" + a + "'");
            throw l.code = "MODULE_NOT_FOUND", l;
          }
          var c = n[a] = {exports: {}};
          t[a][0].call(c.exports, function(e) {
            var n = t[a][1][e];
            return i(n ? n : e);
          }, c, c.exports, e, t, n, r);
        }
        return n[a].exports;
      }
      for (var s = "function" == typeof require && require,
          a = 0; a < r.length; a++)
        i(r[a]);
      return i;
    }({
      1: [function(e, t, n) {
        !function(e, r) {
          "function" == typeof define && define.amd ? define([], r) : "object" == typeof n ? t.exports = r() : e.BrV = r();
        }(this, function() {
          function e(e, t) {
            var n = t.algorithmSteps,
                r = a.handleStr[n[0]](e),
                i = a.sum[n[1]](r, t.pesos),
                s = a.rest[n[2]](i),
                o = parseInt(r[t.dvpos]),
                u = a.expectedDV[n[3]](s, r);
            return o === u;
          }
          function t(t, n) {
            if (n.match && !n.match.test(t))
              return !1;
            for (var r = 0; r < n.dvs.length; r++)
              if (!e(t, n.dvs[r]))
                return !1;
            return !0;
          }
          var n = {};
          n.validate = function(e) {
            var t = [6, 5, 4, 3, 2, 9, 8, 7, 6, 5, 4, 3, 2];
            e = e.replace(/[^\d]/g, "");
            var n = /^(0{14}|1{14}|2{14}|3{14}|4{14}|5{14}|6{14}|7{14}|8{14}|9{14})$/;
            if (!e || 14 !== e.length || n.test(e))
              return !1;
            e = e.split("");
            for (var r = 0,
                i = 0; 12 > r; r++)
              i += e[r] * t[r + 1];
            if (i = 11 - i % 11, i = i >= 10 ? 0 : i, parseInt(e[12]) !== i)
              return !1;
            for (r = 0, i = 0; 12 >= r; r++)
              i += e[r] * t[r];
            return i = 11 - i % 11, i = i >= 10 ? 0 : i, parseInt(e[13]) !== i ? !1 : !0;
          };
          var r = {};
          r.validate = function(e) {
            function t(t) {
              for (var n = 0,
                  r = t - 9,
                  i = 0; 9 > i; i++)
                n += parseInt(e.charAt(i + r)) * (i + 1);
              return n % 11 % 10 === parseInt(e.charAt(t));
            }
            e = e.replace(/[^\d]+/g, "");
            var n = /^(0{11}|1{11}|2{11}|3{11}|4{11}|5{11}|6{11}|7{11}|8{11}|9{11})$/;
            return !e || 11 !== e.length || n.test(e) ? !1 : t(9) && t(10);
          };
          var i = function(e) {
            return this instanceof i ? (this.rules = s[e] || [], this.rule, i.prototype._defineRule = function(e) {
              this.rule = void 0;
              for (var t = 0; t < this.rules.length && void 0 === this.rule; t++) {
                var n = e.replace(/[^\d]/g, ""),
                    r = this.rules[t];
                n.length !== r.chars || r.match && !r.match.test(e) || (this.rule = r);
              }
              return !!this.rule;
            }, void(i.prototype.validate = function(e) {
              return e && this._defineRule(e) ? this.rule.validate(e) : !1;
            })) : new i(e);
          },
              s = {},
              a = {
                handleStr: {
                  onlyNumbers: function(e) {
                    return e.replace(/[^\d]/g, "").split("");
                  },
                  mgSpec: function(e) {
                    var t = e.replace(/[^\d]/g, "");
                    return t = t.substr(0, 3) + "0" + t.substr(3, t.length), t.split("");
                  }
                },
                sum: {
                  normalSum: function(e, t) {
                    for (var n = e,
                        r = 0,
                        i = 0; i < t.length; i++)
                      r += parseInt(n[i]) * t[i];
                    return r;
                  },
                  individualSum: function(e, t) {
                    for (var n = e,
                        r = 0,
                        i = 0; i < t.length; i++) {
                      var s = parseInt(n[i]) * t[i];
                      r += s % 10 + parseInt(s / 10);
                    }
                    return r;
                  },
                  apSpec: function(e, t) {
                    var n = this.normalSum(e, t),
                        r = e.join("");
                    return r >= "030000010" && "030170009" >= r ? n + 5 : r >= "030170010" && "030190229" >= r ? n + 9 : n;
                  }
                },
                rest: {
                  mod11: function(e) {
                    return e % 11;
                  },
                  mod10: function(e) {
                    return e % 10;
                  },
                  mod9: function(e) {
                    return e % 9;
                  }
                },
                expectedDV: {
                  minusRestOf11: function(e) {
                    return 2 > e ? 0 : 11 - e;
                  },
                  minusRestOf11v2: function(e) {
                    return 2 > e ? 11 - e - 10 : 11 - e;
                  },
                  minusRestOf10: function(e) {
                    return 1 > e ? 0 : 10 - e;
                  },
                  mod10: function(e) {
                    return e % 10;
                  },
                  goSpec: function(e, t) {
                    var n = t.join("");
                    return 1 === e ? n >= "101031050" && "101199979" >= n ? 1 : 0 : 0 === e ? 0 : 11 - e;
                  },
                  apSpec: function(e, t) {
                    var n = t.join("");
                    return 0 === e ? n >= "030170010" && "030190229" >= n ? 1 : 0 : 1 === e ? 0 : 11 - e;
                  },
                  voidFn: function(e) {
                    return e;
                  }
                }
              };
          return s.PE = [{
            chars: 9,
            dvs: [{
              dvpos: 7,
              pesos: [8, 7, 6, 5, 4, 3, 2],
              algorithmSteps: ["onlyNumbers", "normalSum", "mod11", "minusRestOf11"]
            }, {
              dvpos: 8,
              pesos: [9, 8, 7, 6, 5, 4, 3, 2],
              algorithmSteps: ["onlyNumbers", "normalSum", "mod11", "minusRestOf11"]
            }],
            validate: function(e) {
              return t(e, this);
            }
          }, {
            chars: 14,
            pesos: [[1, 2, 3, 4, 5, 9, 8, 7, 6, 5, 4, 3, 2]],
            dvs: [{
              dvpos: 13,
              pesos: [5, 4, 3, 2, 1, 9, 8, 7, 6, 5, 4, 3, 2],
              algorithmSteps: ["onlyNumbers", "normalSum", "mod11", "minusRestOf11v2"]
            }],
            validate: function(e) {
              return t(e, this);
            }
          }], s.RS = [{
            chars: 10,
            dvs: [{
              dvpos: 9,
              pesos: [2, 9, 8, 7, 6, 5, 4, 3, 2],
              algorithmSteps: ["onlyNumbers", "normalSum", "mod11", "minusRestOf11"]
            }],
            validate: function(e) {
              return t(e, this);
            }
          }], s.AC = [{
            chars: 13,
            match: /^01/,
            dvs: [{
              dvpos: 11,
              pesos: [4, 3, 2, 9, 8, 7, 6, 5, 4, 3, 2],
              algorithmSteps: ["onlyNumbers", "normalSum", "mod11", "minusRestOf11"]
            }, {
              dvpos: 12,
              pesos: [5, 4, 3, 2, 9, 8, 7, 6, 5, 4, 3, 2],
              algorithmSteps: ["onlyNumbers", "normalSum", "mod11", "minusRestOf11"]
            }],
            validate: function(e) {
              return t(e, this);
            }
          }], s.MG = [{
            chars: 13,
            dvs: [{
              dvpos: 12,
              pesos: [1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2],
              algorithmSteps: ["mgSpec", "individualSum", "mod10", "minusRestOf10"]
            }, {
              dvpos: 12,
              pesos: [3, 2, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2],
              algorithmSteps: ["onlyNumbers", "normalSum", "mod11", "minusRestOf11"]
            }],
            validate: function(e) {
              return t(e, this);
            }
          }], s.SP = [{
            chars: 12,
            match: /^[0-9]/,
            dvs: [{
              dvpos: 8,
              pesos: [1, 3, 4, 5, 6, 7, 8, 10],
              algorithmSteps: ["onlyNumbers", "normalSum", "mod11", "mod10"]
            }, {
              dvpos: 11,
              pesos: [3, 2, 10, 9, 8, 7, 6, 5, 4, 3, 2],
              algorithmSteps: ["onlyNumbers", "normalSum", "mod11", "mod10"]
            }],
            validate: function(e) {
              return t(e, this);
            }
          }, {
            chars: 12,
            match: /^P/i,
            dvs: [{
              dvpos: 8,
              pesos: [1, 3, 4, 5, 6, 7, 8, 10],
              algorithmSteps: ["onlyNumbers", "normalSum", "mod11", "mod10"]
            }],
            validate: function(e) {
              return t(e, this);
            }
          }], s.DF = [{
            chars: 13,
            dvs: [{
              dvpos: 11,
              pesos: [4, 3, 2, 9, 8, 7, 6, 5, 4, 3, 2],
              algorithmSteps: ["onlyNumbers", "normalSum", "mod11", "minusRestOf11"]
            }, {
              dvpos: 12,
              pesos: [5, 4, 3, 2, 9, 8, 7, 6, 5, 4, 3, 2],
              algorithmSteps: ["onlyNumbers", "normalSum", "mod11", "minusRestOf11"]
            }],
            validate: function(e) {
              return t(e, this);
            }
          }], s.ES = [{
            chars: 9,
            dvs: [{
              dvpos: 8,
              pesos: [9, 8, 7, 6, 5, 4, 3, 2],
              algorithmSteps: ["onlyNumbers", "normalSum", "mod11", "minusRestOf11"]
            }],
            validate: function(e) {
              return t(e, this);
            }
          }], s.BA = [{
            chars: 8,
            match: /^[0123458]/,
            dvs: [{
              dvpos: 7,
              pesos: [7, 6, 5, 4, 3, 2],
              algorithmSteps: ["onlyNumbers", "normalSum", "mod10", "minusRestOf10"]
            }, {
              dvpos: 6,
              pesos: [8, 7, 6, 5, 4, 3, 0, 2],
              algorithmSteps: ["onlyNumbers", "normalSum", "mod10", "minusRestOf10"]
            }],
            validate: function(e) {
              return t(e, this);
            }
          }, {
            chars: 8,
            match: /^[679]/,
            dvs: [{
              dvpos: 7,
              pesos: [7, 6, 5, 4, 3, 2],
              algorithmSteps: ["onlyNumbers", "normalSum", "mod11", "minusRestOf11"]
            }, {
              dvpos: 6,
              pesos: [8, 7, 6, 5, 4, 3, 0, 2],
              algorithmSteps: ["onlyNumbers", "normalSum", "mod11", "minusRestOf11"]
            }],
            validate: function(e) {
              return t(e, this);
            }
          }, {
            chars: 9,
            match: /^[0-9][0123458]/,
            dvs: [{
              dvpos: 8,
              pesos: [8, 7, 6, 5, 4, 3, 2],
              algorithmSteps: ["onlyNumbers", "normalSum", "mod10", "minusRestOf10"]
            }, {
              dvpos: 7,
              pesos: [9, 8, 7, 6, 5, 4, 3, 0, 2],
              algorithmSteps: ["onlyNumbers", "normalSum", "mod10", "minusRestOf10"]
            }],
            validate: function(e) {
              return t(e, this);
            }
          }, {
            chars: 9,
            match: /^[0-9][679]/,
            dvs: [{
              dvpos: 8,
              pesos: [8, 7, 6, 5, 4, 3, 2],
              algorithmSteps: ["onlyNumbers", "normalSum", "mod11", "minusRestOf11"]
            }, {
              dvpos: 7,
              pesos: [9, 8, 7, 6, 5, 4, 3, 0, 2],
              algorithmSteps: ["onlyNumbers", "normalSum", "mod11", "minusRestOf11"]
            }],
            validate: function(e) {
              return t(e, this);
            }
          }], s.AM = [{
            chars: 9,
            dvs: [{
              dvpos: 8,
              pesos: [9, 8, 7, 6, 5, 4, 3, 2],
              algorithmSteps: ["onlyNumbers", "normalSum", "mod11", "minusRestOf11"]
            }],
            validate: function(e) {
              return t(e, this);
            }
          }], s.RN = [{
            chars: 9,
            match: /^20/,
            dvs: [{
              dvpos: 8,
              pesos: [9, 8, 7, 6, 5, 4, 3, 2],
              algorithmSteps: ["onlyNumbers", "normalSum", "mod11", "minusRestOf11"]
            }],
            validate: function(e) {
              return t(e, this);
            }
          }, {
            chars: 10,
            match: /^20/,
            dvs: [{
              dvpos: 8,
              pesos: [10, 9, 8, 7, 6, 5, 4, 3, 2],
              algorithmSteps: ["onlyNumbers", "normalSum", "mod11", "minusRestOf11"]
            }],
            validate: function(e) {
              return t(e, this);
            }
          }], s.RO = [{
            chars: 14,
            dvs: [{
              dvpos: 13,
              pesos: [6, 5, 4, 3, 2, 9, 8, 7, 6, 5, 4, 3, 2],
              algorithmSteps: ["onlyNumbers", "normalSum", "mod11", "minusRestOf11"]
            }],
            validate: function(e) {
              return t(e, this);
            }
          }], s.PR = [{
            chars: 10,
            dvs: [{
              dvpos: 8,
              pesos: [3, 2, 7, 6, 5, 4, 3, 2],
              algorithmSteps: ["onlyNumbers", "normalSum", "mod11", "minusRestOf11"]
            }, {
              dvpos: 9,
              pesos: [4, 3, 2, 7, 6, 5, 4, 3, 2],
              algorithmSteps: ["onlyNumbers", "normalSum", "mod11", "minusRestOf11"]
            }],
            validate: function(e) {
              return t(e, this);
            }
          }], s.SC = [{
            chars: 9,
            dvs: [{
              dvpos: 8,
              pesos: [9, 8, 7, 6, 5, 4, 3, 2],
              algorithmSteps: ["onlyNumbers", "normalSum", "mod11", "minusRestOf11"]
            }],
            validate: function(e) {
              return t(e, this);
            }
          }], s.RJ = [{
            chars: 8,
            dvs: [{
              dvpos: 7,
              pesos: [2, 7, 6, 5, 4, 3, 2],
              algorithmSteps: ["onlyNumbers", "normalSum", "mod11", "minusRestOf11"]
            }],
            validate: function(e) {
              return t(e, this);
            }
          }], s.PA = [{
            chars: 9,
            match: /^15/,
            dvs: [{
              dvpos: 8,
              pesos: [9, 8, 7, 6, 5, 4, 3, 2],
              algorithmSteps: ["onlyNumbers", "normalSum", "mod11", "minusRestOf11"]
            }],
            validate: function(e) {
              return t(e, this);
            }
          }], s.SE = [{
            chars: 9,
            dvs: [{
              dvpos: 8,
              pesos: [9, 8, 7, 6, 5, 4, 3, 2],
              algorithmSteps: ["onlyNumbers", "normalSum", "mod11", "minusRestOf11"]
            }],
            validate: function(e) {
              return t(e, this);
            }
          }], s.PB = [{
            chars: 9,
            dvs: [{
              dvpos: 8,
              pesos: [9, 8, 7, 6, 5, 4, 3, 2],
              algorithmSteps: ["onlyNumbers", "normalSum", "mod11", "minusRestOf11"]
            }],
            validate: function(e) {
              return t(e, this);
            }
          }], s.CE = [{
            chars: 9,
            dvs: [{
              dvpos: 8,
              pesos: [9, 8, 7, 6, 5, 4, 3, 2],
              algorithmSteps: ["onlyNumbers", "normalSum", "mod11", "minusRestOf11"]
            }],
            validate: function(e) {
              return t(e, this);
            }
          }], s.PI = [{
            chars: 9,
            dvs: [{
              dvpos: 8,
              pesos: [9, 8, 7, 6, 5, 4, 3, 2],
              algorithmSteps: ["onlyNumbers", "normalSum", "mod11", "minusRestOf11"]
            }],
            validate: function(e) {
              return t(e, this);
            }
          }], s.MA = [{
            chars: 9,
            match: /^12/,
            dvs: [{
              dvpos: 8,
              pesos: [9, 8, 7, 6, 5, 4, 3, 2],
              algorithmSteps: ["onlyNumbers", "normalSum", "mod11", "minusRestOf11"]
            }],
            validate: function(e) {
              return t(e, this);
            }
          }], s.MT = [{
            chars: 11,
            dvs: [{
              dvpos: 10,
              pesos: [3, 2, 9, 8, 7, 6, 5, 4, 3, 2],
              algorithmSteps: ["onlyNumbers", "normalSum", "mod11", "minusRestOf11"]
            }],
            validate: function(e) {
              return t(e, this);
            }
          }], s.MS = [{
            chars: 9,
            match: /^28/,
            dvs: [{
              dvpos: 8,
              pesos: [9, 8, 7, 6, 5, 4, 3, 2],
              algorithmSteps: ["onlyNumbers", "normalSum", "mod11", "minusRestOf11"]
            }],
            validate: function(e) {
              return t(e, this);
            }
          }], s.TO = [{
            chars: 11,
            match: /^[0-9]{2}((0[123])|(99))/,
            dvs: [{
              dvpos: 10,
              pesos: [9, 8, 0, 0, 7, 6, 5, 4, 3, 2],
              algorithmSteps: ["onlyNumbers", "normalSum", "mod11", "minusRestOf11"]
            }],
            validate: function(e) {
              return t(e, this);
            }
          }], s.AL = [{
            chars: 9,
            match: /^24[03578]/,
            dvs: [{
              dvpos: 8,
              pesos: [9, 8, 7, 6, 5, 4, 3, 2],
              algorithmSteps: ["onlyNumbers", "normalSum", "mod11", "minusRestOf11"]
            }],
            validate: function(e) {
              return t(e, this);
            }
          }], s.RR = [{
            chars: 9,
            match: /^24/,
            dvs: [{
              dvpos: 8,
              pesos: [1, 2, 3, 4, 5, 6, 7, 8],
              algorithmSteps: ["onlyNumbers", "normalSum", "mod9", "voidFn"]
            }],
            validate: function(e) {
              return t(e, this);
            }
          }], s.GO = [{
            chars: 9,
            match: /^1[015]/,
            dvs: [{
              dvpos: 8,
              pesos: [9, 8, 7, 6, 5, 4, 3, 2],
              algorithmSteps: ["onlyNumbers", "normalSum", "mod11", "goSpec"]
            }],
            validate: function(e) {
              return t(e, this);
            }
          }], s.AP = [{
            chars: 9,
            match: /^03/,
            dvs: [{
              dvpos: 8,
              pesos: [9, 8, 7, 6, 5, 4, 3, 2],
              algorithmSteps: ["onlyNumbers", "apSpec", "mod11", "apSpec"]
            }],
            validate: function(e) {
              return t(e, this);
            }
          }], {
            ie: i,
            cpf: r,
            cnpj: n
          };
        });
      }, {}],
      2: [function(e, t, n) {
        !function(e, r) {
          "object" == typeof n && "undefined" != typeof t ? t.exports = r() : "function" == typeof define && define.amd ? define(r) : e.moment = r();
        }(this, function() {
          "use strict";
          function n() {
            return Un.apply(null, arguments);
          }
          function r(e) {
            Un = e;
          }
          function i(e) {
            return "[object Array]" === Object.prototype.toString.call(e);
          }
          function s(e) {
            return e instanceof Date || "[object Date]" === Object.prototype.toString.call(e);
          }
          function a(e, t) {
            var n,
                r = [];
            for (n = 0; n < e.length; ++n)
              r.push(t(e[n], n));
            return r;
          }
          function o(e, t) {
            return Object.prototype.hasOwnProperty.call(e, t);
          }
          function u(e, t) {
            for (var n in t)
              o(t, n) && (e[n] = t[n]);
            return o(t, "toString") && (e.toString = t.toString), o(t, "valueOf") && (e.valueOf = t.valueOf), e;
          }
          function l(e, t, n, r) {
            return Te(e, t, n, r, !0).utc();
          }
          function c() {
            return {
              empty: !1,
              unusedTokens: [],
              unusedInput: [],
              overflow: -2,
              charsLeftOver: 0,
              nullInput: !1,
              invalidMonth: null,
              invalidFormat: !1,
              userInvalidated: !1,
              iso: !1
            };
          }
          function f(e) {
            return null == e._pf && (e._pf = c()), e._pf;
          }
          function d(e) {
            if (null == e._isValid) {
              var t = f(e);
              e._isValid = !(isNaN(e._d.getTime()) || !(t.overflow < 0) || t.empty || t.invalidMonth || t.invalidWeekday || t.nullInput || t.invalidFormat || t.userInvalidated), e._strict && (e._isValid = e._isValid && 0 === t.charsLeftOver && 0 === t.unusedTokens.length && void 0 === t.bigHour);
            }
            return e._isValid;
          }
          function m(e) {
            var t = l(NaN);
            return null != e ? u(f(t), e) : f(t).userInvalidated = !0, t;
          }
          function h(e, t) {
            var n,
                r,
                i;
            if ("undefined" != typeof t._isAMomentObject && (e._isAMomentObject = t._isAMomentObject), "undefined" != typeof t._i && (e._i = t._i), "undefined" != typeof t._f && (e._f = t._f), "undefined" != typeof t._l && (e._l = t._l), "undefined" != typeof t._strict && (e._strict = t._strict), "undefined" != typeof t._tzm && (e._tzm = t._tzm), "undefined" != typeof t._isUTC && (e._isUTC = t._isUTC), "undefined" != typeof t._offset && (e._offset = t._offset), "undefined" != typeof t._pf && (e._pf = f(t)), "undefined" != typeof t._locale && (e._locale = t._locale), Cn.length > 0)
              for (n in Cn)
                r = Cn[n], i = t[r], "undefined" != typeof i && (e[r] = i);
            return e;
          }
          function p(e) {
            h(this, e), this._d = new Date(null != e._d ? e._d.getTime() : NaN), Vn === !1 && (Vn = !0, n.updateOffset(this), Vn = !1);
          }
          function v(e) {
            return e instanceof p || null != e && null != e._isAMomentObject;
          }
          function g(e) {
            return 0 > e ? Math.ceil(e) : Math.floor(e);
          }
          function y(e) {
            var t = +e,
                n = 0;
            return 0 !== t && isFinite(t) && (n = g(t)), n;
          }
          function _(e, t, n) {
            var r,
                i = Math.min(e.length, t.length),
                s = Math.abs(e.length - t.length),
                a = 0;
            for (r = 0; i > r; r++)
              (n && e[r] !== t[r] || !n && y(e[r]) !== y(t[r])) && a++;
            return a + s;
          }
          function S() {}
          function M(e) {
            return e ? e.toLowerCase().replace("_", "-") : e;
          }
          function k(e) {
            for (var t,
                n,
                r,
                i,
                s = 0; s < e.length; ) {
              for (i = M(e[s]).split("-"), t = i.length, n = M(e[s + 1]), n = n ? n.split("-") : null; t > 0; ) {
                if (r = w(i.slice(0, t).join("-")))
                  return r;
                if (n && n.length >= t && _(i, n, !0) >= t - 1)
                  break;
                t--;
              }
              s++;
            }
            return null;
          }
          function w(n) {
            var r = null;
            if (!Gn[n] && "undefined" != typeof t && t && t.exports)
              try {
                r = En._abbr, e("./locale/" + n), D(r);
              } catch (i) {}
            return Gn[n];
          }
          function D(e, t) {
            var n;
            return e && (n = "undefined" == typeof t ? Y(e) : b(e, t), n && (En = n)), En._abbr;
          }
          function b(e, t) {
            return null !== t ? (t.abbr = e, Gn[e] = Gn[e] || new S, Gn[e].set(t), D(e), Gn[e]) : (delete Gn[e], null);
          }
          function Y(e) {
            var t;
            if (e && e._locale && e._locale._abbr && (e = e._locale._abbr), !e)
              return En;
            if (!i(e)) {
              if (t = w(e))
                return t;
              e = [e];
            }
            return k(e);
          }
          function O(e, t) {
            var n = e.toLowerCase();
            In[n] = In[n + "s"] = In[t] = e;
          }
          function $(e) {
            return "string" == typeof e ? In[e] || In[e.toLowerCase()] : void 0;
          }
          function N(e) {
            var t,
                n,
                r = {};
            for (n in e)
              o(e, n) && (t = $(n), t && (r[t] = e[n]));
            return r;
          }
          function T(e, t) {
            return function(r) {
              return null != r ? (x(this, e, r), n.updateOffset(this, t), this) : P(this, e);
            };
          }
          function P(e, t) {
            return e._d["get" + (e._isUTC ? "UTC" : "") + t]();
          }
          function x(e, t, n) {
            return e._d["set" + (e._isUTC ? "UTC" : "") + t](n);
          }
          function A(e, t) {
            var n;
            if ("object" == typeof e)
              for (n in e)
                this.set(n, e[n]);
            else if (e = $(e), "function" == typeof this[e])
              return this[e](t);
            return this;
          }
          function F(e, t, n) {
            var r = "" + Math.abs(e),
                i = t - r.length,
                s = e >= 0;
            return (s ? n ? "+" : "" : "-") + Math.pow(10, Math.max(0, i)).toString().substr(1) + r;
          }
          function R(e, t, n, r) {
            var i = r;
            "string" == typeof r && (i = function() {
              return this[r]();
            }), e && (Hn[e] = i), t && (Hn[t[0]] = function() {
              return F(i.apply(this, arguments), t[1], t[2]);
            }), n && (Hn[n] = function() {
              return this.localeData().ordinal(i.apply(this, arguments), e);
            });
          }
          function U(e) {
            return e.match(/\[[\s\S]/) ? e.replace(/^\[|\]$/g, "") : e.replace(/\\/g, "");
          }
          function E(e) {
            var t,
                n,
                r = e.match(Wn);
            for (t = 0, n = r.length; n > t; t++)
              Hn[r[t]] ? r[t] = Hn[r[t]] : r[t] = U(r[t]);
            return function(i) {
              var s = "";
              for (t = 0; n > t; t++)
                s += r[t] instanceof Function ? r[t].call(i, e) : r[t];
              return s;
            };
          }
          function C(e, t) {
            return e.isValid() ? (t = V(t, e.localeData()), jn[t] = jn[t] || E(t), jn[t](e)) : e.localeData().invalidDate();
          }
          function V(e, t) {
            function n(e) {
              return t.longDateFormat(e) || e;
            }
            var r = 5;
            for (Ln.lastIndex = 0; r >= 0 && Ln.test(e); )
              e = e.replace(Ln, n), Ln.lastIndex = 0, r -= 1;
            return e;
          }
          function G(e) {
            return "function" == typeof e && "[object Function]" === Object.prototype.toString.call(e);
          }
          function I(e, t, n) {
            ar[e] = G(t) ? t : function(e) {
              return e && n ? n : t;
            };
          }
          function W(e, t) {
            return o(ar, e) ? ar[e](t._strict, t._locale) : new RegExp(L(e));
          }
          function L(e) {
            return e.replace("\\", "").replace(/\\(\[)|\\(\])|\[([^\]\[]*)\]|\\(.)/g, function(e, t, n, r, i) {
              return t || n || r || i;
            }).replace(/[-\/\\^$*+?.()|[\]{}]/g, "\\$&");
          }
          function j(e, t) {
            var n,
                r = t;
            for ("string" == typeof e && (e = [e]), "number" == typeof t && (r = function(e, n) {
              n[t] = y(e);
            }), n = 0; n < e.length; n++)
              or[e[n]] = r;
          }
          function H(e, t) {
            j(e, function(e, n, r, i) {
              r._w = r._w || {}, t(e, r._w, r, i);
            });
          }
          function B(e, t, n) {
            null != t && o(or, e) && or[e](t, n._a, n, e);
          }
          function Z(e, t) {
            return new Date(Date.UTC(e, t + 1, 0)).getUTCDate();
          }
          function z(e) {
            return this._months[e.month()];
          }
          function q(e) {
            return this._monthsShort[e.month()];
          }
          function J(e, t, n) {
            var r,
                i,
                s;
            for (this._monthsParse || (this._monthsParse = [], this._longMonthsParse = [], this._shortMonthsParse = []), r = 0; 12 > r; r++) {
              if (i = l([2e3, r]), n && !this._longMonthsParse[r] && (this._longMonthsParse[r] = new RegExp("^" + this.months(i, "").replace(".", "") + "$", "i"), this._shortMonthsParse[r] = new RegExp("^" + this.monthsShort(i, "").replace(".", "") + "$", "i")), n || this._monthsParse[r] || (s = "^" + this.months(i, "") + "|^" + this.monthsShort(i, ""), this._monthsParse[r] = new RegExp(s.replace(".", ""), "i")), n && "MMMM" === t && this._longMonthsParse[r].test(e))
                return r;
              if (n && "MMM" === t && this._shortMonthsParse[r].test(e))
                return r;
              if (!n && this._monthsParse[r].test(e))
                return r;
            }
          }
          function Q(e, t) {
            var n;
            return "string" == typeof t && (t = e.localeData().monthsParse(t), "number" != typeof t) ? e : (n = Math.min(e.date(), Z(e.year(), t)), e._d["set" + (e._isUTC ? "UTC" : "") + "Month"](t, n), e);
          }
          function X(e) {
            return null != e ? (Q(this, e), n.updateOffset(this, !0), this) : P(this, "Month");
          }
          function K() {
            return Z(this.year(), this.month());
          }
          function ee(e) {
            var t,
                n = e._a;
            return n && -2 === f(e).overflow && (t = n[lr] < 0 || n[lr] > 11 ? lr : n[cr] < 1 || n[cr] > Z(n[ur], n[lr]) ? cr : n[fr] < 0 || n[fr] > 24 || 24 === n[fr] && (0 !== n[dr] || 0 !== n[mr] || 0 !== n[hr]) ? fr : n[dr] < 0 || n[dr] > 59 ? dr : n[mr] < 0 || n[mr] > 59 ? mr : n[hr] < 0 || n[hr] > 999 ? hr : -1, f(e)._overflowDayOfYear && (ur > t || t > cr) && (t = cr), f(e).overflow = t), e;
          }
          function te(e) {
            n.suppressDeprecationWarnings === !1 && "undefined" != typeof console && console.warn && console.warn("Deprecation warning: " + e);
          }
          function ne(e, t) {
            var n = !0;
            return u(function() {
              return n && (te(e + "\n" + (new Error).stack), n = !1), t.apply(this, arguments);
            }, t);
          }
          function re(e, t) {
            gr[e] || (te(t), gr[e] = !0);
          }
          function ie(e) {
            var t,
                n,
                r = e._i,
                i = yr.exec(r);
            if (i) {
              for (f(e).iso = !0, t = 0, n = _r.length; n > t; t++)
                if (_r[t][1].exec(r)) {
                  e._f = _r[t][0];
                  break;
                }
              for (t = 0, n = Sr.length; n > t; t++)
                if (Sr[t][1].exec(r)) {
                  e._f += (i[6] || " ") + Sr[t][0];
                  break;
                }
              r.match(rr) && (e._f += "Z"), we(e);
            } else
              e._isValid = !1;
          }
          function se(e) {
            var t = Mr.exec(e._i);
            return null !== t ? void(e._d = new Date(+t[1])) : (ie(e), void(e._isValid === !1 && (delete e._isValid, n.createFromInputFallback(e))));
          }
          function ae(e, t, n, r, i, s, a) {
            var o = new Date(e, t, n, r, i, s, a);
            return 1970 > e && o.setFullYear(e), o;
          }
          function oe(e) {
            var t = new Date(Date.UTC.apply(null, arguments));
            return 1970 > e && t.setUTCFullYear(e), t;
          }
          function ue(e) {
            return le(e) ? 366 : 365;
          }
          function le(e) {
            return e % 4 === 0 && e % 100 !== 0 || e % 400 === 0;
          }
          function ce() {
            return le(this.year());
          }
          function fe(e, t, n) {
            var r,
                i = n - t,
                s = n - e.day();
            return s > i && (s -= 7), i - 7 > s && (s += 7), r = Pe(e).add(s, "d"), {
              week: Math.ceil(r.dayOfYear() / 7),
              year: r.year()
            };
          }
          function de(e) {
            return fe(e, this._week.dow, this._week.doy).week;
          }
          function me() {
            return this._week.dow;
          }
          function he() {
            return this._week.doy;
          }
          function pe(e) {
            var t = this.localeData().week(this);
            return null == e ? t : this.add(7 * (e - t), "d");
          }
          function ve(e) {
            var t = fe(this, 1, 4).week;
            return null == e ? t : this.add(7 * (e - t), "d");
          }
          function ge(e, t, n, r, i) {
            var s,
                a = 6 + i - r,
                o = oe(e, 0, 1 + a),
                u = o.getUTCDay();
            return i > u && (u += 7), n = null != n ? 1 * n : i, s = 1 + a + 7 * (t - 1) - u + n, {
              year: s > 0 ? e : e - 1,
              dayOfYear: s > 0 ? s : ue(e - 1) + s
            };
          }
          function ye(e) {
            var t = Math.round((this.clone().startOf("day") - this.clone().startOf("year")) / 864e5) + 1;
            return null == e ? t : this.add(e - t, "d");
          }
          function _e(e, t, n) {
            return null != e ? e : null != t ? t : n;
          }
          function Se(e) {
            var t = new Date;
            return e._useUTC ? [t.getUTCFullYear(), t.getUTCMonth(), t.getUTCDate()] : [t.getFullYear(), t.getMonth(), t.getDate()];
          }
          function Me(e) {
            var t,
                n,
                r,
                i,
                s = [];
            if (!e._d) {
              for (r = Se(e), e._w && null == e._a[cr] && null == e._a[lr] && ke(e), e._dayOfYear && (i = _e(e._a[ur], r[ur]), e._dayOfYear > ue(i) && (f(e)._overflowDayOfYear = !0), n = oe(i, 0, e._dayOfYear), e._a[lr] = n.getUTCMonth(), e._a[cr] = n.getUTCDate()), t = 0; 3 > t && null == e._a[t]; ++t)
                e._a[t] = s[t] = r[t];
              for (; 7 > t; t++)
                e._a[t] = s[t] = null == e._a[t] ? 2 === t ? 1 : 0 : e._a[t];
              24 === e._a[fr] && 0 === e._a[dr] && 0 === e._a[mr] && 0 === e._a[hr] && (e._nextDay = !0, e._a[fr] = 0), e._d = (e._useUTC ? oe : ae).apply(null, s), null != e._tzm && e._d.setUTCMinutes(e._d.getUTCMinutes() - e._tzm), e._nextDay && (e._a[fr] = 24);
            }
          }
          function ke(e) {
            var t,
                n,
                r,
                i,
                s,
                a,
                o;
            t = e._w, null != t.GG || null != t.W || null != t.E ? (s = 1, a = 4, n = _e(t.GG, e._a[ur], fe(Pe(), 1, 4).year), r = _e(t.W, 1), i = _e(t.E, 1)) : (s = e._locale._week.dow, a = e._locale._week.doy, n = _e(t.gg, e._a[ur], fe(Pe(), s, a).year), r = _e(t.w, 1), null != t.d ? (i = t.d, s > i && ++r) : i = null != t.e ? t.e + s : s), o = ge(n, r, i, a, s), e._a[ur] = o.year, e._dayOfYear = o.dayOfYear;
          }
          function we(e) {
            if (e._f === n.ISO_8601)
              return void ie(e);
            e._a = [], f(e).empty = !0;
            var t,
                r,
                i,
                s,
                a,
                o = "" + e._i,
                u = o.length,
                l = 0;
            for (i = V(e._f, e._locale).match(Wn) || [], t = 0; t < i.length; t++)
              s = i[t], r = (o.match(W(s, e)) || [])[0], r && (a = o.substr(0, o.indexOf(r)), a.length > 0 && f(e).unusedInput.push(a), o = o.slice(o.indexOf(r) + r.length), l += r.length), Hn[s] ? (r ? f(e).empty = !1 : f(e).unusedTokens.push(s), B(s, r, e)) : e._strict && !r && f(e).unusedTokens.push(s);
            f(e).charsLeftOver = u - l, o.length > 0 && f(e).unusedInput.push(o), f(e).bigHour === !0 && e._a[fr] <= 12 && e._a[fr] > 0 && (f(e).bigHour = void 0), e._a[fr] = De(e._locale, e._a[fr], e._meridiem), Me(e), ee(e);
          }
          function De(e, t, n) {
            var r;
            return null == n ? t : null != e.meridiemHour ? e.meridiemHour(t, n) : null != e.isPM ? (r = e.isPM(n), r && 12 > t && (t += 12), r || 12 !== t || (t = 0), t) : t;
          }
          function be(e) {
            var t,
                n,
                r,
                i,
                s;
            if (0 === e._f.length)
              return f(e).invalidFormat = !0, void(e._d = new Date(NaN));
            for (i = 0; i < e._f.length; i++)
              s = 0, t = h({}, e), null != e._useUTC && (t._useUTC = e._useUTC), t._f = e._f[i], we(t), d(t) && (s += f(t).charsLeftOver, s += 10 * f(t).unusedTokens.length, f(t).score = s, (null == r || r > s) && (r = s, n = t));
            u(e, n || t);
          }
          function Ye(e) {
            if (!e._d) {
              var t = N(e._i);
              e._a = [t.year, t.month, t.day || t.date, t.hour, t.minute, t.second, t.millisecond], Me(e);
            }
          }
          function Oe(e) {
            var t = new p(ee($e(e)));
            return t._nextDay && (t.add(1, "d"), t._nextDay = void 0), t;
          }
          function $e(e) {
            var t = e._i,
                n = e._f;
            return e._locale = e._locale || Y(e._l), null === t || void 0 === n && "" === t ? m({nullInput: !0}) : ("string" == typeof t && (e._i = t = e._locale.preparse(t)), v(t) ? new p(ee(t)) : (i(n) ? be(e) : n ? we(e) : s(t) ? e._d = t : Ne(e), e));
          }
          function Ne(e) {
            var t = e._i;
            void 0 === t ? e._d = new Date : s(t) ? e._d = new Date(+t) : "string" == typeof t ? se(e) : i(t) ? (e._a = a(t.slice(0), function(e) {
              return parseInt(e, 10);
            }), Me(e)) : "object" == typeof t ? Ye(e) : "number" == typeof t ? e._d = new Date(t) : n.createFromInputFallback(e);
          }
          function Te(e, t, n, r, i) {
            var s = {};
            return "boolean" == typeof n && (r = n, n = void 0), s._isAMomentObject = !0, s._useUTC = s._isUTC = i, s._l = n, s._i = e, s._f = t, s._strict = r, Oe(s);
          }
          function Pe(e, t, n, r) {
            return Te(e, t, n, r, !1);
          }
          function xe(e, t) {
            var n,
                r;
            if (1 === t.length && i(t[0]) && (t = t[0]), !t.length)
              return Pe();
            for (n = t[0], r = 1; r < t.length; ++r)
              (!t[r].isValid() || t[r][e](n)) && (n = t[r]);
            return n;
          }
          function Ae() {
            var e = [].slice.call(arguments, 0);
            return xe("isBefore", e);
          }
          function Fe() {
            var e = [].slice.call(arguments, 0);
            return xe("isAfter", e);
          }
          function Re(e) {
            var t = N(e),
                n = t.year || 0,
                r = t.quarter || 0,
                i = t.month || 0,
                s = t.week || 0,
                a = t.day || 0,
                o = t.hour || 0,
                u = t.minute || 0,
                l = t.second || 0,
                c = t.millisecond || 0;
            this._milliseconds = +c + 1e3 * l + 6e4 * u + 36e5 * o, this._days = +a + 7 * s, this._months = +i + 3 * r + 12 * n, this._data = {}, this._locale = Y(), this._bubble();
          }
          function Ue(e) {
            return e instanceof Re;
          }
          function Ee(e, t) {
            R(e, 0, 0, function() {
              var e = this.utcOffset(),
                  n = "+";
              return 0 > e && (e = -e, n = "-"), n + F(~~(e / 60), 2) + t + F(~~e % 60, 2);
            });
          }
          function Ce(e) {
            var t = (e || "").match(rr) || [],
                n = t[t.length - 1] || [],
                r = (n + "").match(Yr) || ["-", 0, 0],
                i = +(60 * r[1]) + y(r[2]);
            return "+" === r[0] ? i : -i;
          }
          function Ve(e, t) {
            var r,
                i;
            return t._isUTC ? (r = t.clone(), i = (v(e) || s(e) ? +e : +Pe(e)) - +r, r._d.setTime(+r._d + i), n.updateOffset(r, !1), r) : Pe(e).local();
          }
          function Ge(e) {
            return 15 * -Math.round(e._d.getTimezoneOffset() / 15);
          }
          function Ie(e, t) {
            var r,
                i = this._offset || 0;
            return null != e ? ("string" == typeof e && (e = Ce(e)), Math.abs(e) < 16 && (e = 60 * e), !this._isUTC && t && (r = Ge(this)), this._offset = e, this._isUTC = !0, null != r && this.add(r, "m"), i !== e && (!t || this._changeInProgress ? rt(this, Xe(e - i, "m"), 1, !1) : this._changeInProgress || (this._changeInProgress = !0, n.updateOffset(this, !0), this._changeInProgress = null)), this) : this._isUTC ? i : Ge(this);
          }
          function We(e, t) {
            return null != e ? ("string" != typeof e && (e = -e), this.utcOffset(e, t), this) : -this.utcOffset();
          }
          function Le(e) {
            return this.utcOffset(0, e);
          }
          function je(e) {
            return this._isUTC && (this.utcOffset(0, e), this._isUTC = !1, e && this.subtract(Ge(this), "m")), this;
          }
          function He() {
            return this._tzm ? this.utcOffset(this._tzm) : "string" == typeof this._i && this.utcOffset(Ce(this._i)), this;
          }
          function Be(e) {
            return e = e ? Pe(e).utcOffset() : 0, (this.utcOffset() - e) % 60 === 0;
          }
          function Ze() {
            return this.utcOffset() > this.clone().month(0).utcOffset() || this.utcOffset() > this.clone().month(5).utcOffset();
          }
          function ze() {
            if ("undefined" != typeof this._isDSTShifted)
              return this._isDSTShifted;
            var e = {};
            if (h(e, this), e = $e(e), e._a) {
              var t = e._isUTC ? l(e._a) : Pe(e._a);
              this._isDSTShifted = this.isValid() && _(e._a, t.toArray()) > 0;
            } else
              this._isDSTShifted = !1;
            return this._isDSTShifted;
          }
          function qe() {
            return !this._isUTC;
          }
          function Je() {
            return this._isUTC;
          }
          function Qe() {
            return this._isUTC && 0 === this._offset;
          }
          function Xe(e, t) {
            var n,
                r,
                i,
                s = e,
                a = null;
            return Ue(e) ? s = {
              ms: e._milliseconds,
              d: e._days,
              M: e._months
            } : "number" == typeof e ? (s = {}, t ? s[t] = e : s.milliseconds = e) : (a = Or.exec(e)) ? (n = "-" === a[1] ? -1 : 1, s = {
              y: 0,
              d: y(a[cr]) * n,
              h: y(a[fr]) * n,
              m: y(a[dr]) * n,
              s: y(a[mr]) * n,
              ms: y(a[hr]) * n
            }) : (a = $r.exec(e)) ? (n = "-" === a[1] ? -1 : 1, s = {
              y: Ke(a[2], n),
              M: Ke(a[3], n),
              d: Ke(a[4], n),
              h: Ke(a[5], n),
              m: Ke(a[6], n),
              s: Ke(a[7], n),
              w: Ke(a[8], n)
            }) : null == s ? s = {} : "object" == typeof s && ("from" in s || "to" in s) && (i = tt(Pe(s.from), Pe(s.to)), s = {}, s.ms = i.milliseconds, s.M = i.months), r = new Re(s), Ue(e) && o(e, "_locale") && (r._locale = e._locale), r;
          }
          function Ke(e, t) {
            var n = e && parseFloat(e.replace(",", "."));
            return (isNaN(n) ? 0 : n) * t;
          }
          function et(e, t) {
            var n = {
              milliseconds: 0,
              months: 0
            };
            return n.months = t.month() - e.month() + 12 * (t.year() - e.year()), e.clone().add(n.months, "M").isAfter(t) && --n.months, n.milliseconds = +t - +e.clone().add(n.months, "M"), n;
          }
          function tt(e, t) {
            var n;
            return t = Ve(t, e), e.isBefore(t) ? n = et(e, t) : (n = et(t, e), n.milliseconds = -n.milliseconds, n.months = -n.months), n;
          }
          function nt(e, t) {
            return function(n, r) {
              var i,
                  s;
              return null === r || isNaN(+r) || (re(t, "moment()." + t + "(period, number) is deprecated. Please use moment()." + t + "(number, period)."), s = n, n = r, r = s), n = "string" == typeof n ? +n : n, i = Xe(n, r), rt(this, i, e), this;
            };
          }
          function rt(e, t, r, i) {
            var s = t._milliseconds,
                a = t._days,
                o = t._months;
            i = null == i ? !0 : i, s && e._d.setTime(+e._d + s * r), a && x(e, "Date", P(e, "Date") + a * r), o && Q(e, P(e, "Month") + o * r), i && n.updateOffset(e, a || o);
          }
          function it(e, t) {
            var n = e || Pe(),
                r = Ve(n, this).startOf("day"),
                i = this.diff(r, "days", !0),
                s = -6 > i ? "sameElse" : -1 > i ? "lastWeek" : 0 > i ? "lastDay" : 1 > i ? "sameDay" : 2 > i ? "nextDay" : 7 > i ? "nextWeek" : "sameElse";
            return this.format(t && t[s] || this.localeData().calendar(s, this, Pe(n)));
          }
          function st() {
            return new p(this);
          }
          function at(e, t) {
            var n;
            return t = $("undefined" != typeof t ? t : "millisecond"), "millisecond" === t ? (e = v(e) ? e : Pe(e), +this > +e) : (n = v(e) ? +e : +Pe(e), n < +this.clone().startOf(t));
          }
          function ot(e, t) {
            var n;
            return t = $("undefined" != typeof t ? t : "millisecond"), "millisecond" === t ? (e = v(e) ? e : Pe(e), +e > +this) : (n = v(e) ? +e : +Pe(e), +this.clone().endOf(t) < n);
          }
          function ut(e, t, n) {
            return this.isAfter(e, n) && this.isBefore(t, n);
          }
          function lt(e, t) {
            var n;
            return t = $(t || "millisecond"), "millisecond" === t ? (e = v(e) ? e : Pe(e), +this === +e) : (n = +Pe(e), +this.clone().startOf(t) <= n && n <= +this.clone().endOf(t));
          }
          function ct(e, t, n) {
            var r,
                i,
                s = Ve(e, this),
                a = 6e4 * (s.utcOffset() - this.utcOffset());
            return t = $(t), "year" === t || "month" === t || "quarter" === t ? (i = ft(this, s), "quarter" === t ? i /= 3 : "year" === t && (i /= 12)) : (r = this - s, i = "second" === t ? r / 1e3 : "minute" === t ? r / 6e4 : "hour" === t ? r / 36e5 : "day" === t ? (r - a) / 864e5 : "week" === t ? (r - a) / 6048e5 : r), n ? i : g(i);
          }
          function ft(e, t) {
            var n,
                r,
                i = 12 * (t.year() - e.year()) + (t.month() - e.month()),
                s = e.clone().add(i, "months");
            return 0 > t - s ? (n = e.clone().add(i - 1, "months"), r = (t - s) / (s - n)) : (n = e.clone().add(i + 1, "months"), r = (t - s) / (n - s)), -(i + r);
          }
          function dt() {
            return this.clone().locale("en").format("ddd MMM DD YYYY HH:mm:ss [GMT]ZZ");
          }
          function mt() {
            var e = this.clone().utc();
            return 0 < e.year() && e.year() <= 9999 ? "function" == typeof Date.prototype.toISOString ? this.toDate().toISOString() : C(e, "YYYY-MM-DD[T]HH:mm:ss.SSS[Z]") : C(e, "YYYYYY-MM-DD[T]HH:mm:ss.SSS[Z]");
          }
          function ht(e) {
            var t = C(this, e || n.defaultFormat);
            return this.localeData().postformat(t);
          }
          function pt(e, t) {
            return this.isValid() ? Xe({
              to: this,
              from: e
            }).locale(this.locale()).humanize(!t) : this.localeData().invalidDate();
          }
          function vt(e) {
            return this.from(Pe(), e);
          }
          function gt(e, t) {
            return this.isValid() ? Xe({
              from: this,
              to: e
            }).locale(this.locale()).humanize(!t) : this.localeData().invalidDate();
          }
          function yt(e) {
            return this.to(Pe(), e);
          }
          function _t(e) {
            var t;
            return void 0 === e ? this._locale._abbr : (t = Y(e), null != t && (this._locale = t), this);
          }
          function St() {
            return this._locale;
          }
          function Mt(e) {
            switch (e = $(e)) {
              case "year":
                this.month(0);
              case "quarter":
              case "month":
                this.date(1);
              case "week":
              case "isoWeek":
              case "day":
                this.hours(0);
              case "hour":
                this.minutes(0);
              case "minute":
                this.seconds(0);
              case "second":
                this.milliseconds(0);
            }
            return "week" === e && this.weekday(0), "isoWeek" === e && this.isoWeekday(1), "quarter" === e && this.month(3 * Math.floor(this.month() / 3)), this;
          }
          function kt(e) {
            return e = $(e), void 0 === e || "millisecond" === e ? this : this.startOf(e).add(1, "isoWeek" === e ? "week" : e).subtract(1, "ms");
          }
          function wt() {
            return +this._d - 6e4 * (this._offset || 0);
          }
          function Dt() {
            return Math.floor(+this / 1e3);
          }
          function bt() {
            return this._offset ? new Date(+this) : this._d;
          }
          function Yt() {
            var e = this;
            return [e.year(), e.month(), e.date(), e.hour(), e.minute(), e.second(), e.millisecond()];
          }
          function Ot() {
            var e = this;
            return {
              years: e.year(),
              months: e.month(),
              date: e.date(),
              hours: e.hours(),
              minutes: e.minutes(),
              seconds: e.seconds(),
              milliseconds: e.milliseconds()
            };
          }
          function $t() {
            return d(this);
          }
          function Nt() {
            return u({}, f(this));
          }
          function Tt() {
            return f(this).overflow;
          }
          function Pt(e, t) {
            R(0, [e, e.length], 0, t);
          }
          function xt(e, t, n) {
            return fe(Pe([e, 11, 31 + t - n]), t, n).week;
          }
          function At(e) {
            var t = fe(this, this.localeData()._week.dow, this.localeData()._week.doy).year;
            return null == e ? t : this.add(e - t, "y");
          }
          function Ft(e) {
            var t = fe(this, 1, 4).year;
            return null == e ? t : this.add(e - t, "y");
          }
          function Rt() {
            return xt(this.year(), 1, 4);
          }
          function Ut() {
            var e = this.localeData()._week;
            return xt(this.year(), e.dow, e.doy);
          }
          function Et(e) {
            return null == e ? Math.ceil((this.month() + 1) / 3) : this.month(3 * (e - 1) + this.month() % 3);
          }
          function Ct(e, t) {
            return "string" != typeof e ? e : isNaN(e) ? (e = t.weekdaysParse(e), "number" == typeof e ? e : null) : parseInt(e, 10);
          }
          function Vt(e) {
            return this._weekdays[e.day()];
          }
          function Gt(e) {
            return this._weekdaysShort[e.day()];
          }
          function It(e) {
            return this._weekdaysMin[e.day()];
          }
          function Wt(e) {
            var t,
                n,
                r;
            for (this._weekdaysParse = this._weekdaysParse || [], t = 0; 7 > t; t++)
              if (this._weekdaysParse[t] || (n = Pe([2e3, 1]).day(t), r = "^" + this.weekdays(n, "") + "|^" + this.weekdaysShort(n, "") + "|^" + this.weekdaysMin(n, ""), this._weekdaysParse[t] = new RegExp(r.replace(".", ""), "i")), this._weekdaysParse[t].test(e))
                return t;
          }
          function Lt(e) {
            var t = this._isUTC ? this._d.getUTCDay() : this._d.getDay();
            return null != e ? (e = Ct(e, this.localeData()), this.add(e - t, "d")) : t;
          }
          function jt(e) {
            var t = (this.day() + 7 - this.localeData()._week.dow) % 7;
            return null == e ? t : this.add(e - t, "d");
          }
          function Ht(e) {
            return null == e ? this.day() || 7 : this.day(this.day() % 7 ? e : e - 7);
          }
          function Bt(e, t) {
            R(e, 0, 0, function() {
              return this.localeData().meridiem(this.hours(), this.minutes(), t);
            });
          }
          function Zt(e, t) {
            return t._meridiemParse;
          }
          function zt(e) {
            return "p" === (e + "").toLowerCase().charAt(0);
          }
          function qt(e, t, n) {
            return e > 11 ? n ? "pm" : "PM" : n ? "am" : "AM";
          }
          function Jt(e, t) {
            t[hr] = y(1e3 * ("0." + e));
          }
          function Qt() {
            return this._isUTC ? "UTC" : "";
          }
          function Xt() {
            return this._isUTC ? "Coordinated Universal Time" : "";
          }
          function Kt(e) {
            return Pe(1e3 * e);
          }
          function en() {
            return Pe.apply(null, arguments).parseZone();
          }
          function tn(e, t, n) {
            var r = this._calendar[e];
            return "function" == typeof r ? r.call(t, n) : r;
          }
          function nn(e) {
            var t = this._longDateFormat[e],
                n = this._longDateFormat[e.toUpperCase()];
            return t || !n ? t : (this._longDateFormat[e] = n.replace(/MMMM|MM|DD|dddd/g, function(e) {
              return e.slice(1);
            }), this._longDateFormat[e]);
          }
          function rn() {
            return this._invalidDate;
          }
          function sn(e) {
            return this._ordinal.replace("%d", e);
          }
          function an(e) {
            return e;
          }
          function on(e, t, n, r) {
            var i = this._relativeTime[n];
            return "function" == typeof i ? i(e, t, n, r) : i.replace(/%d/i, e);
          }
          function un(e, t) {
            var n = this._relativeTime[e > 0 ? "future" : "past"];
            return "function" == typeof n ? n(t) : n.replace(/%s/i, t);
          }
          function ln(e) {
            var t,
                n;
            for (n in e)
              t = e[n], "function" == typeof t ? this[n] = t : this["_" + n] = t;
            this._ordinalParseLenient = new RegExp(this._ordinalParse.source + "|" + /\d{1,2}/.source);
          }
          function cn(e, t, n, r) {
            var i = Y(),
                s = l().set(r, t);
            return i[n](s, e);
          }
          function fn(e, t, n, r, i) {
            if ("number" == typeof e && (t = e, e = void 0), e = e || "", null != t)
              return cn(e, t, n, i);
            var s,
                a = [];
            for (s = 0; r > s; s++)
              a[s] = cn(e, s, n, i);
            return a;
          }
          function dn(e, t) {
            return fn(e, t, "months", 12, "month");
          }
          function mn(e, t) {
            return fn(e, t, "monthsShort", 12, "month");
          }
          function hn(e, t) {
            return fn(e, t, "weekdays", 7, "day");
          }
          function pn(e, t) {
            return fn(e, t, "weekdaysShort", 7, "day");
          }
          function vn(e, t) {
            return fn(e, t, "weekdaysMin", 7, "day");
          }
          function gn() {
            var e = this._data;
            return this._milliseconds = Qr(this._milliseconds), this._days = Qr(this._days), this._months = Qr(this._months), e.milliseconds = Qr(e.milliseconds), e.seconds = Qr(e.seconds), e.minutes = Qr(e.minutes), e.hours = Qr(e.hours), e.months = Qr(e.months), e.years = Qr(e.years), this;
          }
          function yn(e, t, n, r) {
            var i = Xe(t, n);
            return e._milliseconds += r * i._milliseconds, e._days += r * i._days, e._months += r * i._months, e._bubble();
          }
          function _n(e, t) {
            return yn(this, e, t, 1);
          }
          function Sn(e, t) {
            return yn(this, e, t, -1);
          }
          function Mn(e) {
            return 0 > e ? Math.floor(e) : Math.ceil(e);
          }
          function kn() {
            var e,
                t,
                n,
                r,
                i,
                s = this._milliseconds,
                a = this._days,
                o = this._months,
                u = this._data;
            return s >= 0 && a >= 0 && o >= 0 || 0 >= s && 0 >= a && 0 >= o || (s += 864e5 * Mn(Dn(o) + a), a = 0, o = 0), u.milliseconds = s % 1e3, e = g(s / 1e3), u.seconds = e % 60, t = g(e / 60), u.minutes = t % 60, n = g(t / 60), u.hours = n % 24, a += g(n / 24), i = g(wn(a)), o += i, a -= Mn(Dn(i)), r = g(o / 12), o %= 12, u.days = a, u.months = o, u.years = r, this;
          }
          function wn(e) {
            return 4800 * e / 146097;
          }
          function Dn(e) {
            return 146097 * e / 4800;
          }
          function bn(e) {
            var t,
                n,
                r = this._milliseconds;
            if (e = $(e), "month" === e || "year" === e)
              return t = this._days + r / 864e5, n = this._months + wn(t), "month" === e ? n : n / 12;
            switch (t = this._days + Math.round(Dn(this._months)), e) {
              case "week":
                return t / 7 + r / 6048e5;
              case "day":
                return t + r / 864e5;
              case "hour":
                return 24 * t + r / 36e5;
              case "minute":
                return 1440 * t + r / 6e4;
              case "second":
                return 86400 * t + r / 1e3;
              case "millisecond":
                return Math.floor(864e5 * t) + r;
              default:
                throw new Error("Unknown unit " + e);
            }
          }
          function Yn() {
            return this._milliseconds + 864e5 * this._days + this._months % 12 * 2592e6 + 31536e6 * y(this._months / 12);
          }
          function On(e) {
            return function() {
              return this.as(e);
            };
          }
          function $n(e) {
            return e = $(e), this[e + "s"]();
          }
          function Nn(e) {
            return function() {
              return this._data[e];
            };
          }
          function Tn() {
            return g(this.days() / 7);
          }
          function Pn(e, t, n, r, i) {
            return i.relativeTime(t || 1, !!n, e, r);
          }
          function xn(e, t, n) {
            var r = Xe(e).abs(),
                i = mi(r.as("s")),
                s = mi(r.as("m")),
                a = mi(r.as("h")),
                o = mi(r.as("d")),
                u = mi(r.as("M")),
                l = mi(r.as("y")),
                c = i < hi.s && ["s", i] || 1 === s && ["m"] || s < hi.m && ["mm", s] || 1 === a && ["h"] || a < hi.h && ["hh", a] || 1 === o && ["d"] || o < hi.d && ["dd", o] || 1 === u && ["M"] || u < hi.M && ["MM", u] || 1 === l && ["y"] || ["yy", l];
            return c[2] = t, c[3] = +e > 0, c[4] = n, Pn.apply(null, c);
          }
          function An(e, t) {
            return void 0 === hi[e] ? !1 : void 0 === t ? hi[e] : (hi[e] = t, !0);
          }
          function Fn(e) {
            var t = this.localeData(),
                n = xn(this, !e, t);
            return e && (n = t.pastFuture(+this, n)), t.postformat(n);
          }
          function Rn() {
            var e,
                t,
                n,
                r = pi(this._milliseconds) / 1e3,
                i = pi(this._days),
                s = pi(this._months);
            e = g(r / 60), t = g(e / 60), r %= 60, e %= 60, n = g(s / 12), s %= 12;
            var a = n,
                o = s,
                u = i,
                l = t,
                c = e,
                f = r,
                d = this.asSeconds();
            return d ? (0 > d ? "-" : "") + "P" + (a ? a + "Y" : "") + (o ? o + "M" : "") + (u ? u + "D" : "") + (l || c || f ? "T" : "") + (l ? l + "H" : "") + (c ? c + "M" : "") + (f ? f + "S" : "") : "P0D";
          }
          var Un,
              En,
              Cn = n.momentProperties = [],
              Vn = !1,
              Gn = {},
              In = {},
              Wn = /(\[[^\[]*\])|(\\)?(Mo|MM?M?M?|Do|DDDo|DD?D?D?|ddd?d?|do?|w[o|w]?|W[o|W]?|Q|YYYYYY|YYYYY|YYYY|YY|gg(ggg?)?|GG(GGG?)?|e|E|a|A|hh?|HH?|mm?|ss?|S{1,9}|x|X|zz?|ZZ?|.)/g,
              Ln = /(\[[^\[]*\])|(\\)?(LTS|LT|LL?L?L?|l{1,4})/g,
              jn = {},
              Hn = {},
              Bn = /\d/,
              Zn = /\d\d/,
              zn = /\d{3}/,
              qn = /\d{4}/,
              Jn = /[+-]?\d{6}/,
              Qn = /\d\d?/,
              Xn = /\d{1,3}/,
              Kn = /\d{1,4}/,
              er = /[+-]?\d{1,6}/,
              tr = /\d+/,
              nr = /[+-]?\d+/,
              rr = /Z|[+-]\d\d:?\d\d/gi,
              ir = /[+-]?\d+(\.\d{1,3})?/,
              sr = /[0-9]*['a-z\u00A0-\u05FF\u0700-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]+|[\u0600-\u06FF\/]+(\s*?[\u0600-\u06FF]+){1,2}/i,
              ar = {},
              or = {},
              ur = 0,
              lr = 1,
              cr = 2,
              fr = 3,
              dr = 4,
              mr = 5,
              hr = 6;
          R("M", ["MM", 2], "Mo", function() {
            return this.month() + 1;
          }), R("MMM", 0, 0, function(e) {
            return this.localeData().monthsShort(this, e);
          }), R("MMMM", 0, 0, function(e) {
            return this.localeData().months(this, e);
          }), O("month", "M"), I("M", Qn), I("MM", Qn, Zn), I("MMM", sr), I("MMMM", sr), j(["M", "MM"], function(e, t) {
            t[lr] = y(e) - 1;
          }), j(["MMM", "MMMM"], function(e, t, n, r) {
            var i = n._locale.monthsParse(e, r, n._strict);
            null != i ? t[lr] = i : f(n).invalidMonth = e;
          });
          var pr = "January_February_March_April_May_June_July_August_September_October_November_December".split("_"),
              vr = "Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec".split("_"),
              gr = {};
          n.suppressDeprecationWarnings = !1;
          var yr = /^\s*(?:[+-]\d{6}|\d{4})-(?:(\d\d-\d\d)|(W\d\d$)|(W\d\d-\d)|(\d\d\d))((T| )(\d\d(:\d\d(:\d\d(\.\d+)?)?)?)?([\+\-]\d\d(?::?\d\d)?|\s*Z)?)?$/,
              _r = [["YYYYYY-MM-DD", /[+-]\d{6}-\d{2}-\d{2}/], ["YYYY-MM-DD", /\d{4}-\d{2}-\d{2}/], ["GGGG-[W]WW-E", /\d{4}-W\d{2}-\d/], ["GGGG-[W]WW", /\d{4}-W\d{2}/], ["YYYY-DDD", /\d{4}-\d{3}/]],
              Sr = [["HH:mm:ss.SSSS", /(T| )\d\d:\d\d:\d\d\.\d+/], ["HH:mm:ss", /(T| )\d\d:\d\d:\d\d/], ["HH:mm", /(T| )\d\d:\d\d/], ["HH", /(T| )\d\d/]],
              Mr = /^\/?Date\((\-?\d+)/i;
          n.createFromInputFallback = ne("moment construction falls back to js Date. This is discouraged and will be removed in upcoming major release. Please refer to https://github.com/moment/moment/issues/1407 for more info.", function(e) {
            e._d = new Date(e._i + (e._useUTC ? " UTC" : ""));
          }), R(0, ["YY", 2], 0, function() {
            return this.year() % 100;
          }), R(0, ["YYYY", 4], 0, "year"), R(0, ["YYYYY", 5], 0, "year"), R(0, ["YYYYYY", 6, !0], 0, "year"), O("year", "y"), I("Y", nr), I("YY", Qn, Zn), I("YYYY", Kn, qn), I("YYYYY", er, Jn), I("YYYYYY", er, Jn), j(["YYYYY", "YYYYYY"], ur), j("YYYY", function(e, t) {
            t[ur] = 2 === e.length ? n.parseTwoDigitYear(e) : y(e);
          }), j("YY", function(e, t) {
            t[ur] = n.parseTwoDigitYear(e);
          }), n.parseTwoDigitYear = function(e) {
            return y(e) + (y(e) > 68 ? 1900 : 2e3);
          };
          var kr = T("FullYear", !1);
          R("w", ["ww", 2], "wo", "week"), R("W", ["WW", 2], "Wo", "isoWeek"), O("week", "w"), O("isoWeek", "W"), I("w", Qn), I("ww", Qn, Zn), I("W", Qn), I("WW", Qn, Zn), H(["w", "ww", "W", "WW"], function(e, t, n, r) {
            t[r.substr(0, 1)] = y(e);
          });
          var wr = {
            dow: 0,
            doy: 6
          };
          R("DDD", ["DDDD", 3], "DDDo", "dayOfYear"), O("dayOfYear", "DDD"), I("DDD", Xn), I("DDDD", zn), j(["DDD", "DDDD"], function(e, t, n) {
            n._dayOfYear = y(e);
          }), n.ISO_8601 = function() {};
          var Dr = ne("moment().min is deprecated, use moment.min instead. https://github.com/moment/moment/issues/1548", function() {
            var e = Pe.apply(null, arguments);
            return this > e ? this : e;
          }),
              br = ne("moment().max is deprecated, use moment.max instead. https://github.com/moment/moment/issues/1548", function() {
                var e = Pe.apply(null, arguments);
                return e > this ? this : e;
              });
          Ee("Z", ":"), Ee("ZZ", ""), I("Z", rr), I("ZZ", rr), j(["Z", "ZZ"], function(e, t, n) {
            n._useUTC = !0, n._tzm = Ce(e);
          });
          var Yr = /([\+\-]|\d\d)/gi;
          n.updateOffset = function() {};
          var Or = /(\-)?(?:(\d*)\.)?(\d+)\:(\d+)(?:\:(\d+)\.?(\d{3})?)?/,
              $r = /^(-)?P(?:(?:([0-9,.]*)Y)?(?:([0-9,.]*)M)?(?:([0-9,.]*)D)?(?:T(?:([0-9,.]*)H)?(?:([0-9,.]*)M)?(?:([0-9,.]*)S)?)?|([0-9,.]*)W)$/;
          Xe.fn = Re.prototype;
          var Nr = nt(1, "add"),
              Tr = nt(-1, "subtract");
          n.defaultFormat = "YYYY-MM-DDTHH:mm:ssZ";
          var Pr = ne("moment().lang() is deprecated. Instead, use moment().localeData() to get the language configuration. Use moment().locale() to change languages.", function(e) {
            return void 0 === e ? this.localeData() : this.locale(e);
          });
          R(0, ["gg", 2], 0, function() {
            return this.weekYear() % 100;
          }), R(0, ["GG", 2], 0, function() {
            return this.isoWeekYear() % 100;
          }), Pt("gggg", "weekYear"), Pt("ggggg", "weekYear"), Pt("GGGG", "isoWeekYear"), Pt("GGGGG", "isoWeekYear"), O("weekYear", "gg"), O("isoWeekYear", "GG"), I("G", nr), I("g", nr), I("GG", Qn, Zn), I("gg", Qn, Zn), I("GGGG", Kn, qn), I("gggg", Kn, qn), I("GGGGG", er, Jn), I("ggggg", er, Jn), H(["gggg", "ggggg", "GGGG", "GGGGG"], function(e, t, n, r) {
            t[r.substr(0, 2)] = y(e);
          }), H(["gg", "GG"], function(e, t, r, i) {
            t[i] = n.parseTwoDigitYear(e);
          }), R("Q", 0, 0, "quarter"), O("quarter", "Q"), I("Q", Bn), j("Q", function(e, t) {
            t[lr] = 3 * (y(e) - 1);
          }), R("D", ["DD", 2], "Do", "date"), O("date", "D"), I("D", Qn), I("DD", Qn, Zn), I("Do", function(e, t) {
            return e ? t._ordinalParse : t._ordinalParseLenient;
          }), j(["D", "DD"], cr), j("Do", function(e, t) {
            t[cr] = y(e.match(Qn)[0], 10);
          });
          var xr = T("Date", !0);
          R("d", 0, "do", "day"), R("dd", 0, 0, function(e) {
            return this.localeData().weekdaysMin(this, e);
          }), R("ddd", 0, 0, function(e) {
            return this.localeData().weekdaysShort(this, e);
          }), R("dddd", 0, 0, function(e) {
            return this.localeData().weekdays(this, e);
          }), R("e", 0, 0, "weekday"), R("E", 0, 0, "isoWeekday"), O("day", "d"), O("weekday", "e"), O("isoWeekday", "E"), I("d", Qn), I("e", Qn), I("E", Qn), I("dd", sr), I("ddd", sr), I("dddd", sr), H(["dd", "ddd", "dddd"], function(e, t, n) {
            var r = n._locale.weekdaysParse(e);
            null != r ? t.d = r : f(n).invalidWeekday = e;
          }), H(["d", "e", "E"], function(e, t, n, r) {
            t[r] = y(e);
          });
          var Ar = "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"),
              Fr = "Sun_Mon_Tue_Wed_Thu_Fri_Sat".split("_"),
              Rr = "Su_Mo_Tu_We_Th_Fr_Sa".split("_");
          R("H", ["HH", 2], 0, "hour"), R("h", ["hh", 2], 0, function() {
            return this.hours() % 12 || 12;
          }), Bt("a", !0), Bt("A", !1), O("hour", "h"), I("a", Zt), I("A", Zt), I("H", Qn), I("h", Qn), I("HH", Qn, Zn), I("hh", Qn, Zn), j(["H", "HH"], fr), j(["a", "A"], function(e, t, n) {
            n._isPm = n._locale.isPM(e), n._meridiem = e;
          }), j(["h", "hh"], function(e, t, n) {
            t[fr] = y(e), f(n).bigHour = !0;
          });
          var Ur = /[ap]\.?m?\.?/i,
              Er = T("Hours", !0);
          R("m", ["mm", 2], 0, "minute"), O("minute", "m"), I("m", Qn), I("mm", Qn, Zn), j(["m", "mm"], dr);
          var Cr = T("Minutes", !1);
          R("s", ["ss", 2], 0, "second"), O("second", "s"), I("s", Qn), I("ss", Qn, Zn), j(["s", "ss"], mr);
          var Vr = T("Seconds", !1);
          R("S", 0, 0, function() {
            return ~~(this.millisecond() / 100);
          }), R(0, ["SS", 2], 0, function() {
            return ~~(this.millisecond() / 10);
          }), R(0, ["SSS", 3], 0, "millisecond"), R(0, ["SSSS", 4], 0, function() {
            return 10 * this.millisecond();
          }), R(0, ["SSSSS", 5], 0, function() {
            return 100 * this.millisecond();
          }), R(0, ["SSSSSS", 6], 0, function() {
            return 1e3 * this.millisecond();
          }), R(0, ["SSSSSSS", 7], 0, function() {
            return 1e4 * this.millisecond();
          }), R(0, ["SSSSSSSS", 8], 0, function() {
            return 1e5 * this.millisecond();
          }), R(0, ["SSSSSSSSS", 9], 0, function() {
            return 1e6 * this.millisecond();
          }), O("millisecond", "ms"), I("S", Xn, Bn), I("SS", Xn, Zn), I("SSS", Xn, zn);
          var Gr;
          for (Gr = "SSSS"; Gr.length <= 9; Gr += "S")
            I(Gr, tr);
          for (Gr = "S"; Gr.length <= 9; Gr += "S")
            j(Gr, Jt);
          var Ir = T("Milliseconds", !1);
          R("z", 0, 0, "zoneAbbr"), R("zz", 0, 0, "zoneName");
          var Wr = p.prototype;
          Wr.add = Nr, Wr.calendar = it, Wr.clone = st, Wr.diff = ct, Wr.endOf = kt, Wr.format = ht, Wr.from = pt, Wr.fromNow = vt, Wr.to = gt, Wr.toNow = yt, Wr.get = A, Wr.invalidAt = Tt, Wr.isAfter = at, Wr.isBefore = ot, Wr.isBetween = ut, Wr.isSame = lt, Wr.isValid = $t, Wr.lang = Pr, Wr.locale = _t, Wr.localeData = St, Wr.max = br, Wr.min = Dr, Wr.parsingFlags = Nt, Wr.set = A, Wr.startOf = Mt, Wr.subtract = Tr, Wr.toArray = Yt, Wr.toObject = Ot, Wr.toDate = bt, Wr.toISOString = mt, Wr.toJSON = mt, Wr.toString = dt, Wr.unix = Dt, Wr.valueOf = wt, Wr.year = kr, Wr.isLeapYear = ce, Wr.weekYear = At, Wr.isoWeekYear = Ft, Wr.quarter = Wr.quarters = Et, Wr.month = X, Wr.daysInMonth = K, Wr.week = Wr.weeks = pe, Wr.isoWeek = Wr.isoWeeks = ve, Wr.weeksInYear = Ut, Wr.isoWeeksInYear = Rt, Wr.date = xr, Wr.day = Wr.days = Lt, Wr.weekday = jt, Wr.isoWeekday = Ht, Wr.dayOfYear = ye, Wr.hour = Wr.hours = Er, Wr.minute = Wr.minutes = Cr, Wr.second = Wr.seconds = Vr, Wr.millisecond = Wr.milliseconds = Ir, Wr.utcOffset = Ie, Wr.utc = Le, Wr.local = je, Wr.parseZone = He, Wr.hasAlignedHourOffset = Be, Wr.isDST = Ze, Wr.isDSTShifted = ze, Wr.isLocal = qe, Wr.isUtcOffset = Je, Wr.isUtc = Qe, Wr.isUTC = Qe, Wr.zoneAbbr = Qt, Wr.zoneName = Xt, Wr.dates = ne("dates accessor is deprecated. Use date instead.", xr), Wr.months = ne("months accessor is deprecated. Use month instead", X), Wr.years = ne("years accessor is deprecated. Use year instead", kr), Wr.zone = ne("moment().zone is deprecated, use moment().utcOffset instead. https://github.com/moment/moment/issues/1779", We);
          var Lr = Wr,
              jr = {
                sameDay: "[Today at] LT",
                nextDay: "[Tomorrow at] LT",
                nextWeek: "dddd [at] LT",
                lastDay: "[Yesterday at] LT",
                lastWeek: "[Last] dddd [at] LT",
                sameElse: "L"
              },
              Hr = {
                LTS: "h:mm:ss A",
                LT: "h:mm A",
                L: "MM/DD/YYYY",
                LL: "MMMM D, YYYY",
                LLL: "MMMM D, YYYY h:mm A",
                LLLL: "dddd, MMMM D, YYYY h:mm A"
              },
              Br = "Invalid date",
              Zr = "%d",
              zr = /\d{1,2}/,
              qr = {
                future: "in %s",
                past: "%s ago",
                s: "a few seconds",
                m: "a minute",
                mm: "%d minutes",
                h: "an hour",
                hh: "%d hours",
                d: "a day",
                dd: "%d days",
                M: "a month",
                MM: "%d months",
                y: "a year",
                yy: "%d years"
              },
              Jr = S.prototype;
          Jr._calendar = jr, Jr.calendar = tn, Jr._longDateFormat = Hr, Jr.longDateFormat = nn, Jr._invalidDate = Br, Jr.invalidDate = rn, Jr._ordinal = Zr, Jr.ordinal = sn, Jr._ordinalParse = zr, Jr.preparse = an, Jr.postformat = an, Jr._relativeTime = qr, Jr.relativeTime = on, Jr.pastFuture = un, Jr.set = ln, Jr.months = z, Jr._months = pr, Jr.monthsShort = q, Jr._monthsShort = vr, Jr.monthsParse = J, Jr.week = de, Jr._week = wr, Jr.firstDayOfYear = he, Jr.firstDayOfWeek = me, Jr.weekdays = Vt, Jr._weekdays = Ar, Jr.weekdaysMin = It, Jr._weekdaysMin = Rr, Jr.weekdaysShort = Gt, Jr._weekdaysShort = Fr, Jr.weekdaysParse = Wt, Jr.isPM = zt, Jr._meridiemParse = Ur, Jr.meridiem = qt, D("en", {
            ordinalParse: /\d{1,2}(th|st|nd|rd)/,
            ordinal: function(e) {
              var t = e % 10,
                  n = 1 === y(e % 100 / 10) ? "th" : 1 === t ? "st" : 2 === t ? "nd" : 3 === t ? "rd" : "th";
              return e + n;
            }
          }), n.lang = ne("moment.lang is deprecated. Use moment.locale instead.", D), n.langData = ne("moment.langData is deprecated. Use moment.localeData instead.", Y);
          var Qr = Math.abs,
              Xr = On("ms"),
              Kr = On("s"),
              ei = On("m"),
              ti = On("h"),
              ni = On("d"),
              ri = On("w"),
              ii = On("M"),
              si = On("y"),
              ai = Nn("milliseconds"),
              oi = Nn("seconds"),
              ui = Nn("minutes"),
              li = Nn("hours"),
              ci = Nn("days"),
              fi = Nn("months"),
              di = Nn("years"),
              mi = Math.round,
              hi = {
                s: 45,
                m: 45,
                h: 22,
                d: 26,
                M: 11
              },
              pi = Math.abs,
              vi = Re.prototype;
          vi.abs = gn, vi.add = _n, vi.subtract = Sn, vi.as = bn, vi.asMilliseconds = Xr, vi.asSeconds = Kr, vi.asMinutes = ei, vi.asHours = ti, vi.asDays = ni, vi.asWeeks = ri, vi.asMonths = ii, vi.asYears = si, vi.valueOf = Yn, vi._bubble = kn, vi.get = $n, vi.milliseconds = ai, vi.seconds = oi, vi.minutes = ui, vi.hours = li, vi.days = ci, vi.weeks = Tn, vi.months = fi, vi.years = di, vi.humanize = Fn, vi.toISOString = Rn, vi.toString = Rn, vi.toJSON = Rn, vi.locale = _t, vi.localeData = St, vi.toIsoString = ne("toIsoString() is deprecated. Please use toISOString() instead (notice the capitals)", Rn), vi.lang = Pr, R("X", 0, 0, "unix"), R("x", 0, 0, "valueOf"), I("x", nr), I("X", ir), j("X", function(e, t, n) {
            n._d = new Date(1e3 * parseFloat(e, 10));
          }), j("x", function(e, t, n) {
            n._d = new Date(y(e));
          }), n.version = "2.10.6", r(Pe), n.fn = Lr, n.min = Ae, n.max = Fe, n.utc = l, n.unix = Kt, n.months = dn, n.isDate = s, n.locale = D, n.invalid = m, n.duration = Xe, n.isMoment = v, n.weekdays = hn, n.parseZone = en, n.localeData = Y, n.isDuration = Ue, n.monthsShort = mn, n.weekdaysMin = vn, n.defineLocale = b, n.weekdaysShort = pn, n.normalizeUnits = $, n.relativeTimeThreshold = An;
          var gi = n;
          return gi;
        });
      }, {}],
      3: [function(e, t, n) {
        !function(e, r) {
          "function" == typeof define && define.amd ? define([], r) : "object" == typeof n ? t.exports = r() : e.StringMask = r();
        }(this, function() {
          function e(e, t) {
            for (var n = 0,
                r = t - 1,
                i = {escape: !0}; r >= 0 && i && i.escape; )
              i = a[e.charAt(r)], n += i && i.escape ? 1 : 0, r--;
            return n > 0 && n % 2 === 1;
          }
          function t(e, t) {
            var n = e.replace(/[^0]/g, "").length,
                r = t.replace(/[^\d]/g, "").length;
            return r - n;
          }
          function n(e, t, n, r) {
            return r && "function" == typeof r.transform && (t = r.transform(t)), n.reverse ? t + e : e + t;
          }
          function r(e, t, n) {
            var i = e.charAt(t),
                s = a[i];
            return "" === i ? !1 : s && !s.escape ? !0 : r(e, t + n, n);
          }
          function i(e, t, n) {
            var r = e.split("");
            return r.splice(n >= 0 ? n : 0, 0, t), r.join("");
          }
          function s(e, t) {
            this.options = t || {}, this.options = {
              reverse: this.options.reverse || !1,
              usedefaults: this.options.usedefaults || this.options.reverse
            }, this.pattern = e;
          }
          var a = {
            0: {
              pattern: /\d/,
              _default: "0"
            },
            9: {
              pattern: /\d/,
              optional: !0
            },
            "#": {
              pattern: /\d/,
              optional: !0,
              recursive: !0
            },
            S: {pattern: /[a-zA-Z]/},
            U: {
              pattern: /[a-zA-Z]/,
              transform: function(e) {
                return e.toLocaleUpperCase();
              }
            },
            L: {
              pattern: /[a-zA-Z]/,
              transform: function(e) {
                return e.toLocaleLowerCase();
              }
            },
            $: {escape: !0}
          };
          return s.prototype.process = function(s) {
            function o(e) {
              if (!p && r(u, g, v.inc))
                return !0;
              if (p || (p = h.length > 0), p) {
                var t = h.shift();
                if (h.push(t), e.reverse && f >= 0)
                  return g++, u = i(u, t, g), !0;
                if (!e.reverse && f < s.length)
                  return u = i(u, t, g), !0;
              }
              return g < u.length && g >= 0;
            }
            if (!s)
              return "";
            s += "";
            for (var u = this.pattern,
                l = !0,
                c = "",
                f = this.options.reverse ? s.length - 1 : 0,
                d = t(u, s),
                m = !1,
                h = [],
                p = !1,
                v = {
                  start: this.options.reverse ? u.length - 1 : 0,
                  end: this.options.reverse ? -1 : u.length,
                  inc: this.options.reverse ? -1 : 1
                },
                g = v.start; o(this.options); g += v.inc) {
              var y = u.charAt(g),
                  _ = s.charAt(f),
                  S = a[y];
              if (!p || _) {
                if (this.options.reverse && e(u, g)) {
                  c = n(c, y, this.options, S), g += v.inc;
                  continue;
                }
                if (!this.options.reverse && m) {
                  c = n(c, y, this.options, S), m = !1;
                  continue;
                }
                if (!this.options.reverse && S && S.escape) {
                  m = !0;
                  continue;
                }
              }
              if (!p && S && S.recursive)
                h.push(y);
              else {
                if (p && !_) {
                  S && S.recursive || (c = n(c, y, this.options, S));
                  continue;
                }
                if (h.length > 0 && S && !S.recursive) {
                  l = !1;
                  continue;
                }
                if (!p && h.length > 0 && !_)
                  continue;
              }
              if (S)
                if (S.optional) {
                  if (S.pattern.test(_) && d)
                    c = n(c, _, this.options, S), f += v.inc, d--;
                  else if (h.length > 0 && _) {
                    l = !1;
                    break;
                  }
                } else if (S.pattern.test(_))
                  c = n(c, _, this.options, S), f += v.inc;
                else {
                  if (_ || !S._default || !this.options.usedefaults) {
                    l = !1;
                    break;
                  }
                  c = n(c, S._default, this.options, S);
                }
              else
                c = n(c, y, this.options, S), !p && h.length && h.push(y);
            }
            return {
              result: c,
              valid: l
            };
          }, s.prototype.apply = function(e) {
            return this.process(e).result;
          }, s.prototype.validate = function(e) {
            return this.process(e).valid;
          }, s.process = function(e, t, n) {
            return new s(t, n).process(e);
          }, s.apply = function(e, t, n) {
            return new s(t, n).apply(e);
          }, s.validate = function(e, t, n) {
            return new s(t, n).validate(e);
          }, s;
        });
      }, {}],
      4: [function(e, t, n) {
        t.exports = angular.module("ui.utils.masks", [e("./global/global-masks"), e("./br/br-masks"), e("./us/us-masks")]).name;
      }, {
        "./br/br-masks": 6,
        "./global/global-masks": 15,
        "./us/us-masks": 23
      }],
      5: [function(e, t, n) {
        var r = e("string-mask"),
            i = e("mask-factory"),
            s = new r("00000.00000 00000.000000 00000.000000 0 00000000000000");
        t.exports = i({
          clearValue: function(e) {
            return e.replace(/[^0-9]/g, "").slice(0, 47);
          },
          format: function(e) {
            return 0 === e.length ? e : s.apply(e).replace(/[^0-9]$/, "");
          },
          validations: {brBoletoBancario: function(e) {
              return 47 === e.length;
            }}
        });
      }, {
        "mask-factory": "mask-factory",
        "string-mask": 3
      }],
      6: [function(e, t, n) {
        var r = angular.module("ui.utils.masks.br", [e("../helpers")]).directive("uiBrBoletoBancarioMask", e("./boleto-bancario/boleto-bancario")).directive("uiBrCepMask", e("./cep/cep")).directive("uiBrCnpjMask", e("./cnpj/cnpj")).directive("uiBrCpfMask", e("./cpf/cpf")).directive("uiBrCpfcnpjMask", e("./cpf-cnpj/cpf-cnpj")).directive("uiBrIeMask", e("./inscricao-estadual/ie")).directive("uiNfeAccessKeyMask", e("./nfe/nfe")).directive("uiBrPhoneNumber", e("./phone/br-phone"));
        t.exports = r.name;
      }, {
        "../helpers": 21,
        "./boleto-bancario/boleto-bancario": 5,
        "./cep/cep": 7,
        "./cnpj/cnpj": 8,
        "./cpf-cnpj/cpf-cnpj": 9,
        "./cpf/cpf": 10,
        "./inscricao-estadual/ie": 11,
        "./nfe/nfe": 12,
        "./phone/br-phone": 13
      }],
      7: [function(e, t, n) {
        var r = e("string-mask"),
            i = e("mask-factory"),
            s = new r("00000-000");
        t.exports = i({
          clearValue: function(e) {
            return e.replace(/[^0-9]/g, "").slice(0, 8);
          },
          format: function(e) {
            return (s.apply(e) || "").replace(/[^0-9]$/, "");
          },
          validations: {cep: function(e) {
              return 8 === e.length;
            }}
        });
      }, {
        "mask-factory": "mask-factory",
        "string-mask": 3
      }],
      8: [function(e, t, n) {
        var r = e("string-mask"),
            i = e("br-validations"),
            s = e("mask-factory"),
            a = new r("00.000.000/0000-00");
        t.exports = s({
          clearValue: function(e) {
            return e.replace(/[^\d]/g, "").slice(0, 14);
          },
          format: function(e) {
            return (a.apply(e) || "").trim().replace(/[^0-9]$/, "");
          },
          validations: {cnpj: function(e) {
              return i.cnpj.validate(e);
            }}
        });
      }, {
        "br-validations": 1,
        "mask-factory": "mask-factory",
        "string-mask": 3
      }],
      9: [function(e, t, n) {
        var r = e("string-mask"),
            i = e("br-validations"),
            s = e("mask-factory"),
            a = new r("00.000.000/0000-00"),
            o = new r("000.000.000-00");
        t.exports = s({
          clearValue: function(e) {
            return e.replace(/[^\d]/g, "").slice(0, 14);
          },
          format: function(e) {
            var t;
            return t = e.length > 11 ? a.apply(e) : o.apply(e) || "", t.trim().replace(/[^0-9]$/, "");
          },
          validations: {
            cpf: function(e) {
              return e.length > 11 || i.cpf.validate(e);
            },
            cnpj: function(e) {
              return e.length <= 11 || i.cnpj.validate(e);
            }
          }
        });
      }, {
        "br-validations": 1,
        "mask-factory": "mask-factory",
        "string-mask": 3
      }],
      10: [function(e, t, n) {
        var r = e("string-mask"),
            i = e("br-validations"),
            s = e("mask-factory"),
            a = new r("000.000.000-00");
        t.exports = s({
          clearValue: function(e) {
            return e.replace(/[^\d]/g, "").slice(0, 11);
          },
          format: function(e) {
            return (a.apply(e) || "").trim().replace(/[^0-9]$/, "");
          },
          validations: {cpf: function(e) {
              return i.cpf.validate(e);
            }}
        });
      }, {
        "br-validations": 1,
        "mask-factory": "mask-factory",
        "string-mask": 3
      }],
      11: [function(e, t, n) {
        function r(e) {
          function t(e) {
            return e ? e.replace(/[^0-9]/g, "") : e;
          }
          function n(e, n) {
            if (!e || !a[e])
              return void 0;
            if ("SP" === e && /^P/i.test(n))
              return a.SP[1].mask;
            for (var r = a[e],
                i = 0; r[i].chars && r[i].chars < t(n).length && i < r.length - 1; )
              i++;
            return r[i].mask;
          }
          function r(e, r) {
            var i = n(r, e);
            if (!i)
              return e;
            var s = i.process(t(e)),
                a = s.result || "";
            return a = a.trim().replace(/[^0-9]$/, ""), "SP" === r && /^p/i.test(e) ? "P" + a : a;
          }
          var a = {
            AC: [{mask: new i("00.000.000/000-00")}],
            AL: [{mask: new i("000000000")}],
            AM: [{mask: new i("00.000.000-0")}],
            AP: [{mask: new i("000000000")}],
            BA: [{
              chars: 8,
              mask: new i("000000-00")
            }, {mask: new i("0000000-00")}],
            CE: [{mask: new i("00000000-0")}],
            DF: [{mask: new i("00000000000-00")}],
            ES: [{mask: new i("00000000-0")}],
            GO: [{mask: new i("00.000.000-0")}],
            MA: [{mask: new i("000000000")}],
            MG: [{mask: new i("000.000.000/0000")}],
            MS: [{mask: new i("000000000")}],
            MT: [{mask: new i("0000000000-0")}],
            PA: [{mask: new i("00-000000-0")}],
            PB: [{mask: new i("00000000-0")}],
            PE: [{
              chars: 9,
              mask: new i("0000000-00")
            }, {mask: new i("00.0.000.0000000-0")}],
            PI: [{mask: new i("000000000")}],
            PR: [{mask: new i("000.00000-00")}],
            RJ: [{mask: new i("00.000.00-0")}],
            RN: [{
              chars: 9,
              mask: new i("00.000.000-0")
            }, {mask: new i("00.0.000.000-0")}],
            RO: [{mask: new i("0000000000000-0")}],
            RR: [{mask: new i("00000000-0")}],
            RS: [{mask: new i("000/0000000")}],
            SC: [{mask: new i("000.000.000")}],
            SE: [{mask: new i("00000000-0")}],
            SP: [{mask: new i("000.000.000.000")}, {mask: new i("-00000000.0/000")}],
            TO: [{mask: new i("00000000000")}]
          };
          return {
            restrict: "A",
            require: "ngModel",
            link: function(n, i, a, o) {
              function u(e) {
                return o.$isEmpty(e) ? e : r(e, c);
              }
              function l(e) {
                if (o.$isEmpty(e))
                  return e;
                var n = r(e, c),
                    i = t(n);
                return o.$viewValue !== n && (o.$setViewValue(n), o.$render()), c && "SP" === c.toUpperCase() && /^p/i.test(e) ? "P" + i : i;
              }
              var c = (e(a.uiBrIeMask)(n) || "").toUpperCase();
              o.$formatters.push(u), o.$parsers.push(l), o.$validators.ie = function(e) {
                return o.$isEmpty(e) || s.ie(c).validate(e);
              }, n.$watch(a.uiBrIeMask, function(e) {
                c = (e || "").toUpperCase(), l(o.$viewValue), o.$validate();
              });
            }
          };
        }
        var i = e("string-mask"),
            s = e("br-validations");
        r.$inject = ["$parse"], t.exports = r;
      }, {
        "br-validations": 1,
        "string-mask": 3
      }],
      12: [function(e, t, n) {
        var r = e("string-mask"),
            i = e("mask-factory"),
            s = new r("0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000");
        t.exports = i({
          clearValue: function(e) {
            return e.replace(/[^0-9]/g, "").slice(0, 44);
          },
          format: function(e) {
            return (s.apply(e) || "").replace(/[^0-9]$/, "");
          },
          validations: {nfeAccessKey: function(e) {
              return 44 === e.length;
            }}
        });
      }, {
        "mask-factory": "mask-factory",
        "string-mask": 3
      }],
      13: [function(e, t, n) {
        var r = e("string-mask"),
            i = e("mask-factory"),
            s = new r("(00) 0000-0000"),
            a = new r("(00) 00000-0000"),
            o = new r("0000-000-0000");
        t.exports = i({
          clearValue: function(e) {
            return e.toString().replace(/[^0-9]/g, "").slice(0, 11);
          },
          format: function(e) {
            var t;
            return t = 0 === e.indexOf("0800") ? o.apply(e) : e.length < 11 ? s.apply(e) || "" : a.apply(e), t.trim().replace(/[^0-9]$/, "");
          },
          getModelValue: function(e, t) {
            var n = this.clearValue(e);
            return "number" === t ? parseInt(n) : n;
          },
          validations: {brPhoneNumber: function(e) {
              var t = e && e.toString().length;
              return 10 === t || 11 === t;
            }}
        });
      }, {
        "mask-factory": "mask-factory",
        "string-mask": 3
      }],
      14: [function(e, t, n) {
        function r(e) {
          var t = {"pt-br": "DD/MM/YYYY"},
              n = t[e.id] || "YYYY-MM-DD";
          return {
            restrict: "A",
            require: "ngModel",
            link: function(e, t, r, a) {
              function o(e) {
                if (a.$isEmpty(e))
                  return e;
                var t = e;
                "object" == typeof e && (t = i(e).format(n)), t = t.replace(/[^0-9]/g, "");
                var r = u.apply(t) || "";
                return r.trim().replace(/[^0-9]$/, "");
              }
              var u = new s(n.replace(/[YMD]/g, "0"));
              a.$formatters.push(o), a.$parsers.push(function(e) {
                if (a.$isEmpty(e))
                  return e;
                var t = o(e);
                return a.$viewValue !== t && (a.$setViewValue(t), a.$render()), i(t, n).toDate();
              }), a.$validators.date = function(e, t) {
                return a.$isEmpty(e) ? !0 : i(t, n).isValid() && t.length === n.length;
              };
            }
          };
        }
        var i = e("moment"),
            s = e("string-mask");
        r.$inject = ["$locale"], t.exports = r;
      }, {
        moment: 2,
        "string-mask": 3
      }],
      15: [function(e, t, n) {
        var r = angular.module("ui.utils.masks.global", [e("../helpers")]).directive("uiDateMask", e("./date/date")).directive("uiMoneyMask", e("./money/money")).directive("uiNumberMask", e("./number/number")).directive("uiPercentageMask", e("./percentage/percentage")).directive("uiScientificNotationMask", e("./scientific-notation/scientific-notation")).directive("uiTimeMask", e("./time/time"));
        t.exports = r.name;
      }, {
        "../helpers": 21,
        "./date/date": 14,
        "./money/money": 16,
        "./number/number": 17,
        "./percentage/percentage": 18,
        "./scientific-notation/scientific-notation": 19,
        "./time/time": 20
      }],
      16: [function(e, t, n) {
        function r(e, t, n) {
          return {
            restrict: "A",
            require: "ngModel",
            link: function(r, a, o, u) {
              function l(e) {
                var t = e > 0 ? d + new Array(e + 1).join("0") : "",
                    n = h + " #" + m + "##0" + t;
                return new i(n, {reverse: !0});
              }
              function c(e) {
                if (u.$isEmpty(e))
                  return e;
                var t = angular.isDefined(o.uiNegativeNumber) && 0 > e ? "-" : "",
                    r = n.prepareNumberToFormatter(e, p);
                return t + v.apply(r);
              }
              function f(e) {
                if (u.$isEmpty(e))
                  return e;
                var t = e.replace(/[^\d]+/g, "");
                t = t.replace(/^[0]+([1-9])/, "$1");
                var n = v.apply(t);
                if (angular.isDefined(o.uiNegativeNumber)) {
                  var r = "-" === e[0],
                      i = "-" === e.slice(-1);
                  i ^ r && t && (t *= -1, n = "-" + n);
                }
                return e !== n && (u.$setViewValue(n), u.$render()), n ? parseInt(n.replace(/[^\d\-]+/g, "")) / Math.pow(10, p) : null;
              }
              var d = e.NUMBER_FORMATS.DECIMAL_SEP,
                  m = e.NUMBER_FORMATS.GROUP_SEP,
                  h = e.NUMBER_FORMATS.CURRENCY_SYM,
                  p = t(o.uiMoneyMask)(r);
              angular.isDefined(o.uiHideGroupSep) && (m = ""), isNaN(p) && (p = 2);
              var v = l(p);
              if (u.$formatters.push(c), u.$parsers.push(f), o.uiMoneyMask && r.$watch(o.uiMoneyMask, function(e) {
                p = isNaN(e) ? 2 : e, v = l(p), f(u.$viewValue);
              }), o.min) {
                var g;
                u.$validators.min = function(e) {
                  return s.minNumber(u, e, g);
                }, r.$watch(o.min, function(e) {
                  g = e, u.$validate();
                });
              }
              if (o.max) {
                var y;
                u.$validators.max = function(e) {
                  return s.maxNumber(u, e, y);
                }, r.$watch(o.max, function(e) {
                  y = e, u.$validate();
                });
              }
            }
          };
        }
        var i = e("string-mask"),
            s = e("validators");
        r.$inject = ["$locale", "$parse", "PreFormatters"], t.exports = r;
      }, {
        "string-mask": 3,
        validators: "validators"
      }],
      17: [function(e, t, n) {
        function r(e, t, n, r) {
          return {
            restrict: "A",
            require: "ngModel",
            link: function(s, a, o, u) {
              function l(e) {
                if (u.$isEmpty(e))
                  return null;
                var t = n.clearDelimitersAndLeadingZeros(e) || "0",
                    r = h.apply(t),
                    i = parseFloat(p.apply(t));
                if (angular.isDefined(o.uiNegativeNumber)) {
                  var s = "-" === e[0],
                      a = "-" === e.slice(-1);
                  a ^ s && i && (i *= -1, r = "-" + r);
                }
                return u.$viewValue !== r && (u.$setViewValue(r), u.$render()), i;
              }
              function c(e) {
                if (u.$isEmpty(e))
                  return e;
                var t = angular.isDefined(o.uiNegativeNumber) && 0 > e ? "-" : "",
                    r = n.prepareNumberToFormatter(e, m);
                return t + h.apply(r);
              }
              var f = e.NUMBER_FORMATS.DECIMAL_SEP,
                  d = e.NUMBER_FORMATS.GROUP_SEP,
                  m = t(o.uiNumberMask)(s);
              angular.isDefined(o.uiHideGroupSep) && (d = ""), isNaN(m) && (m = 2);
              var h = r.viewMask(m, f, d),
                  p = r.modelMask(m);
              if (u.$formatters.push(c), u.$parsers.push(l), o.uiNumberMask && s.$watch(o.uiNumberMask, function(e) {
                m = isNaN(e) ? 2 : e, h = r.viewMask(m, f, d), p = r.modelMask(m), l(u.$viewValue);
              }), o.min) {
                var v;
                u.$validators.min = function(e) {
                  return i.minNumber(u, e, v);
                }, s.$watch(o.min, function(e) {
                  v = e, u.$validate();
                });
              }
              if (o.max) {
                var g;
                u.$validators.max = function(e) {
                  return i.maxNumber(u, e, g);
                }, s.$watch(o.max, function(e) {
                  g = e, u.$validate();
                });
              }
            }
          };
        }
        var i = e("validators");
        r.$inject = ["$locale", "$parse", "PreFormatters", "NumberMasks"], t.exports = r;
      }, {validators: "validators"}],
      18: [function(e, t, n) {
        function r(e, t, n, r) {
          function s(e, t, r) {
            return n.clearDelimitersAndLeadingZeros((parseFloat(e) * r).toFixed(t));
          }
          return {
            restrict: "A",
            require: "ngModel",
            link: function(t, a, o, u) {
              function l(e) {
                if (u.$isEmpty(e))
                  return e;
                var t = s(e, m, h.multiplier);
                return v.apply(t) + " %";
              }
              function c(e) {
                if (u.$isEmpty(e))
                  return null;
                var t = n.clearDelimitersAndLeadingZeros(e) || "0";
                e.length > 1 && -1 === e.indexOf("%") && (t = t.slice(0, t.length - 1));
                var r = v.apply(t) + " %",
                    i = parseFloat(g.apply(t));
                return u.$viewValue !== r && (u.$setViewValue(r), u.$render()), i;
              }
              var f = e.NUMBER_FORMATS.DECIMAL_SEP,
                  d = e.NUMBER_FORMATS.GROUP_SEP,
                  m = parseInt(o.uiPercentageMask),
                  h = {
                    multiplier: 100,
                    decimalMask: 2
                  };
              angular.isDefined(o.uiHideGroupSep) && (d = ""), angular.isDefined(o.uiPercentageValue) && (h.multiplier = 1, h.decimalMask = 0), isNaN(m) && (m = 2);
              var p = m + h.decimalMask,
                  v = r.viewMask(m, f, d),
                  g = r.modelMask(p);
              if (u.$formatters.push(l), u.$parsers.push(c), o.uiPercentageMask && t.$watch(o.uiPercentageMask, function(e) {
                m = isNaN(e) ? 2 : e, angular.isDefined(o.uiPercentageValue) && (h.multiplier = 1, h.decimalMask = 0), p = m + h.decimalMask, v = r.viewMask(m, f, d), g = r.modelMask(p), c(u.$viewValue);
              }), o.min) {
                var y;
                u.$validators.min = function(e) {
                  return i.minNumber(u, e, y);
                }, t.$watch(o.min, function(e) {
                  y = e, u.$validate();
                });
              }
              if (o.max) {
                var _;
                u.$validators.max = function(e) {
                  return i.maxNumber(u, e, _);
                }, t.$watch(o.max, function(e) {
                  _ = e, u.$validate();
                });
              }
            }
          };
        }
        var i = e("validators");
        r.$inject = ["$locale", "$parse", "PreFormatters", "NumberMasks"], t.exports = r;
      }, {validators: "validators"}],
      19: [function(e, t, n) {
        function r(e, t) {
          function n(e) {
            var t = "0";
            if (e > 0) {
              t += r;
              for (var n = 0; e > n; n++)
                t += "0";
            }
            return new i(t, {reverse: !0});
          }
          var r = e.NUMBER_FORMATS.DECIMAL_SEP,
              s = 2;
          return {
            restrict: "A",
            require: "ngModel",
            link: function(e, i, a, o) {
              function u(e) {
                var t = e.toString(),
                    n = t.match(/(-?[0-9]*)[\.]?([0-9]*)?[Ee]?([\+-]?[0-9]*)?/);
                return {
                  integerPartOfSignificand: n[1],
                  decimalPartOfSignificand: n[2],
                  exponent: 0 | n[3]
                };
              }
              function l(e) {
                if (o.$isEmpty(e))
                  return e;
                "string" == typeof e ? e = e.replace(r, ".") : "number" == typeof e && (e = e.toExponential(f));
                var t,
                    n,
                    i = u(e),
                    s = i.integerPartOfSignificand || 0,
                    a = s.toString();
                angular.isDefined(i.decimalPartOfSignificand) && (a += i.decimalPartOfSignificand);
                var l = (s >= 1 || -1 >= s) && (angular.isDefined(i.decimalPartOfSignificand) && i.decimalPartOfSignificand.length > f || 0 === f && a.length >= 2);
                return l && (n = a.slice(f + 1, a.length), a = a.slice(0, f + 1)), t = d.apply(a), 0 !== i.exponent && (n = i.exponent), angular.isDefined(n) && (t += "e" + n), t;
              }
              function c(e) {
                if (o.$isEmpty(e))
                  return e;
                var t = l(e),
                    n = parseFloat(t.replace(r, "."));
                return o.$viewValue !== t && (o.$setViewValue(t), o.$render()), n;
              }
              var f = t(a.uiScientificNotationMask)(e);
              isNaN(f) && (f = s);
              var d = n(f);
              o.$formatters.push(l), o.$parsers.push(c), o.$validators.max = function(e) {
                return o.$isEmpty(e) || e < Number.MAX_VALUE;
              };
            }
          };
        }
        var i = e("string-mask");
        r.$inject = ["$locale", "$parse"], t.exports = r;
      }, {"string-mask": 3}],
      20: [function(e, t, n) {
        var r = e("string-mask");
        t.exports = function() {
          return {
            restrict: "A",
            require: "ngModel",
            link: function(e, t, n, i) {
              function s(e) {
                if (i.$isEmpty(e))
                  return e;
                var t = e.replace(/[^0-9]/g, "").slice(0, u) || "";
                return (l.apply(t) || "").replace(/[^0-9]$/, "");
              }
              var a = "00:00:00";
              angular.isDefined(n.uiTimeMask) && "short" === n.uiTimeMask && (a = "00:00");
              var o = a.length,
                  u = a.replace(":", "").length,
                  l = new r(a);
              i.$formatters.push(s), i.$parsers.push(function(e) {
                if (i.$isEmpty(e))
                  return e;
                var t = s(e),
                    n = t;
                return i.$viewValue !== t && (i.$setViewValue(t), i.$render()), n;
              }), i.$validators.time = function(e) {
                if (i.$isEmpty(e))
                  return !0;
                var t = e.toString().split(/:/).filter(function(e) {
                  return !!e;
                }),
                    n = parseInt(t[0]),
                    r = parseInt(t[1]),
                    s = parseInt(t[2] || 0);
                return e.toString().length === o && 24 > n && 60 > r && 60 > s;
              };
            }
          };
        };
      }, {"string-mask": 3}],
      21: [function(e, t, n) {
        var r = e("string-mask"),
            i = angular.module("ui.utils.masks.helpers", []);
        t.exports = i.name, i.factory("PreFormatters", [function() {
          function e(e) {
            if ("0" === e)
              return "0";
            var t = e.replace(/^-/, "").replace(/^0*/, "");
            return t.replace(/[^0-9]/g, "");
          }
          function t(t, n) {
            return e(parseFloat(t).toFixed(n));
          }
          return {
            clearDelimitersAndLeadingZeros: e,
            prepareNumberToFormatter: t
          };
        }]).factory("NumberValidators", [function() {
          return {
            maxNumber: function(e, t, n) {
              var r = parseFloat(n),
                  i = e.$isEmpty(t) || isNaN(r) || r >= t;
              return e.$setValidity("max", i), t;
            },
            minNumber: function(e, t, n) {
              var r = parseFloat(n),
                  i = e.$isEmpty(t) || isNaN(r) || t >= r;
              return e.$setValidity("min", i), t;
            }
          };
        }]).factory("NumberMasks", [function() {
          return {
            viewMask: function(e, t, n) {
              var i = "#" + n + "##0";
              if (e > 0) {
                i += t;
                for (var s = 0; e > s; s++)
                  i += "0";
              }
              return new r(i, {reverse: !0});
            },
            modelMask: function(e) {
              var t = "###0";
              if (e > 0) {
                t += ".";
                for (var n = 0; e > n; n++)
                  t += "0";
              }
              return new r(t, {reverse: !0});
            }
          };
        }]);
      }, {"string-mask": 3}],
      22: [function(e, t, n) {
        var r = e("string-mask"),
            i = e("mask-factory"),
            s = new r("(000) 000-0000"),
            a = new r("+00-00-000-000000");
        t.exports = i({
          clearValue: function(e) {
            return e.toString().replace(/[^0-9]/g, "");
          },
          format: function(e) {
            var t;
            return t = e.length < 11 ? s.apply(e) || "" : a.apply(e), t.trim().replace(/[^0-9]$/, "");
          },
          validations: {usPhoneNumber: function(e) {
              return e.length > 9;
            }}
        });
      }, {
        "mask-factory": "mask-factory",
        "string-mask": 3
      }],
      23: [function(e, t, n) {
        var r = angular.module("ui.utils.masks.us", [e("../helpers")]).directive("uiUsPhoneNumber", e("./phone/us-phone"));
        t.exports = r.name;
      }, {
        "../helpers": 21,
        "./phone/us-phone": 22
      }],
      "mask-factory": [function(e, t, n) {
        t.exports = function(e) {
          return function() {
            return {
              restrict: "A",
              require: "ngModel",
              link: function(t, n, r, i) {
                i.$formatters.push(function(t) {
                  if (i.$isEmpty(t))
                    return t;
                  var n = e.clearValue(t);
                  return e.format(n);
                }), i.$parsers.push(function(t) {
                  if (i.$isEmpty(t))
                    return t;
                  var n = e.clearValue(t),
                      r = e.format(n);
                  if (i.$viewValue !== r && (i.$setViewValue(r), i.$render()), angular.isUndefined(e.getModelValue))
                    return n;
                  var s = typeof i.$modelValue;
                  return e.getModelValue(r, s);
                }), angular.forEach(e.validations, function(e, t) {
                  i.$validators[t] = function(t, n) {
                    return i.$isEmpty(t) || e(t, n);
                  };
                });
              }
            };
          };
        };
      }, {}],
      validators: [function(e, t, n) {
        t.exports = {
          maxNumber: function(e, t, n) {
            var r = parseFloat(n, 10);
            return e.$isEmpty(t) || isNaN(r) || r >= t;
          },
          minNumber: function(e, t, n) {
            var r = parseFloat(n, 10);
            return e.$isEmpty(t) || isNaN(r) || t >= r;
          }
        };
      }, {}]
    }, {}, [4]);
  })();
  return _retrieveGlobal();
});

System.registerDynamic("bower:angular-input-masks@2.1.1.js", ["bower:angular-input-masks@2.1.1/angular-input-masks-standalone.min.js"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = $__require('bower:angular-input-masks@2.1.1/angular-input-masks-standalone.min.js');
  global.define = __define;
  return module.exports;
});

System.registerDynamic("bower:ng-file-upload@12.0.4/ng-file-upload.js", [], false, function(__require, __exports, __module) {
  var _retrieveGlobal = System.get("@@global-helpers").prepareGlobal(__module.id, null, null);
  (function() {
    var ngFileUpload = this["ngFileUpload"];
    if (window.XMLHttpRequest && !(window.FileAPI && FileAPI.shouldLoad)) {
      window.XMLHttpRequest.prototype.setRequestHeader = (function(orig) {
        return function(header, value) {
          if (header === '__setXHR_') {
            var val = value(this);
            if (val instanceof Function) {
              val(this);
            }
          } else {
            orig.apply(this, arguments);
          }
        };
      })(window.XMLHttpRequest.prototype.setRequestHeader);
    }
    var ngFileUpload = angular.module('ngFileUpload', []);
    ngFileUpload.version = '12.0.4';
    ngFileUpload.service('UploadBase', ['$http', '$q', '$timeout', function($http, $q, $timeout) {
      var upload = this;
      upload.promisesCount = 0;
      this.isResumeSupported = function() {
        return window.Blob && window.Blob.prototype.slice;
      };
      var resumeSupported = this.isResumeSupported();
      function sendHttp(config) {
        config.method = config.method || 'POST';
        config.headers = config.headers || {};
        var deferred = config._deferred = config._deferred || $q.defer();
        var promise = deferred.promise;
        function notifyProgress(e) {
          if (deferred.notify) {
            deferred.notify(e);
          }
          if (promise.progressFunc) {
            $timeout(function() {
              promise.progressFunc(e);
            });
          }
        }
        function getNotifyEvent(n) {
          if (config._start != null && resumeSupported) {
            return {
              loaded: n.loaded + config._start,
              total: (config._file && config._file.size) || n.total,
              type: n.type,
              config: config,
              lengthComputable: true,
              target: n.target
            };
          } else {
            return n;
          }
        }
        if (!config.disableProgress) {
          config.headers.__setXHR_ = function() {
            return function(xhr) {
              if (!xhr || !xhr.upload || !xhr.upload.addEventListener)
                return;
              config.__XHR = xhr;
              if (config.xhrFn)
                config.xhrFn(xhr);
              xhr.upload.addEventListener('progress', function(e) {
                e.config = config;
                notifyProgress(getNotifyEvent(e));
              }, false);
              xhr.upload.addEventListener('load', function(e) {
                if (e.lengthComputable) {
                  e.config = config;
                  notifyProgress(getNotifyEvent(e));
                }
              }, false);
            };
          };
        }
        function uploadWithAngular() {
          $http(config).then(function(r) {
            if (resumeSupported && config._chunkSize && !config._finished && config._file) {
              notifyProgress({
                loaded: config._end,
                total: config._file && config._file.size,
                config: config,
                type: 'progress'
              });
              upload.upload(config, true);
            } else {
              if (config._finished)
                delete config._finished;
              deferred.resolve(r);
            }
          }, function(e) {
            deferred.reject(e);
          }, function(n) {
            deferred.notify(n);
          });
        }
        if (!resumeSupported) {
          uploadWithAngular();
        } else if (config._chunkSize && config._end && !config._finished) {
          config._start = config._end;
          config._end += config._chunkSize;
          uploadWithAngular();
        } else if (config.resumeSizeUrl) {
          $http.get(config.resumeSizeUrl).then(function(resp) {
            if (config.resumeSizeResponseReader) {
              config._start = config.resumeSizeResponseReader(resp.data);
            } else {
              config._start = parseInt((resp.data.size == null ? resp.data : resp.data.size).toString());
            }
            if (config._chunkSize) {
              config._end = config._start + config._chunkSize;
            }
            uploadWithAngular();
          }, function(e) {
            throw e;
          });
        } else if (config.resumeSize) {
          config.resumeSize().then(function(size) {
            config._start = size;
            uploadWithAngular();
          }, function(e) {
            throw e;
          });
        } else {
          if (config._chunkSize) {
            config._start = 0;
            config._end = config._start + config._chunkSize;
          }
          uploadWithAngular();
        }
        promise.success = function(fn) {
          promise.then(function(response) {
            fn(response.data, response.status, response.headers, config);
          });
          return promise;
        };
        promise.error = function(fn) {
          promise.then(null, function(response) {
            fn(response.data, response.status, response.headers, config);
          });
          return promise;
        };
        promise.progress = function(fn) {
          promise.progressFunc = fn;
          promise.then(null, null, function(n) {
            fn(n);
          });
          return promise;
        };
        promise.abort = promise.pause = function() {
          if (config.__XHR) {
            $timeout(function() {
              config.__XHR.abort();
            });
          }
          return promise;
        };
        promise.xhr = function(fn) {
          config.xhrFn = (function(origXhrFn) {
            return function() {
              if (origXhrFn)
                origXhrFn.apply(promise, arguments);
              fn.apply(promise, arguments);
            };
          })(config.xhrFn);
          return promise;
        };
        upload.promisesCount++;
        promise['finally'](function() {
          upload.promisesCount--;
        });
        return promise;
      }
      this.isUploadInProgress = function() {
        return upload.promisesCount > 0;
      };
      this.rename = function(file, name) {
        file.ngfName = name;
        return file;
      };
      this.jsonBlob = function(val) {
        if (val != null && !angular.isString(val)) {
          val = JSON.stringify(val);
        }
        var blob = new window.Blob([val], {type: 'application/json'});
        blob._ngfBlob = true;
        return blob;
      };
      this.json = function(val) {
        return angular.toJson(val);
      };
      function copy(obj) {
        var clone = {};
        for (var key in obj) {
          if (obj.hasOwnProperty(key)) {
            clone[key] = obj[key];
          }
        }
        return clone;
      }
      this.isFile = function(file) {
        return file != null && (file instanceof window.Blob || (file.flashId && file.name && file.size));
      };
      this.upload = function(config, internal) {
        function toResumeFile(file, formData) {
          if (file._ngfBlob)
            return file;
          config._file = config._file || file;
          if (config._start != null && resumeSupported) {
            if (config._end && config._end >= file.size) {
              config._finished = true;
              config._end = file.size;
            }
            var slice = file.slice(config._start, config._end || file.size);
            slice.name = file.name;
            slice.ngfName = file.ngfName;
            if (config._chunkSize) {
              formData.append('_chunkSize', config._chunkSize);
              formData.append('_currentChunkSize', config._end - config._start);
              formData.append('_chunkNumber', Math.floor(config._start / config._chunkSize));
              formData.append('_totalSize', config._file.size);
            }
            return slice;
          }
          return file;
        }
        function addFieldToFormData(formData, val, key) {
          if (val !== undefined) {
            if (angular.isDate(val)) {
              val = val.toISOString();
            }
            if (angular.isString(val)) {
              formData.append(key, val);
            } else if (upload.isFile(val)) {
              var file = toResumeFile(val, formData);
              var split = key.split(',');
              if (split[1]) {
                file.ngfName = split[1].replace(/^\s+|\s+$/g, '');
                key = split[0];
              }
              config._fileKey = config._fileKey || key;
              formData.append(key, file, file.ngfName || file.name);
            } else {
              if (angular.isObject(val)) {
                if (val.$$ngfCircularDetection)
                  throw 'ngFileUpload: Circular reference in config.data. Make sure specified data for Upload.upload() has no circular reference: ' + key;
                val.$$ngfCircularDetection = true;
                try {
                  for (var k in val) {
                    if (val.hasOwnProperty(k) && k !== '$$ngfCircularDetection') {
                      var objectKey = config.objectKey == null ? '[i]' : config.objectKey;
                      if (val.length && parseInt(k) > -1) {
                        objectKey = config.arrayKey == null ? objectKey : config.arrayKey;
                      }
                      addFieldToFormData(formData, val[k], key + objectKey.replace(/[ik]/g, k));
                    }
                  }
                } finally {
                  delete val.$$ngfCircularDetection;
                }
              } else {
                formData.append(key, val);
              }
            }
          }
        }
        function digestConfig() {
          config._chunkSize = upload.translateScalars(config.resumeChunkSize);
          config._chunkSize = config._chunkSize ? parseInt(config._chunkSize.toString()) : null;
          config.headers = config.headers || {};
          config.headers['Content-Type'] = undefined;
          config.transformRequest = config.transformRequest ? (angular.isArray(config.transformRequest) ? config.transformRequest : [config.transformRequest]) : [];
          config.transformRequest.push(function(data) {
            var formData = new window.FormData(),
                key;
            data = data || config.fields || {};
            if (config.file) {
              data.file = config.file;
            }
            for (key in data) {
              if (data.hasOwnProperty(key)) {
                var val = data[key];
                if (config.formDataAppender) {
                  config.formDataAppender(formData, key, val);
                } else {
                  addFieldToFormData(formData, val, key);
                }
              }
            }
            return formData;
          });
        }
        if (!internal)
          config = copy(config);
        if (!config._isDigested) {
          config._isDigested = true;
          digestConfig();
        }
        return sendHttp(config);
      };
      this.http = function(config) {
        config = copy(config);
        config.transformRequest = config.transformRequest || function(data) {
          if ((window.ArrayBuffer && data instanceof window.ArrayBuffer) || data instanceof window.Blob) {
            return data;
          }
          return $http.defaults.transformRequest[0].apply(this, arguments);
        };
        config._chunkSize = upload.translateScalars(config.resumeChunkSize);
        config._chunkSize = config._chunkSize ? parseInt(config._chunkSize.toString()) : null;
        return sendHttp(config);
      };
      this.translateScalars = function(str) {
        if (angular.isString(str)) {
          if (str.search(/kb/i) === str.length - 2) {
            return parseFloat(str.substring(0, str.length - 2) * 1024);
          } else if (str.search(/mb/i) === str.length - 2) {
            return parseFloat(str.substring(0, str.length - 2) * 1048576);
          } else if (str.search(/gb/i) === str.length - 2) {
            return parseFloat(str.substring(0, str.length - 2) * 1073741824);
          } else if (str.search(/b/i) === str.length - 1) {
            return parseFloat(str.substring(0, str.length - 1));
          } else if (str.search(/s/i) === str.length - 1) {
            return parseFloat(str.substring(0, str.length - 1));
          } else if (str.search(/m/i) === str.length - 1) {
            return parseFloat(str.substring(0, str.length - 1) * 60);
          } else if (str.search(/h/i) === str.length - 1) {
            return parseFloat(str.substring(0, str.length - 1) * 3600);
          }
        }
        return str;
      };
      this.urlToBlob = function(url) {
        var defer = $q.defer();
        $http({
          url: url,
          method: 'get',
          responseType: 'arraybuffer'
        }).then(function(resp) {
          var arrayBufferView = new Uint8Array(resp.data);
          var type = resp.headers('content-type') || 'image/WebP';
          var blob = new window.Blob([arrayBufferView], {type: type});
          defer.resolve(blob);
        }, function(e) {
          defer.reject(e);
        });
        return defer.promise;
      };
      this.setDefaults = function(defaults) {
        this.defaults = defaults || {};
      };
      this.defaults = {};
      this.version = ngFileUpload.version;
    }]);
    ngFileUpload.service('Upload', ['$parse', '$timeout', '$compile', '$q', 'UploadExif', function($parse, $timeout, $compile, $q, UploadExif) {
      var upload = UploadExif;
      upload.getAttrWithDefaults = function(attr, name) {
        if (attr[name] != null)
          return attr[name];
        var def = upload.defaults[name];
        return (def == null ? def : (angular.isString(def) ? def : JSON.stringify(def)));
      };
      upload.attrGetter = function(name, attr, scope, params) {
        var attrVal = this.getAttrWithDefaults(attr, name);
        if (scope) {
          try {
            if (params) {
              return $parse(attrVal)(scope, params);
            } else {
              return $parse(attrVal)(scope);
            }
          } catch (e) {
            if (name.search(/min|max|pattern/i)) {
              return attrVal;
            } else {
              throw e;
            }
          }
        } else {
          return attrVal;
        }
      };
      upload.shouldUpdateOn = function(type, attr, scope) {
        var modelOptions = upload.attrGetter('ngModelOptions', attr, scope);
        if (modelOptions && modelOptions.updateOn) {
          return modelOptions.updateOn.split(' ').indexOf(type) > -1;
        }
        return true;
      };
      upload.emptyPromise = function() {
        var d = $q.defer();
        var args = arguments;
        $timeout(function() {
          d.resolve.apply(d, args);
        });
        return d.promise;
      };
      upload.rejectPromise = function() {
        var d = $q.defer();
        var args = arguments;
        $timeout(function() {
          d.reject.apply(d, args);
        });
        return d.promise;
      };
      upload.happyPromise = function(promise, data) {
        var d = $q.defer();
        promise.then(function(result) {
          d.resolve(result);
        }, function(error) {
          $timeout(function() {
            throw error;
          });
          d.resolve(data);
        });
        return d.promise;
      };
      function applyExifRotations(files, attr, scope) {
        var promises = [upload.emptyPromise()];
        angular.forEach(files, function(f, i) {
          if (f.type.indexOf('image/jpeg') === 0 && upload.attrGetter('ngfFixOrientation', attr, scope, {$file: f})) {
            promises.push(upload.happyPromise(upload.applyExifRotation(f), f).then(function(fixedFile) {
              files.splice(i, 1, fixedFile);
            }));
          }
        });
        return $q.all(promises);
      }
      function resize(files, attr, scope) {
        var resizeVal = upload.attrGetter('ngfResize', attr, scope);
        if (!resizeVal || !upload.isResizeSupported() || !files.length)
          return upload.emptyPromise();
        if (resizeVal instanceof Function) {
          var defer = $q.defer();
          resizeVal(files).then(function(p) {
            resizeWithParams(p, files, attr, scope).then(function(r) {
              defer.resolve(r);
            }, function(e) {
              defer.reject(e);
            });
          }, function(e) {
            defer.reject(e);
          });
        } else {
          return resizeWithParams(resizeVal, files, attr, scope);
        }
      }
      function resizeWithParams(param, files, attr, scope) {
        var promises = [upload.emptyPromise()];
        function handleFile(f, i) {
          if (f.type.indexOf('image') === 0) {
            if (param.pattern && !upload.validatePattern(f, param.pattern))
              return;
            var promise = upload.resize(f, param.width, param.height, param.quality, param.type, param.ratio, param.centerCrop, function(width, height) {
              return upload.attrGetter('ngfResizeIf', attr, scope, {
                $width: width,
                $height: height,
                $file: f
              });
            }, param.restoreExif !== false);
            promises.push(promise);
            promise.then(function(resizedFile) {
              files.splice(i, 1, resizedFile);
            }, function(e) {
              f.$error = 'resize';
              f.$errorParam = (e ? (e.message ? e.message : e) + ': ' : '') + (f && f.name);
            });
          }
        }
        for (var i = 0; i < files.length; i++) {
          handleFile(files[i], i);
        }
        return $q.all(promises);
      }
      upload.updateModel = function(ngModel, attr, scope, fileChange, files, evt, noDelay) {
        function update(files, invalidFiles, newFiles, dupFiles, isSingleModel) {
          attr.$$ngfPrevValidFiles = files;
          attr.$$ngfPrevInvalidFiles = invalidFiles;
          var file = files && files.length ? files[0] : null;
          var invalidFile = invalidFiles && invalidFiles.length ? invalidFiles[0] : null;
          if (ngModel) {
            upload.applyModelValidation(ngModel, files);
            ngModel.$setViewValue(isSingleModel ? file : files);
          }
          if (fileChange) {
            $parse(fileChange)(scope, {
              $files: files,
              $file: file,
              $newFiles: newFiles,
              $duplicateFiles: dupFiles,
              $invalidFiles: invalidFiles,
              $invalidFile: invalidFile,
              $event: evt
            });
          }
          var invalidModel = upload.attrGetter('ngfModelInvalid', attr);
          if (invalidModel) {
            $timeout(function() {
              $parse(invalidModel).assign(scope, isSingleModel ? invalidFile : invalidFiles);
            });
          }
          $timeout(function() {});
        }
        var allNewFiles,
            dupFiles = [],
            prevValidFiles,
            prevInvalidFiles,
            invalids = [],
            valids = [];
        function removeDuplicates() {
          function equals(f1, f2) {
            return f1.name === f2.name && (f1.$ngfOrigSize || f1.size) === (f2.$ngfOrigSize || f2.size) && f1.type === f2.type;
          }
          function isInPrevFiles(f) {
            var j;
            for (j = 0; j < prevValidFiles.length; j++) {
              if (equals(f, prevValidFiles[j])) {
                return true;
              }
            }
            for (j = 0; j < prevInvalidFiles.length; j++) {
              if (equals(f, prevInvalidFiles[j])) {
                return true;
              }
            }
            return false;
          }
          if (files) {
            allNewFiles = [];
            dupFiles = [];
            for (var i = 0; i < files.length; i++) {
              if (isInPrevFiles(files[i])) {
                dupFiles.push(files[i]);
              } else {
                allNewFiles.push(files[i]);
              }
            }
          }
        }
        function toArray(v) {
          return angular.isArray(v) ? v : [v];
        }
        function separateInvalids() {
          valids = [];
          invalids = [];
          angular.forEach(allNewFiles, function(file) {
            if (file.$error) {
              invalids.push(file);
            } else {
              valids.push(file);
            }
          });
        }
        function resizeAndUpdate() {
          function updateModel() {
            $timeout(function() {
              update(keep ? prevValidFiles.concat(valids) : valids, keep ? prevInvalidFiles.concat(invalids) : invalids, files, dupFiles, isSingleModel);
            }, options && options.debounce ? options.debounce.change || options.debounce : 0);
          }
          resize(validateAfterResize ? allNewFiles : valids, attr, scope).then(function() {
            if (validateAfterResize) {
              upload.validate(allNewFiles, prevValidFiles.length, ngModel, attr, scope).then(function() {
                separateInvalids();
                updateModel();
              });
            } else {
              updateModel();
            }
          }, function(e) {
            throw 'Could not resize files ' + e;
          });
        }
        prevValidFiles = attr.$$ngfPrevValidFiles || [];
        prevInvalidFiles = attr.$$ngfPrevInvalidFiles || [];
        if (ngModel && ngModel.$modelValue) {
          prevValidFiles = toArray(ngModel.$modelValue);
        }
        var keep = upload.attrGetter('ngfKeep', attr, scope);
        allNewFiles = (files || []).slice(0);
        if (keep === 'distinct' || upload.attrGetter('ngfKeepDistinct', attr, scope) === true) {
          removeDuplicates(attr, scope);
        }
        var isSingleModel = !keep && !upload.attrGetter('ngfMultiple', attr, scope) && !upload.attrGetter('multiple', attr);
        if (keep && !allNewFiles.length)
          return;
        upload.attrGetter('ngfBeforeModelChange', attr, scope, {
          $files: files,
          $file: files && files.length ? files[0] : null,
          $newFiles: allNewFiles,
          $duplicateFiles: dupFiles,
          $event: evt
        });
        var validateAfterResize = upload.attrGetter('ngfValidateAfterResize', attr, scope);
        var options = upload.attrGetter('ngModelOptions', attr, scope);
        upload.validate(allNewFiles, prevValidFiles.length, ngModel, attr, scope).then(function() {
          if (noDelay) {
            update(allNewFiles, [], files, dupFiles, isSingleModel);
          } else {
            if ((!options || !options.allowInvalid) && !validateAfterResize) {
              separateInvalids();
            } else {
              valids = allNewFiles;
            }
            if (upload.attrGetter('ngfFixOrientation', attr, scope) && upload.isExifSupported()) {
              applyExifRotations(valids, attr, scope).then(function() {
                resizeAndUpdate();
              });
            } else {
              resizeAndUpdate();
            }
          }
        });
      };
      return upload;
    }]);
    ngFileUpload.directive('ngfSelect', ['$parse', '$timeout', '$compile', 'Upload', function($parse, $timeout, $compile, Upload) {
      var generatedElems = [];
      function isDelayedClickSupported(ua) {
        var m = ua.match(/Android[^\d]*(\d+)\.(\d+)/);
        if (m && m.length > 2) {
          var v = Upload.defaults.androidFixMinorVersion || 4;
          return parseInt(m[1]) < 4 || (parseInt(m[1]) === v && parseInt(m[2]) < v);
        }
        return ua.indexOf('Chrome') === -1 && /.*Windows.*Safari.*/.test(ua);
      }
      function linkFileSelect(scope, elem, attr, ngModel, $parse, $timeout, $compile, upload) {
        var attrGetter = function(name, scope) {
          return upload.attrGetter(name, attr, scope);
        };
        function isInputTypeFile() {
          return elem[0].tagName.toLowerCase() === 'input' && attr.type && attr.type.toLowerCase() === 'file';
        }
        function fileChangeAttr() {
          return attrGetter('ngfChange') || attrGetter('ngfSelect');
        }
        function changeFn(evt) {
          if (upload.shouldUpdateOn('change', attr, scope)) {
            var fileList = evt.__files_ || (evt.target && evt.target.files),
                files = [];
            for (var i = 0; i < fileList.length; i++) {
              files.push(fileList[i]);
            }
            upload.updateModel(ngModel, attr, scope, fileChangeAttr(), files.length ? files : null, evt);
          }
        }
        upload.registerModelChangeValidator(ngModel, attr, scope);
        var unwatches = [];
        unwatches.push(scope.$watch(attrGetter('ngfMultiple'), function() {
          fileElem.attr('multiple', attrGetter('ngfMultiple', scope));
        }));
        unwatches.push(scope.$watch(attrGetter('ngfCapture'), function() {
          fileElem.attr('capture', attrGetter('ngfCapture', scope));
        }));
        unwatches.push(scope.$watch(attrGetter('ngfAccept'), function() {
          fileElem.attr('accept', attrGetter('ngfAccept', scope));
        }));
        attr.$observe('accept', function() {
          fileElem.attr('accept', attrGetter('accept'));
        });
        unwatches.push(function() {
          if (attr.$$observers)
            delete attr.$$observers.accept;
        });
        function bindAttrToFileInput(fileElem) {
          if (elem !== fileElem) {
            for (var i = 0; i < elem[0].attributes.length; i++) {
              var attribute = elem[0].attributes[i];
              if (attribute.name !== 'type' && attribute.name !== 'class' && attribute.name !== 'style') {
                if (attribute.value == null || attribute.value === '') {
                  if (attribute.name === 'required')
                    attribute.value = 'required';
                  if (attribute.name === 'multiple')
                    attribute.value = 'multiple';
                }
                fileElem.attr(attribute.name, attribute.name === 'id' ? 'ngf-' + attribute.value : attribute.value);
              }
            }
          }
        }
        function createFileInput() {
          if (isInputTypeFile()) {
            return elem;
          }
          var fileElem = angular.element('<input type="file">');
          bindAttrToFileInput(fileElem);
          var label = angular.element('<label>upload</label>');
          label.css('visibility', 'hidden').css('position', 'absolute').css('overflow', 'hidden').css('width', '0px').css('height', '0px').css('border', 'none').css('margin', '0px').css('padding', '0px').attr('tabindex', '-1');
          generatedElems.push({
            el: elem,
            ref: label
          });
          document.body.appendChild(label.append(fileElem)[0]);
          return fileElem;
        }
        var initialTouchStartY = 0;
        function clickHandler(evt) {
          if (elem.attr('disabled'))
            return false;
          if (attrGetter('ngfSelectDisabled', scope))
            return;
          var r = handleTouch(evt);
          if (r != null)
            return r;
          resetModel(evt);
          try {
            if (!isInputTypeFile() && !document.body.contains(fileElem[0])) {
              generatedElems.push({
                el: elem,
                ref: fileElem.parent()
              });
              document.body.appendChild(fileElem.parent()[0]);
              fileElem.bind('change', changeFn);
            }
          } catch (e) {}
          if (isDelayedClickSupported(navigator.userAgent)) {
            setTimeout(function() {
              fileElem[0].click();
            }, 0);
          } else {
            fileElem[0].click();
          }
          return false;
        }
        function handleTouch(evt) {
          var touches = evt.changedTouches || (evt.originalEvent && evt.originalEvent.changedTouches);
          if (evt.type === 'touchstart') {
            initialTouchStartY = touches ? touches[0].clientY : 0;
            return true;
          } else {
            evt.stopPropagation();
            evt.preventDefault();
            if (evt.type === 'touchend') {
              var currentLocation = touches ? touches[0].clientY : 0;
              if (Math.abs(currentLocation - initialTouchStartY) > 20)
                return false;
            }
          }
        }
        var fileElem = elem;
        function resetModel(evt) {
          if (upload.shouldUpdateOn('click', attr, scope) && fileElem.val()) {
            fileElem.val(null);
            upload.updateModel(ngModel, attr, scope, fileChangeAttr(), null, evt, true);
          }
        }
        if (!isInputTypeFile()) {
          fileElem = createFileInput();
        }
        fileElem.bind('change', changeFn);
        if (!isInputTypeFile()) {
          elem.bind('click touchstart touchend', clickHandler);
        } else {
          elem.bind('click', resetModel);
        }
        function ie10SameFileSelectFix(evt) {
          if (fileElem && !fileElem.attr('__ngf_ie10_Fix_')) {
            if (!fileElem[0].parentNode) {
              fileElem = null;
              return;
            }
            evt.preventDefault();
            evt.stopPropagation();
            fileElem.unbind('click');
            var clone = fileElem.clone();
            fileElem.replaceWith(clone);
            fileElem = clone;
            fileElem.attr('__ngf_ie10_Fix_', 'true');
            fileElem.bind('change', changeFn);
            fileElem.bind('click', ie10SameFileSelectFix);
            fileElem[0].click();
            return false;
          } else {
            fileElem.removeAttr('__ngf_ie10_Fix_');
          }
        }
        if (navigator.appVersion.indexOf('MSIE 10') !== -1) {
          fileElem.bind('click', ie10SameFileSelectFix);
        }
        if (ngModel)
          ngModel.$formatters.push(function(val) {
            if (val == null || val.length === 0) {
              if (fileElem.val()) {
                fileElem.val(null);
              }
            }
            return val;
          });
        scope.$on('$destroy', function() {
          if (!isInputTypeFile())
            fileElem.parent().remove();
          angular.forEach(unwatches, function(unwatch) {
            unwatch();
          });
        });
        $timeout(function() {
          for (var i = 0; i < generatedElems.length; i++) {
            var g = generatedElems[i];
            if (!document.body.contains(g.el[0])) {
              generatedElems.splice(i, 1);
              g.ref.remove();
            }
          }
        });
        if (window.FileAPI && window.FileAPI.ngfFixIE) {
          window.FileAPI.ngfFixIE(elem, fileElem, changeFn);
        }
      }
      return {
        restrict: 'AEC',
        require: '?ngModel',
        link: function(scope, elem, attr, ngModel) {
          linkFileSelect(scope, elem, attr, ngModel, $parse, $timeout, $compile, Upload);
        }
      };
    }]);
    (function() {
      ngFileUpload.service('UploadDataUrl', ['UploadBase', '$timeout', '$q', function(UploadBase, $timeout, $q) {
        var upload = UploadBase;
        upload.base64DataUrl = function(file) {
          if (angular.isArray(file)) {
            var d = $q.defer(),
                count = 0;
            angular.forEach(file, function(f) {
              upload.dataUrl(f, true)['finally'](function() {
                count++;
                if (count === file.length) {
                  var urls = [];
                  angular.forEach(file, function(ff) {
                    urls.push(ff.$ngfDataUrl);
                  });
                  d.resolve(urls, file);
                }
              });
            });
            return d.promise;
          } else {
            return upload.dataUrl(file, true);
          }
        };
        upload.dataUrl = function(file, disallowObjectUrl) {
          if (!file)
            return upload.emptyPromise(file, file);
          if ((disallowObjectUrl && file.$ngfDataUrl != null) || (!disallowObjectUrl && file.$ngfBlobUrl != null)) {
            return upload.emptyPromise(disallowObjectUrl ? file.$ngfDataUrl : file.$ngfBlobUrl, file);
          }
          var p = disallowObjectUrl ? file.$$ngfDataUrlPromise : file.$$ngfBlobUrlPromise;
          if (p)
            return p;
          var deferred = $q.defer();
          $timeout(function() {
            if (window.FileReader && file && (!window.FileAPI || navigator.userAgent.indexOf('MSIE 8') === -1 || file.size < 20000) && (!window.FileAPI || navigator.userAgent.indexOf('MSIE 9') === -1 || file.size < 4000000)) {
              var URL = window.URL || window.webkitURL;
              if (URL && URL.createObjectURL && !disallowObjectUrl) {
                var url;
                try {
                  url = URL.createObjectURL(file);
                } catch (e) {
                  $timeout(function() {
                    file.$ngfBlobUrl = '';
                    deferred.reject();
                  });
                  return;
                }
                $timeout(function() {
                  file.$ngfBlobUrl = url;
                  if (url) {
                    deferred.resolve(url, file);
                    upload.blobUrls = upload.blobUrls || [];
                    upload.blobUrlsTotalSize = upload.blobUrlsTotalSize || 0;
                    upload.blobUrls.push({
                      url: url,
                      size: file.size
                    });
                    upload.blobUrlsTotalSize += file.size || 0;
                    var maxMemory = upload.defaults.blobUrlsMaxMemory || 268435456;
                    var maxLength = upload.defaults.blobUrlsMaxQueueSize || 200;
                    while ((upload.blobUrlsTotalSize > maxMemory || upload.blobUrls.length > maxLength) && upload.blobUrls.length > 1) {
                      var obj = upload.blobUrls.splice(0, 1)[0];
                      URL.revokeObjectURL(obj.url);
                      upload.blobUrlsTotalSize -= obj.size;
                    }
                  }
                });
              } else {
                var fileReader = new FileReader();
                fileReader.onload = function(e) {
                  $timeout(function() {
                    file.$ngfDataUrl = e.target.result;
                    deferred.resolve(e.target.result, file);
                    $timeout(function() {
                      delete file.$ngfDataUrl;
                    }, 1000);
                  });
                };
                fileReader.onerror = function() {
                  $timeout(function() {
                    file.$ngfDataUrl = '';
                    deferred.reject();
                  });
                };
                fileReader.readAsDataURL(file);
              }
            } else {
              $timeout(function() {
                file[disallowObjectUrl ? '$ngfDataUrl' : '$ngfBlobUrl'] = '';
                deferred.reject();
              });
            }
          });
          if (disallowObjectUrl) {
            p = file.$$ngfDataUrlPromise = deferred.promise;
          } else {
            p = file.$$ngfBlobUrlPromise = deferred.promise;
          }
          p['finally'](function() {
            delete file[disallowObjectUrl ? '$$ngfDataUrlPromise' : '$$ngfBlobUrlPromise'];
          });
          return p;
        };
        return upload;
      }]);
      function getTagType(el) {
        if (el.tagName.toLowerCase() === 'img')
          return 'image';
        if (el.tagName.toLowerCase() === 'audio')
          return 'audio';
        if (el.tagName.toLowerCase() === 'video')
          return 'video';
        return /./;
      }
      function linkFileDirective(Upload, $timeout, scope, elem, attr, directiveName, resizeParams, isBackground) {
        function constructDataUrl(file) {
          var disallowObjectUrl = Upload.attrGetter('ngfNoObjectUrl', attr, scope);
          Upload.dataUrl(file, disallowObjectUrl)['finally'](function() {
            $timeout(function() {
              var src = (disallowObjectUrl ? file.$ngfDataUrl : file.$ngfBlobUrl) || file.$ngfDataUrl;
              if (isBackground) {
                elem.css('background-image', 'url(\'' + (src || '') + '\')');
              } else {
                elem.attr('src', src);
              }
              if (src) {
                elem.removeClass('ng-hide');
              } else {
                elem.addClass('ng-hide');
              }
            });
          });
        }
        $timeout(function() {
          var unwatch = scope.$watch(attr[directiveName], function(file) {
            var size = resizeParams;
            if (directiveName === 'ngfThumbnail') {
              if (!size) {
                size = {
                  width: elem[0].clientWidth,
                  height: elem[0].clientHeight
                };
              }
              if (size.width === 0 && window.getComputedStyle) {
                var style = getComputedStyle(elem[0]);
                size = {
                  width: parseInt(style.width.slice(0, -2)),
                  height: parseInt(style.height.slice(0, -2))
                };
              }
            }
            if (angular.isString(file)) {
              elem.removeClass('ng-hide');
              if (isBackground) {
                return elem.css('background-image', 'url(\'' + file + '\')');
              } else {
                return elem.attr('src', file);
              }
            }
            if (file && file.type && file.type.search(getTagType(elem[0])) === 0 && (!isBackground || file.type.indexOf('image') === 0)) {
              if (size && Upload.isResizeSupported()) {
                Upload.resize(file, size.width, size.height, size.quality).then(function(f) {
                  constructDataUrl(f);
                }, function(e) {
                  throw e;
                });
              } else {
                constructDataUrl(file);
              }
            } else {
              elem.addClass('ng-hide');
            }
          });
          scope.$on('$destroy', function() {
            unwatch();
          });
        });
      }
      ngFileUpload.directive('ngfSrc', ['Upload', '$timeout', function(Upload, $timeout) {
        return {
          restrict: 'AE',
          link: function(scope, elem, attr) {
            linkFileDirective(Upload, $timeout, scope, elem, attr, 'ngfSrc', Upload.attrGetter('ngfResize', attr, scope), false);
          }
        };
      }]);
      ngFileUpload.directive('ngfBackground', ['Upload', '$timeout', function(Upload, $timeout) {
        return {
          restrict: 'AE',
          link: function(scope, elem, attr) {
            linkFileDirective(Upload, $timeout, scope, elem, attr, 'ngfBackground', Upload.attrGetter('ngfResize', attr, scope), true);
          }
        };
      }]);
      ngFileUpload.directive('ngfThumbnail', ['Upload', '$timeout', function(Upload, $timeout) {
        return {
          restrict: 'AE',
          link: function(scope, elem, attr) {
            var size = Upload.attrGetter('ngfSize', attr, scope);
            linkFileDirective(Upload, $timeout, scope, elem, attr, 'ngfThumbnail', size, Upload.attrGetter('ngfAsBackground', attr, scope));
          }
        };
      }]);
      ngFileUpload.config(['$compileProvider', function($compileProvider) {
        if ($compileProvider.imgSrcSanitizationWhitelist)
          $compileProvider.imgSrcSanitizationWhitelist(/^\s*(https?|ftp|mailto|tel|local|file|data|blob):/);
        if ($compileProvider.aHrefSanitizationWhitelist)
          $compileProvider.aHrefSanitizationWhitelist(/^\s*(https?|ftp|mailto|tel|local|file|data|blob):/);
      }]);
      ngFileUpload.filter('ngfDataUrl', ['UploadDataUrl', '$sce', function(UploadDataUrl, $sce) {
        return function(file, disallowObjectUrl, trustedUrl) {
          if (angular.isString(file)) {
            return $sce.trustAsResourceUrl(file);
          }
          var src = file && ((disallowObjectUrl ? file.$ngfDataUrl : file.$ngfBlobUrl) || file.$ngfDataUrl);
          if (file && !src) {
            if (!file.$ngfDataUrlFilterInProgress && angular.isObject(file)) {
              file.$ngfDataUrlFilterInProgress = true;
              UploadDataUrl.dataUrl(file, disallowObjectUrl);
            }
            return '';
          }
          if (file)
            delete file.$ngfDataUrlFilterInProgress;
          return (file && src ? (trustedUrl ? $sce.trustAsResourceUrl(src) : src) : file) || '';
        };
      }]);
    })();
    ngFileUpload.service('UploadValidate', ['UploadDataUrl', '$q', '$timeout', function(UploadDataUrl, $q, $timeout) {
      var upload = UploadDataUrl;
      function globStringToRegex(str) {
        var regexp = '',
            excludes = [];
        if (str.length > 2 && str[0] === '/' && str[str.length - 1] === '/') {
          regexp = str.substring(1, str.length - 1);
        } else {
          var split = str.split(',');
          if (split.length > 1) {
            for (var i = 0; i < split.length; i++) {
              var r = globStringToRegex(split[i]);
              if (r.regexp) {
                regexp += '(' + r.regexp + ')';
                if (i < split.length - 1) {
                  regexp += '|';
                }
              } else {
                excludes = excludes.concat(r.excludes);
              }
            }
          } else {
            if (str.indexOf('!') === 0) {
              excludes.push('^((?!' + globStringToRegex(str.substring(1)).regexp + ').)*$');
            } else {
              if (str.indexOf('.') === 0) {
                str = '*' + str;
              }
              regexp = '^' + str.replace(new RegExp('[.\\\\+*?\\[\\^\\]$(){}=!<>|:\\-]', 'g'), '\\$&') + '$';
              regexp = regexp.replace(/\\\*/g, '.*').replace(/\\\?/g, '.');
            }
          }
        }
        return {
          regexp: regexp,
          excludes: excludes
        };
      }
      upload.validatePattern = function(file, val) {
        if (!val) {
          return true;
        }
        var pattern = globStringToRegex(val),
            valid = true;
        if (pattern.regexp && pattern.regexp.length) {
          var regexp = new RegExp(pattern.regexp, 'i');
          valid = (file.type != null && regexp.test(file.type)) || (file.name != null && regexp.test(file.name));
        }
        var len = pattern.excludes.length;
        while (len--) {
          var exclude = new RegExp(pattern.excludes[len], 'i');
          valid = valid && (file.type == null || exclude.test(file.type)) && (file.name == null || exclude.test(file.name));
        }
        return valid;
      };
      upload.ratioToFloat = function(val) {
        var r = val.toString(),
            xIndex = r.search(/[x:]/i);
        if (xIndex > -1) {
          r = parseFloat(r.substring(0, xIndex)) / parseFloat(r.substring(xIndex + 1));
        } else {
          r = parseFloat(r);
        }
        return r;
      };
      upload.registerModelChangeValidator = function(ngModel, attr, scope) {
        if (ngModel) {
          ngModel.$formatters.push(function(files) {
            if (ngModel.$dirty) {
              if (files && !angular.isArray(files)) {
                files = [files];
              }
              upload.validate(files, 0, ngModel, attr, scope).then(function() {
                upload.applyModelValidation(ngModel, files);
              });
            }
          });
        }
      };
      function markModelAsDirty(ngModel, files) {
        if (files != null && !ngModel.$dirty) {
          if (ngModel.$setDirty) {
            ngModel.$setDirty();
          } else {
            ngModel.$dirty = true;
          }
        }
      }
      upload.applyModelValidation = function(ngModel, files) {
        markModelAsDirty(ngModel, files);
        angular.forEach(ngModel.$ngfValidations, function(validation) {
          ngModel.$setValidity(validation.name, validation.valid);
        });
      };
      upload.getValidationAttr = function(attr, scope, name, validationName, file) {
        var dName = 'ngf' + name[0].toUpperCase() + name.substr(1);
        var val = upload.attrGetter(dName, attr, scope, {$file: file});
        if (val == null) {
          val = upload.attrGetter('ngfValidate', attr, scope, {$file: file});
          if (val) {
            var split = (validationName || name).split('.');
            val = val[split[0]];
            if (split.length > 1) {
              val = val && val[split[1]];
            }
          }
        }
        return val;
      };
      upload.validate = function(files, prevLength, ngModel, attr, scope) {
        ngModel = ngModel || {};
        ngModel.$ngfValidations = ngModel.$ngfValidations || [];
        angular.forEach(ngModel.$ngfValidations, function(v) {
          v.valid = true;
        });
        var attrGetter = function(name, params) {
          return upload.attrGetter(name, attr, scope, params);
        };
        if (files == null || files.length === 0) {
          return upload.emptyPromise(ngModel);
        }
        files = files.length === undefined ? [files] : files.slice(0);
        function validateSync(name, validationName, fn) {
          if (files) {
            var i = files.length,
                valid = null;
            while (i--) {
              var file = files[i];
              if (file) {
                var val = upload.getValidationAttr(attr, scope, name, validationName, file);
                if (val != null) {
                  if (!fn(file, val, i)) {
                    file.$error = name;
                    (file.$errorMessages = (file.$errorMessages || {}))[name] = true;
                    file.$errorParam = val;
                    files.splice(i, 1);
                    valid = false;
                  }
                }
              }
            }
            if (valid !== null) {
              ngModel.$ngfValidations.push({
                name: name,
                valid: valid
              });
            }
          }
        }
        validateSync('maxFiles', null, function(file, val, i) {
          return prevLength + i < val;
        });
        validateSync('pattern', null, upload.validatePattern);
        validateSync('minSize', 'size.min', function(file, val) {
          return file.size + 0.1 >= upload.translateScalars(val);
        });
        validateSync('maxSize', 'size.max', function(file, val) {
          return file.size - 0.1 <= upload.translateScalars(val);
        });
        var totalSize = 0;
        validateSync('maxTotalSize', null, function(file, val) {
          totalSize += file.size;
          if (totalSize > upload.translateScalars(val)) {
            files.splice(0, files.length);
            return false;
          }
          return true;
        });
        validateSync('validateFn', null, function(file, r) {
          return r === true || r === null || r === '';
        });
        if (!files.length) {
          return upload.emptyPromise(ngModel, ngModel.$ngfValidations);
        }
        function validateAsync(name, validationName, type, asyncFn, fn) {
          function resolveResult(defer, file, val) {
            if (val != null) {
              asyncFn(file, val).then(function(d) {
                if (!fn(d, val)) {
                  file.$error = name;
                  (file.$errorMessages = (file.$errorMessages || {}))[name] = true;
                  file.$errorParam = val;
                  defer.reject();
                } else {
                  defer.resolve();
                }
              }, function() {
                if (attrGetter('ngfValidateForce', {$file: file})) {
                  file.$error = name;
                  (file.$errorMessages = (file.$errorMessages || {}))[name] = true;
                  file.$errorParam = val;
                  defer.reject();
                } else {
                  defer.resolve();
                }
              });
            } else {
              defer.resolve();
            }
          }
          var promises = [upload.emptyPromise()];
          if (files) {
            files = files.length === undefined ? [files] : files;
            angular.forEach(files, function(file) {
              var defer = $q.defer();
              promises.push(defer.promise);
              if (type && (file.type == null || file.type.search(type) !== 0)) {
                defer.resolve();
                return;
              }
              if (name === 'dimensions' && upload.attrGetter('ngfDimensions', attr) != null) {
                upload.imageDimensions(file).then(function(d) {
                  resolveResult(defer, file, attrGetter('ngfDimensions', {
                    $file: file,
                    $width: d.width,
                    $height: d.height
                  }));
                }, function() {
                  defer.reject();
                });
              } else if (name === 'duration' && upload.attrGetter('ngfDuration', attr) != null) {
                upload.mediaDuration(file).then(function(d) {
                  resolveResult(defer, file, attrGetter('ngfDuration', {
                    $file: file,
                    $duration: d
                  }));
                }, function() {
                  defer.reject();
                });
              } else {
                resolveResult(defer, file, upload.getValidationAttr(attr, scope, name, validationName, file));
              }
            });
            return $q.all(promises).then(function() {
              ngModel.$ngfValidations.push({
                name: name,
                valid: true
              });
            }, function() {
              ngModel.$ngfValidations.push({
                name: name,
                valid: false
              });
            });
          }
        }
        var deffer = $q.defer();
        var promises = [];
        promises.push(upload.happyPromise(validateAsync('maxHeight', 'height.max', /image/, this.imageDimensions, function(d, val) {
          return d.height <= val;
        })));
        promises.push(upload.happyPromise(validateAsync('minHeight', 'height.min', /image/, this.imageDimensions, function(d, val) {
          return d.height >= val;
        })));
        promises.push(upload.happyPromise(validateAsync('maxWidth', 'width.max', /image/, this.imageDimensions, function(d, val) {
          return d.width <= val;
        })));
        promises.push(upload.happyPromise(validateAsync('minWidth', 'width.min', /image/, this.imageDimensions, function(d, val) {
          return d.width >= val;
        })));
        promises.push(upload.happyPromise(validateAsync('dimensions', null, /image/, function(file, val) {
          return upload.emptyPromise(val);
        }, function(r) {
          return r;
        })));
        promises.push(upload.happyPromise(validateAsync('ratio', null, /image/, this.imageDimensions, function(d, val) {
          var split = val.toString().split(','),
              valid = false;
          for (var i = 0; i < split.length; i++) {
            if (Math.abs((d.width / d.height) - upload.ratioToFloat(split[i])) < 0.0001) {
              valid = true;
            }
          }
          return valid;
        })));
        promises.push(upload.happyPromise(validateAsync('maxRatio', 'ratio.max', /image/, this.imageDimensions, function(d, val) {
          return (d.width / d.height) - upload.ratioToFloat(val) < 0.0001;
        })));
        promises.push(upload.happyPromise(validateAsync('minRatio', 'ratio.min', /image/, this.imageDimensions, function(d, val) {
          return (d.width / d.height) - upload.ratioToFloat(val) > -0.0001;
        })));
        promises.push(upload.happyPromise(validateAsync('maxDuration', 'duration.max', /audio|video/, this.mediaDuration, function(d, val) {
          return d <= upload.translateScalars(val);
        })));
        promises.push(upload.happyPromise(validateAsync('minDuration', 'duration.min', /audio|video/, this.mediaDuration, function(d, val) {
          return d >= upload.translateScalars(val);
        })));
        promises.push(upload.happyPromise(validateAsync('duration', null, /audio|video/, function(file, val) {
          return upload.emptyPromise(val);
        }, function(r) {
          return r;
        })));
        promises.push(upload.happyPromise(validateAsync('validateAsyncFn', null, null, function(file, val) {
          return val;
        }, function(r) {
          return r === true || r === null || r === '';
        })));
        return $q.all(promises).then(function() {
          deffer.resolve(ngModel, ngModel.$ngfValidations);
        });
      };
      upload.imageDimensions = function(file) {
        if (file.$ngfWidth && file.$ngfHeight) {
          var d = $q.defer();
          $timeout(function() {
            d.resolve({
              width: file.$ngfWidth,
              height: file.$ngfHeight
            });
          });
          return d.promise;
        }
        if (file.$ngfDimensionPromise)
          return file.$ngfDimensionPromise;
        var deferred = $q.defer();
        $timeout(function() {
          if (file.type.indexOf('image') !== 0) {
            deferred.reject('not image');
            return;
          }
          upload.dataUrl(file).then(function(dataUrl) {
            var img = angular.element('<img>').attr('src', dataUrl).css('visibility', 'hidden').css('position', 'fixed').css('max-width', 'none !important').css('max-height', 'none !important');
            function success() {
              var width = img[0].clientWidth;
              var height = img[0].clientHeight;
              img.remove();
              file.$ngfWidth = width;
              file.$ngfHeight = height;
              deferred.resolve({
                width: width,
                height: height
              });
            }
            function error() {
              img.remove();
              deferred.reject('load error');
            }
            img.on('load', success);
            img.on('error', error);
            var count = 0;
            function checkLoadError() {
              $timeout(function() {
                if (img[0].parentNode) {
                  if (img[0].clientWidth) {
                    success();
                  } else if (count > 10) {
                    error();
                  } else {
                    checkLoadError();
                  }
                }
              }, 1000);
            }
            checkLoadError();
            angular.element(document.getElementsByTagName('body')[0]).append(img);
          }, function() {
            deferred.reject('load error');
          });
        });
        file.$ngfDimensionPromise = deferred.promise;
        file.$ngfDimensionPromise['finally'](function() {
          delete file.$ngfDimensionPromise;
        });
        return file.$ngfDimensionPromise;
      };
      upload.mediaDuration = function(file) {
        if (file.$ngfDuration) {
          var d = $q.defer();
          $timeout(function() {
            d.resolve(file.$ngfDuration);
          });
          return d.promise;
        }
        if (file.$ngfDurationPromise)
          return file.$ngfDurationPromise;
        var deferred = $q.defer();
        $timeout(function() {
          if (file.type.indexOf('audio') !== 0 && file.type.indexOf('video') !== 0) {
            deferred.reject('not media');
            return;
          }
          upload.dataUrl(file).then(function(dataUrl) {
            var el = angular.element(file.type.indexOf('audio') === 0 ? '<audio>' : '<video>').attr('src', dataUrl).css('visibility', 'none').css('position', 'fixed');
            function success() {
              var duration = el[0].duration;
              file.$ngfDuration = duration;
              el.remove();
              deferred.resolve(duration);
            }
            function error() {
              el.remove();
              deferred.reject('load error');
            }
            el.on('loadedmetadata', success);
            el.on('error', error);
            var count = 0;
            function checkLoadError() {
              $timeout(function() {
                if (el[0].parentNode) {
                  if (el[0].duration) {
                    success();
                  } else if (count > 10) {
                    error();
                  } else {
                    checkLoadError();
                  }
                }
              }, 1000);
            }
            checkLoadError();
            angular.element(document.body).append(el);
          }, function() {
            deferred.reject('load error');
          });
        });
        file.$ngfDurationPromise = deferred.promise;
        file.$ngfDurationPromise['finally'](function() {
          delete file.$ngfDurationPromise;
        });
        return file.$ngfDurationPromise;
      };
      return upload;
    }]);
    ngFileUpload.service('UploadResize', ['UploadValidate', '$q', function(UploadValidate, $q) {
      var upload = UploadValidate;
      var calculateAspectRatioFit = function(srcWidth, srcHeight, maxWidth, maxHeight, centerCrop) {
        var ratio = centerCrop ? Math.max(maxWidth / srcWidth, maxHeight / srcHeight) : Math.min(maxWidth / srcWidth, maxHeight / srcHeight);
        return {
          width: srcWidth * ratio,
          height: srcHeight * ratio,
          marginX: srcWidth * ratio - maxWidth,
          marginY: srcHeight * ratio - maxHeight
        };
      };
      var resize = function(imagen, width, height, quality, type, ratio, centerCrop, resizeIf) {
        var deferred = $q.defer();
        var canvasElement = document.createElement('canvas');
        var imageElement = document.createElement('img');
        imageElement.onload = function() {
          if (resizeIf != null && resizeIf(imageElement.width, imageElement.height) === false) {
            deferred.reject('resizeIf');
            return;
          }
          try {
            if (ratio) {
              var ratioFloat = upload.ratioToFloat(ratio);
              var imgRatio = imageElement.width / imageElement.height;
              if (imgRatio < ratioFloat) {
                width = imageElement.width;
                height = width / ratioFloat;
              } else {
                height = imageElement.height;
                width = height * ratioFloat;
              }
            }
            if (!width) {
              width = imageElement.width;
            }
            if (!height) {
              height = imageElement.height;
            }
            var dimensions = calculateAspectRatioFit(imageElement.width, imageElement.height, width, height, centerCrop);
            canvasElement.width = Math.min(dimensions.width, width);
            canvasElement.height = Math.min(dimensions.height, height);
            var context = canvasElement.getContext('2d');
            context.drawImage(imageElement, Math.min(0, -dimensions.marginX / 2), Math.min(0, -dimensions.marginY / 2), dimensions.width, dimensions.height);
            deferred.resolve(canvasElement.toDataURL(type || 'image/WebP', quality || 0.934));
          } catch (e) {
            deferred.reject(e);
          }
        };
        imageElement.onerror = function() {
          deferred.reject();
        };
        imageElement.src = imagen;
        return deferred.promise;
      };
      upload.dataUrltoBlob = function(dataurl, name, origSize) {
        var arr = dataurl.split(','),
            mime = arr[0].match(/:(.*?);/)[1],
            bstr = atob(arr[1]),
            n = bstr.length,
            u8arr = new Uint8Array(n);
        while (n--) {
          u8arr[n] = bstr.charCodeAt(n);
        }
        var blob = new window.Blob([u8arr], {type: mime});
        blob.name = name;
        blob.$ngfOrigSize = origSize;
        return blob;
      };
      upload.isResizeSupported = function() {
        var elem = document.createElement('canvas');
        return window.atob && elem.getContext && elem.getContext('2d') && window.Blob;
      };
      if (upload.isResizeSupported()) {
        Object.defineProperty(window.Blob.prototype, 'name', {
          get: function() {
            return this.$ngfName;
          },
          set: function(v) {
            this.$ngfName = v;
          },
          configurable: true
        });
      }
      upload.resize = function(file, width, height, quality, type, ratio, centerCrop, resizeIf, restoreExif) {
        if (file.type.indexOf('image') !== 0)
          return upload.emptyPromise(file);
        var deferred = $q.defer();
        upload.dataUrl(file, true).then(function(url) {
          resize(url, width, height, quality, type || file.type, ratio, centerCrop, resizeIf).then(function(dataUrl) {
            if (file.type === 'image/jpeg' && restoreExif) {
              try {
                dataUrl = upload.restoreExif(url, dataUrl);
              } catch (e) {
                setTimeout(function() {
                  throw e;
                }, 1);
              }
            }
            try {
              var blob = upload.dataUrltoBlob(dataUrl, file.name, file.size);
              deferred.resolve(blob);
            } catch (e) {
              deferred.reject(e);
            }
          }, function(r) {
            if (r === 'resizeIf') {
              deferred.resolve(file);
            }
            deferred.reject(r);
          });
        }, function(e) {
          deferred.reject(e);
        });
        return deferred.promise;
      };
      return upload;
    }]);
    (function() {
      ngFileUpload.directive('ngfDrop', ['$parse', '$timeout', '$location', 'Upload', '$http', '$q', function($parse, $timeout, $location, Upload, $http, $q) {
        return {
          restrict: 'AEC',
          require: '?ngModel',
          link: function(scope, elem, attr, ngModel) {
            linkDrop(scope, elem, attr, ngModel, $parse, $timeout, $location, Upload, $http, $q);
          }
        };
      }]);
      ngFileUpload.directive('ngfNoFileDrop', function() {
        return function(scope, elem) {
          if (dropAvailable())
            elem.css('display', 'none');
        };
      });
      ngFileUpload.directive('ngfDropAvailable', ['$parse', '$timeout', 'Upload', function($parse, $timeout, Upload) {
        return function(scope, elem, attr) {
          if (dropAvailable()) {
            var model = $parse(Upload.attrGetter('ngfDropAvailable', attr));
            $timeout(function() {
              model(scope);
              if (model.assign) {
                model.assign(scope, true);
              }
            });
          }
        };
      }]);
      function linkDrop(scope, elem, attr, ngModel, $parse, $timeout, $location, upload, $http, $q) {
        var available = dropAvailable();
        var attrGetter = function(name, scope, params) {
          return upload.attrGetter(name, attr, scope, params);
        };
        if (attrGetter('dropAvailable')) {
          $timeout(function() {
            if (scope[attrGetter('dropAvailable')]) {
              scope[attrGetter('dropAvailable')].value = available;
            } else {
              scope[attrGetter('dropAvailable')] = available;
            }
          });
        }
        if (!available) {
          if (attrGetter('ngfHideOnDropNotAvailable', scope) === true) {
            elem.css('display', 'none');
          }
          return;
        }
        function isDisabled() {
          return elem.attr('disabled') || attrGetter('ngfDropDisabled', scope);
        }
        if (attrGetter('ngfSelect') == null) {
          upload.registerModelChangeValidator(ngModel, attr, scope);
        }
        var leaveTimeout = null;
        var stopPropagation = $parse(attrGetter('ngfStopPropagation'));
        var dragOverDelay = 1;
        var actualDragOverClass;
        elem[0].addEventListener('dragover', function(evt) {
          if (isDisabled() || !upload.shouldUpdateOn('drop', attr, scope))
            return;
          evt.preventDefault();
          if (stopPropagation(scope))
            evt.stopPropagation();
          if (navigator.userAgent.indexOf('Chrome') > -1) {
            var b = evt.dataTransfer.effectAllowed;
            evt.dataTransfer.dropEffect = ('move' === b || 'linkMove' === b) ? 'move' : 'copy';
          }
          $timeout.cancel(leaveTimeout);
          if (!actualDragOverClass) {
            actualDragOverClass = 'C';
            calculateDragOverClass(scope, attr, evt, function(clazz) {
              actualDragOverClass = clazz;
              elem.addClass(actualDragOverClass);
              attrGetter('ngfDrag', scope, {
                $isDragging: true,
                $class: actualDragOverClass,
                $event: evt
              });
            });
          }
        }, false);
        elem[0].addEventListener('dragenter', function(evt) {
          if (isDisabled() || !upload.shouldUpdateOn('drop', attr, scope))
            return;
          evt.preventDefault();
          if (stopPropagation(scope))
            evt.stopPropagation();
        }, false);
        elem[0].addEventListener('dragleave', function(evt) {
          if (isDisabled() || !upload.shouldUpdateOn('drop', attr, scope))
            return;
          evt.preventDefault();
          if (stopPropagation(scope))
            evt.stopPropagation();
          leaveTimeout = $timeout(function() {
            if (actualDragOverClass)
              elem.removeClass(actualDragOverClass);
            actualDragOverClass = null;
            attrGetter('ngfDrag', scope, {
              $isDragging: false,
              $event: evt
            });
          }, dragOverDelay || 100);
        }, false);
        elem[0].addEventListener('drop', function(evt) {
          if (isDisabled() || !upload.shouldUpdateOn('drop', attr, scope))
            return;
          evt.preventDefault();
          if (stopPropagation(scope))
            evt.stopPropagation();
          if (actualDragOverClass)
            elem.removeClass(actualDragOverClass);
          actualDragOverClass = null;
          var items = evt.dataTransfer.items;
          var html;
          try {
            html = evt.dataTransfer && evt.dataTransfer.getData && evt.dataTransfer.getData('text/html');
          } catch (e) {}
          extractFiles(items, evt.dataTransfer.files, attrGetter('ngfAllowDir', scope) !== false, attrGetter('multiple') || attrGetter('ngfMultiple', scope)).then(function(files) {
            if (files.length) {
              updateModel(files, evt);
            } else {
              extractFilesFromHtml('dropUrl', html).then(function(files) {
                updateModel(files, evt);
              });
            }
          });
        }, false);
        elem[0].addEventListener('paste', function(evt) {
          if (navigator.userAgent.toLowerCase().indexOf('firefox') > -1 && attrGetter('ngfEnableFirefoxPaste', scope)) {
            evt.preventDefault();
          }
          if (isDisabled() || !upload.shouldUpdateOn('paste', attr, scope))
            return;
          var files = [];
          var clipboard = evt.clipboardData || evt.originalEvent.clipboardData;
          if (clipboard && clipboard.items) {
            for (var k = 0; k < clipboard.items.length; k++) {
              if (clipboard.items[k].type.indexOf('image') !== -1) {
                files.push(clipboard.items[k].getAsFile());
              }
            }
          }
          if (files.length) {
            updateModel(files, evt);
          } else {
            extractFilesFromHtml('pasteUrl', clipboard).then(function(files) {
              updateModel(files, evt);
            });
          }
        }, false);
        if (navigator.userAgent.toLowerCase().indexOf('firefox') > -1 && attrGetter('ngfEnableFirefoxPaste', scope)) {
          elem.attr('contenteditable', true);
          elem.on('keypress', function(e) {
            if (!e.metaKey && !e.ctrlKey) {
              e.preventDefault();
            }
          });
        }
        function updateModel(files, evt) {
          upload.updateModel(ngModel, attr, scope, attrGetter('ngfChange') || attrGetter('ngfDrop'), files, evt);
        }
        function extractFilesFromHtml(updateOn, html) {
          if (!upload.shouldUpdateOn(updateOn, attr, scope) || !html)
            return upload.rejectPromise([]);
          var urls = [];
          html.replace(/<(img src|img [^>]* src) *=\"([^\"]*)\"/gi, function(m, n, src) {
            urls.push(src);
          });
          var promises = [],
              files = [];
          if (urls.length) {
            angular.forEach(urls, function(url) {
              promises.push(upload.urlToBlob(url).then(function(blob) {
                files.push(blob);
              }));
            });
            var defer = $q.defer();
            $q.all(promises).then(function() {
              defer.resolve(files);
            }, function(e) {
              defer.reject(e);
            });
            return defer.promise;
          }
          return upload.emptyPromise();
        }
        function calculateDragOverClass(scope, attr, evt, callback) {
          var obj = attrGetter('ngfDragOverClass', scope, {$event: evt}),
              dClass = 'dragover';
          if (angular.isString(obj)) {
            dClass = obj;
          } else if (obj) {
            if (obj.delay)
              dragOverDelay = obj.delay;
            if (obj.accept || obj.reject) {
              var items = evt.dataTransfer.items;
              if (items == null || !items.length) {
                dClass = obj.accept;
              } else {
                var pattern = obj.pattern || attrGetter('ngfPattern', scope, {$event: evt});
                var len = items.length;
                while (len--) {
                  if (!upload.validatePattern(items[len], pattern)) {
                    dClass = obj.reject;
                    break;
                  } else {
                    dClass = obj.accept;
                  }
                }
              }
            }
          }
          callback(dClass);
        }
        function extractFiles(items, fileList, allowDir, multiple) {
          var maxFiles = upload.getValidationAttr(attr, scope, 'maxFiles') || Number.MAX_VALUE;
          var maxTotalSize = upload.getValidationAttr(attr, scope, 'maxTotalSize') || Number.MAX_VALUE;
          var includeDir = attrGetter('ngfIncludeDir', scope);
          var files = [],
              totalSize = 0;
          function traverseFileTree(entry, path) {
            var defer = $q.defer();
            if (entry != null) {
              if (entry.isDirectory) {
                var promises = [upload.emptyPromise()];
                if (includeDir) {
                  var file = {type: 'directory'};
                  file.name = file.path = (path || '') + entry.name + entry.name;
                  files.push(file);
                }
                var dirReader = entry.createReader();
                var entries = [];
                var readEntries = function() {
                  dirReader.readEntries(function(results) {
                    try {
                      if (!results.length) {
                        angular.forEach(entries.slice(0), function(e) {
                          if (files.length <= maxFiles && totalSize <= maxTotalSize) {
                            promises.push(traverseFileTree(e, (path ? path : '') + entry.name + '/'));
                          }
                        });
                        $q.all(promises).then(function() {
                          defer.resolve();
                        }, function(e) {
                          defer.reject(e);
                        });
                      } else {
                        entries = entries.concat(Array.prototype.slice.call(results || [], 0));
                        readEntries();
                      }
                    } catch (e) {
                      defer.reject(e);
                    }
                  }, function(e) {
                    defer.reject(e);
                  });
                };
                readEntries();
              } else {
                entry.file(function(file) {
                  try {
                    file.path = (path ? path : '') + file.name;
                    if (includeDir) {
                      file = upload.rename(file, file.path);
                    }
                    files.push(file);
                    totalSize += file.size;
                    defer.resolve();
                  } catch (e) {
                    defer.reject(e);
                  }
                }, function(e) {
                  defer.reject(e);
                });
              }
            }
            return defer.promise;
          }
          var promises = [upload.emptyPromise()];
          if (items && items.length > 0 && $location.protocol() !== 'file') {
            for (var i = 0; i < items.length; i++) {
              if (items[i].webkitGetAsEntry && items[i].webkitGetAsEntry() && items[i].webkitGetAsEntry().isDirectory) {
                var entry = items[i].webkitGetAsEntry();
                if (entry.isDirectory && !allowDir) {
                  continue;
                }
                if (entry != null) {
                  promises.push(traverseFileTree(entry));
                }
              } else {
                var f = items[i].getAsFile();
                if (f != null) {
                  files.push(f);
                  totalSize += f.size;
                }
              }
              if (files.length > maxFiles || totalSize > maxTotalSize || (!multiple && files.length > 0))
                break;
            }
          } else {
            if (fileList != null) {
              for (var j = 0; j < fileList.length; j++) {
                var file = fileList.item(j);
                if (file.type || file.size > 0) {
                  files.push(file);
                  totalSize += file.size;
                }
                if (files.length > maxFiles || totalSize > maxTotalSize || (!multiple && files.length > 0))
                  break;
              }
            }
          }
          var defer = $q.defer();
          $q.all(promises).then(function() {
            if (!multiple && !includeDir && files.length) {
              var i = 0;
              while (files[i] && files[i].type === 'directory')
                i++;
              defer.resolve([files[i]]);
            } else {
              defer.resolve(files);
            }
          }, function(e) {
            defer.reject(e);
          });
          return defer.promise;
        }
      }
      function dropAvailable() {
        var div = document.createElement('div');
        return ('draggable' in div) && ('ondrop' in div) && !/Edge\/12./i.test(navigator.userAgent);
      }
    })();
    ngFileUpload.service('UploadExif', ['UploadResize', '$q', function(UploadResize, $q) {
      var upload = UploadResize;
      upload.isExifSupported = function() {
        return window.FileReader && new FileReader().readAsArrayBuffer && upload.isResizeSupported();
      };
      function applyTransform(ctx, orientation, width, height) {
        switch (orientation) {
          case 2:
            return ctx.transform(-1, 0, 0, 1, width, 0);
          case 3:
            return ctx.transform(-1, 0, 0, -1, width, height);
          case 4:
            return ctx.transform(1, 0, 0, -1, 0, height);
          case 5:
            return ctx.transform(0, 1, 1, 0, 0, 0);
          case 6:
            return ctx.transform(0, 1, -1, 0, height, 0);
          case 7:
            return ctx.transform(0, -1, -1, 0, height, width);
          case 8:
            return ctx.transform(0, -1, 1, 0, 0, width);
        }
      }
      upload.readOrientation = function(file) {
        var defer = $q.defer();
        var reader = new FileReader();
        var slicedFile = file.slice ? file.slice(0, 64 * 1024) : file;
        reader.readAsArrayBuffer(slicedFile);
        reader.onerror = function(e) {
          return defer.reject(e);
        };
        reader.onload = function(e) {
          var result = {orientation: 1};
          var view = new DataView(this.result);
          if (view.getUint16(0, false) !== 0xFFD8)
            return defer.resolve(result);
          var length = view.byteLength,
              offset = 2;
          while (offset < length) {
            var marker = view.getUint16(offset, false);
            offset += 2;
            if (marker === 0xFFE1) {
              if (view.getUint32(offset += 2, false) !== 0x45786966)
                return defer.resolve(result);
              var little = view.getUint16(offset += 6, false) === 0x4949;
              offset += view.getUint32(offset + 4, little);
              var tags = view.getUint16(offset, little);
              offset += 2;
              for (var i = 0; i < tags; i++)
                if (view.getUint16(offset + (i * 12), little) === 0x0112) {
                  var orientation = view.getUint16(offset + (i * 12) + 8, little);
                  if (orientation >= 2 && orientation <= 8) {
                    view.setUint16(offset + (i * 12) + 8, 1, little);
                    result.fixedArrayBuffer = e.target.result;
                  }
                  result.orientation = orientation;
                  return defer.resolve(result);
                }
            } else if ((marker & 0xFF00) !== 0xFF00)
              break;
            else
              offset += view.getUint16(offset, false);
          }
          return defer.resolve(result);
        };
        return defer.promise;
      };
      function arrayBufferToBase64(buffer) {
        var binary = '';
        var bytes = new Uint8Array(buffer);
        var len = bytes.byteLength;
        for (var i = 0; i < len; i++) {
          binary += String.fromCharCode(bytes[i]);
        }
        return window.btoa(binary);
      }
      upload.applyExifRotation = function(file) {
        if (file.type.indexOf('image/jpeg') !== 0) {
          return upload.emptyPromise(file);
        }
        var deferred = $q.defer();
        upload.readOrientation(file).then(function(result) {
          if (result.orientation < 2 || result.orientation > 8) {
            return deferred.resolve(file);
          }
          upload.dataUrl(file, true).then(function(url) {
            var canvas = document.createElement('canvas');
            var img = document.createElement('img');
            img.onload = function() {
              try {
                canvas.width = result.orientation > 4 ? img.height : img.width;
                canvas.height = result.orientation > 4 ? img.width : img.height;
                var ctx = canvas.getContext('2d');
                applyTransform(ctx, result.orientation, img.width, img.height);
                ctx.drawImage(img, 0, 0);
                var dataUrl = canvas.toDataURL(file.type || 'image/WebP', 0.934);
                dataUrl = upload.restoreExif(arrayBufferToBase64(result.fixedArrayBuffer), dataUrl);
                var blob = upload.dataUrltoBlob(dataUrl, file.name);
                deferred.resolve(blob);
              } catch (e) {
                return deferred.reject(e);
              }
            };
            img.onerror = function() {
              deferred.reject();
            };
            img.src = url;
          }, function(e) {
            deferred.reject(e);
          });
        }, function(e) {
          deferred.reject(e);
        });
        return deferred.promise;
      };
      upload.restoreExif = function(orig, resized) {
        var ExifRestorer = {};
        ExifRestorer.KEY_STR = 'ABCDEFGHIJKLMNOP' + 'QRSTUVWXYZabcdef' + 'ghijklmnopqrstuv' + 'wxyz0123456789+/' + '=';
        ExifRestorer.encode64 = function(input) {
          var output = '',
              chr1,
              chr2,
              chr3 = '',
              enc1,
              enc2,
              enc3,
              enc4 = '',
              i = 0;
          do {
            chr1 = input[i++];
            chr2 = input[i++];
            chr3 = input[i++];
            enc1 = chr1 >> 2;
            enc2 = ((chr1 & 3) << 4) | (chr2 >> 4);
            enc3 = ((chr2 & 15) << 2) | (chr3 >> 6);
            enc4 = chr3 & 63;
            if (isNaN(chr2)) {
              enc3 = enc4 = 64;
            } else if (isNaN(chr3)) {
              enc4 = 64;
            }
            output = output + this.KEY_STR.charAt(enc1) + this.KEY_STR.charAt(enc2) + this.KEY_STR.charAt(enc3) + this.KEY_STR.charAt(enc4);
            chr1 = chr2 = chr3 = '';
            enc1 = enc2 = enc3 = enc4 = '';
          } while (i < input.length);
          return output;
        };
        ExifRestorer.restore = function(origFileBase64, resizedFileBase64) {
          if (origFileBase64.match('data:image/jpeg;base64,')) {
            origFileBase64 = origFileBase64.replace('data:image/jpeg;base64,', '');
          }
          var rawImage = this.decode64(origFileBase64);
          var segments = this.slice2Segments(rawImage);
          var image = this.exifManipulation(resizedFileBase64, segments);
          return 'data:image/jpeg;base64,' + this.encode64(image);
        };
        ExifRestorer.exifManipulation = function(resizedFileBase64, segments) {
          var exifArray = this.getExifArray(segments),
              newImageArray = this.insertExif(resizedFileBase64, exifArray);
          return new Uint8Array(newImageArray);
        };
        ExifRestorer.getExifArray = function(segments) {
          var seg;
          for (var x = 0; x < segments.length; x++) {
            seg = segments[x];
            if (seg[0] === 255 & seg[1] === 225) {
              return seg;
            }
          }
          return [];
        };
        ExifRestorer.insertExif = function(resizedFileBase64, exifArray) {
          var imageData = resizedFileBase64.replace('data:image/jpeg;base64,', ''),
              buf = this.decode64(imageData),
              separatePoint = buf.indexOf(255, 3),
              mae = buf.slice(0, separatePoint),
              ato = buf.slice(separatePoint),
              array = mae;
          array = array.concat(exifArray);
          array = array.concat(ato);
          return array;
        };
        ExifRestorer.slice2Segments = function(rawImageArray) {
          var head = 0,
              segments = [];
          while (1) {
            if (rawImageArray[head] === 255 & rawImageArray[head + 1] === 218) {
              break;
            }
            if (rawImageArray[head] === 255 & rawImageArray[head + 1] === 216) {
              head += 2;
            } else {
              var length = rawImageArray[head + 2] * 256 + rawImageArray[head + 3],
                  endPoint = head + length + 2,
                  seg = rawImageArray.slice(head, endPoint);
              segments.push(seg);
              head = endPoint;
            }
            if (head > rawImageArray.length) {
              break;
            }
          }
          return segments;
        };
        ExifRestorer.decode64 = function(input) {
          var chr1,
              chr2,
              chr3 = '',
              enc1,
              enc2,
              enc3,
              enc4 = '',
              i = 0,
              buf = [];
          var base64test = /[^A-Za-z0-9\+\/\=]/g;
          if (base64test.exec(input)) {
            console.log('There were invalid base64 characters in the input text.\n' + 'Valid base64 characters are A-Z, a-z, 0-9, ' + ', ' / ',and "="\n' + 'Expect errors in decoding.');
          }
          input = input.replace(/[^A-Za-z0-9\+\/\=]/g, '');
          do {
            enc1 = this.KEY_STR.indexOf(input.charAt(i++));
            enc2 = this.KEY_STR.indexOf(input.charAt(i++));
            enc3 = this.KEY_STR.indexOf(input.charAt(i++));
            enc4 = this.KEY_STR.indexOf(input.charAt(i++));
            chr1 = (enc1 << 2) | (enc2 >> 4);
            chr2 = ((enc2 & 15) << 4) | (enc3 >> 2);
            chr3 = ((enc3 & 3) << 6) | enc4;
            buf.push(chr1);
            if (enc3 !== 64) {
              buf.push(chr2);
            }
            if (enc4 !== 64) {
              buf.push(chr3);
            }
            chr1 = chr2 = chr3 = '';
            enc1 = enc2 = enc3 = enc4 = '';
          } while (i < input.length);
          return buf;
        };
        return ExifRestorer.restore(orig, resized);
      };
      return upload;
    }]);
    this["ngFileUpload"] = ngFileUpload;
  })();
  return _retrieveGlobal();
});

System.registerDynamic("bower:ng-file-upload@12.0.4.js", ["bower:ng-file-upload@12.0.4/ng-file-upload.js"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = $__require('bower:ng-file-upload@12.0.4/ng-file-upload.js');
  global.define = __define;
  return module.exports;
});

System.registerDynamic("github:Modernizr/Modernizr@2.8.3/modernizr.js", [], false, function(__require, __exports, __module) {
  var _retrieveGlobal = System.get("@@global-helpers").prepareGlobal(__module.id, "Modernizr", null);
  (function() {
    "format global";
    "exports Modernizr";
    window.Modernizr = (function(window, document, undefined) {
      var version = '2.8.3',
          Modernizr = {},
          enableClasses = true,
          docElement = document.documentElement,
          mod = 'modernizr',
          modElem = document.createElement(mod),
          mStyle = modElem.style,
          inputElem = document.createElement('input'),
          smile = ':)',
          toString = {}.toString,
          prefixes = ' -webkit- -moz- -o- -ms- '.split(' '),
          omPrefixes = 'Webkit Moz O ms',
          cssomPrefixes = omPrefixes.split(' '),
          domPrefixes = omPrefixes.toLowerCase().split(' '),
          ns = {'svg': 'http://www.w3.org/2000/svg'},
          tests = {},
          inputs = {},
          attrs = {},
          classes = [],
          slice = classes.slice,
          featureName,
          injectElementWithStyles = function(rule, callback, nodes, testnames) {
            var style,
                ret,
                node,
                docOverflow,
                div = document.createElement('div'),
                body = document.body,
                fakeBody = body || document.createElement('body');
            if (parseInt(nodes, 10)) {
              while (nodes--) {
                node = document.createElement('div');
                node.id = testnames ? testnames[nodes] : mod + (nodes + 1);
                div.appendChild(node);
              }
            }
            style = ['&#173;', '<style id="s', mod, '">', rule, '</style>'].join('');
            div.id = mod;
            (body ? div : fakeBody).innerHTML += style;
            fakeBody.appendChild(div);
            if (!body) {
              fakeBody.style.background = '';
              fakeBody.style.overflow = 'hidden';
              docOverflow = docElement.style.overflow;
              docElement.style.overflow = 'hidden';
              docElement.appendChild(fakeBody);
            }
            ret = callback(div, rule);
            if (!body) {
              fakeBody.parentNode.removeChild(fakeBody);
              docElement.style.overflow = docOverflow;
            } else {
              div.parentNode.removeChild(div);
            }
            return !!ret;
          },
          testMediaQuery = function(mq) {
            var matchMedia = window.matchMedia || window.msMatchMedia;
            if (matchMedia) {
              return matchMedia(mq) && matchMedia(mq).matches || false;
            }
            var bool;
            injectElementWithStyles('@media ' + mq + ' { #' + mod + ' { position: absolute; } }', function(node) {
              bool = (window.getComputedStyle ? getComputedStyle(node, null) : node.currentStyle)['position'] == 'absolute';
            });
            return bool;
          },
          isEventSupported = (function() {
            var TAGNAMES = {
              'select': 'input',
              'change': 'input',
              'submit': 'form',
              'reset': 'form',
              'error': 'img',
              'load': 'img',
              'abort': 'img'
            };
            function isEventSupported(eventName, element) {
              element = element || document.createElement(TAGNAMES[eventName] || 'div');
              eventName = 'on' + eventName;
              var isSupported = eventName in element;
              if (!isSupported) {
                if (!element.setAttribute) {
                  element = document.createElement('div');
                }
                if (element.setAttribute && element.removeAttribute) {
                  element.setAttribute(eventName, '');
                  isSupported = is(element[eventName], 'function');
                  if (!is(element[eventName], 'undefined')) {
                    element[eventName] = undefined;
                  }
                  element.removeAttribute(eventName);
                }
              }
              element = null;
              return isSupported;
            }
            return isEventSupported;
          })(),
          _hasOwnProperty = ({}).hasOwnProperty,
          hasOwnProp;
      if (!is(_hasOwnProperty, 'undefined') && !is(_hasOwnProperty.call, 'undefined')) {
        hasOwnProp = function(object, property) {
          return _hasOwnProperty.call(object, property);
        };
      } else {
        hasOwnProp = function(object, property) {
          return ((property in object) && is(object.constructor.prototype[property], 'undefined'));
        };
      }
      if (!Function.prototype.bind) {
        Function.prototype.bind = function bind(that) {
          var target = this;
          if (typeof target != "function") {
            throw new TypeError();
          }
          var args = slice.call(arguments, 1),
              bound = function() {
                if (this instanceof bound) {
                  var F = function() {};
                  F.prototype = target.prototype;
                  var self = new F();
                  var result = target.apply(self, args.concat(slice.call(arguments)));
                  if (Object(result) === result) {
                    return result;
                  }
                  return self;
                } else {
                  return target.apply(that, args.concat(slice.call(arguments)));
                }
              };
          return bound;
        };
      }
      function setCss(str) {
        mStyle.cssText = str;
      }
      function setCssAll(str1, str2) {
        return setCss(prefixes.join(str1 + ';') + (str2 || ''));
      }
      function is(obj, type) {
        return typeof obj === type;
      }
      function contains(str, substr) {
        return !!~('' + str).indexOf(substr);
      }
      function testProps(props, prefixed) {
        for (var i in props) {
          var prop = props[i];
          if (!contains(prop, "-") && mStyle[prop] !== undefined) {
            return prefixed == 'pfx' ? prop : true;
          }
        }
        return false;
      }
      function testDOMProps(props, obj, elem) {
        for (var i in props) {
          var item = obj[props[i]];
          if (item !== undefined) {
            if (elem === false)
              return props[i];
            if (is(item, 'function')) {
              return item.bind(elem || obj);
            }
            return item;
          }
        }
        return false;
      }
      function testPropsAll(prop, prefixed, elem) {
        var ucProp = prop.charAt(0).toUpperCase() + prop.slice(1),
            props = (prop + ' ' + cssomPrefixes.join(ucProp + ' ') + ucProp).split(' ');
        if (is(prefixed, "string") || is(prefixed, "undefined")) {
          return testProps(props, prefixed);
        } else {
          props = (prop + ' ' + (domPrefixes).join(ucProp + ' ') + ucProp).split(' ');
          return testDOMProps(props, prefixed, elem);
        }
      }
      tests['flexbox'] = function() {
        return testPropsAll('flexWrap');
      };
      tests['flexboxlegacy'] = function() {
        return testPropsAll('boxDirection');
      };
      tests['canvas'] = function() {
        var elem = document.createElement('canvas');
        return !!(elem.getContext && elem.getContext('2d'));
      };
      tests['canvastext'] = function() {
        return !!(Modernizr['canvas'] && is(document.createElement('canvas').getContext('2d').fillText, 'function'));
      };
      tests['webgl'] = function() {
        return !!window.WebGLRenderingContext;
      };
      tests['touch'] = function() {
        var bool;
        if (('ontouchstart' in window) || window.DocumentTouch && document instanceof DocumentTouch) {
          bool = true;
        } else {
          injectElementWithStyles(['@media (', prefixes.join('touch-enabled),('), mod, ')', '{#modernizr{top:9px;position:absolute}}'].join(''), function(node) {
            bool = node.offsetTop === 9;
          });
        }
        return bool;
      };
      tests['geolocation'] = function() {
        return 'geolocation' in navigator;
      };
      tests['postmessage'] = function() {
        return !!window.postMessage;
      };
      tests['websqldatabase'] = function() {
        return !!window.openDatabase;
      };
      tests['indexedDB'] = function() {
        return !!testPropsAll("indexedDB", window);
      };
      tests['hashchange'] = function() {
        return isEventSupported('hashchange', window) && (document.documentMode === undefined || document.documentMode > 7);
      };
      tests['history'] = function() {
        return !!(window.history && history.pushState);
      };
      tests['draganddrop'] = function() {
        var div = document.createElement('div');
        return ('draggable' in div) || ('ondragstart' in div && 'ondrop' in div);
      };
      tests['websockets'] = function() {
        return 'WebSocket' in window || 'MozWebSocket' in window;
      };
      tests['rgba'] = function() {
        setCss('background-color:rgba(150,255,150,.5)');
        return contains(mStyle.backgroundColor, 'rgba');
      };
      tests['hsla'] = function() {
        setCss('background-color:hsla(120,40%,100%,.5)');
        return contains(mStyle.backgroundColor, 'rgba') || contains(mStyle.backgroundColor, 'hsla');
      };
      tests['multiplebgs'] = function() {
        setCss('background:url(https://),url(https://),red url(https://)');
        return (/(url\s*\(.*?){3}/).test(mStyle.background);
      };
      tests['backgroundsize'] = function() {
        return testPropsAll('backgroundSize');
      };
      tests['borderimage'] = function() {
        return testPropsAll('borderImage');
      };
      tests['borderradius'] = function() {
        return testPropsAll('borderRadius');
      };
      tests['boxshadow'] = function() {
        return testPropsAll('boxShadow');
      };
      tests['textshadow'] = function() {
        return document.createElement('div').style.textShadow === '';
      };
      tests['opacity'] = function() {
        setCssAll('opacity:.55');
        return (/^0.55$/).test(mStyle.opacity);
      };
      tests['cssanimations'] = function() {
        return testPropsAll('animationName');
      };
      tests['csscolumns'] = function() {
        return testPropsAll('columnCount');
      };
      tests['cssgradients'] = function() {
        var str1 = 'background-image:',
            str2 = 'gradient(linear,left top,right bottom,from(#9f9),to(white));',
            str3 = 'linear-gradient(left top,#9f9, white);';
        setCss((str1 + '-webkit- '.split(' ').join(str2 + str1) + prefixes.join(str3 + str1)).slice(0, -str1.length));
        return contains(mStyle.backgroundImage, 'gradient');
      };
      tests['cssreflections'] = function() {
        return testPropsAll('boxReflect');
      };
      tests['csstransforms'] = function() {
        return !!testPropsAll('transform');
      };
      tests['csstransforms3d'] = function() {
        var ret = !!testPropsAll('perspective');
        if (ret && 'webkitPerspective' in docElement.style) {
          injectElementWithStyles('@media (transform-3d),(-webkit-transform-3d){#modernizr{left:9px;position:absolute;height:3px;}}', function(node, rule) {
            ret = node.offsetLeft === 9 && node.offsetHeight === 3;
          });
        }
        return ret;
      };
      tests['csstransitions'] = function() {
        return testPropsAll('transition');
      };
      tests['fontface'] = function() {
        var bool;
        injectElementWithStyles('@font-face {font-family:"font";src:url("https://")}', function(node, rule) {
          var style = document.getElementById('smodernizr'),
              sheet = style.sheet || style.styleSheet,
              cssText = sheet ? (sheet.cssRules && sheet.cssRules[0] ? sheet.cssRules[0].cssText : sheet.cssText || '') : '';
          bool = /src/i.test(cssText) && cssText.indexOf(rule.split(' ')[0]) === 0;
        });
        return bool;
      };
      tests['generatedcontent'] = function() {
        var bool;
        injectElementWithStyles(['#', mod, '{font:0/0 a}#', mod, ':after{content:"', smile, '";visibility:hidden;font:3px/1 a}'].join(''), function(node) {
          bool = node.offsetHeight >= 3;
        });
        return bool;
      };
      tests['video'] = function() {
        var elem = document.createElement('video'),
            bool = false;
        try {
          if (bool = !!elem.canPlayType) {
            bool = new Boolean(bool);
            bool.ogg = elem.canPlayType('video/ogg; codecs="theora"').replace(/^no$/, '');
            bool.h264 = elem.canPlayType('video/mp4; codecs="avc1.42E01E"').replace(/^no$/, '');
            bool.webm = elem.canPlayType('video/webm; codecs="vp8, vorbis"').replace(/^no$/, '');
          }
        } catch (e) {}
        return bool;
      };
      tests['audio'] = function() {
        var elem = document.createElement('audio'),
            bool = false;
        try {
          if (bool = !!elem.canPlayType) {
            bool = new Boolean(bool);
            bool.ogg = elem.canPlayType('audio/ogg; codecs="vorbis"').replace(/^no$/, '');
            bool.mp3 = elem.canPlayType('audio/mpeg;').replace(/^no$/, '');
            bool.wav = elem.canPlayType('audio/wav; codecs="1"').replace(/^no$/, '');
            bool.m4a = (elem.canPlayType('audio/x-m4a;') || elem.canPlayType('audio/aac;')).replace(/^no$/, '');
          }
        } catch (e) {}
        return bool;
      };
      tests['localstorage'] = function() {
        try {
          localStorage.setItem(mod, mod);
          localStorage.removeItem(mod);
          return true;
        } catch (e) {
          return false;
        }
      };
      tests['sessionstorage'] = function() {
        try {
          sessionStorage.setItem(mod, mod);
          sessionStorage.removeItem(mod);
          return true;
        } catch (e) {
          return false;
        }
      };
      tests['webworkers'] = function() {
        return !!window.Worker;
      };
      tests['applicationcache'] = function() {
        return !!window.applicationCache;
      };
      tests['svg'] = function() {
        return !!document.createElementNS && !!document.createElementNS(ns.svg, 'svg').createSVGRect;
      };
      tests['inlinesvg'] = function() {
        var div = document.createElement('div');
        div.innerHTML = '<svg/>';
        return (div.firstChild && div.firstChild.namespaceURI) == ns.svg;
      };
      tests['smil'] = function() {
        return !!document.createElementNS && /SVGAnimate/.test(toString.call(document.createElementNS(ns.svg, 'animate')));
      };
      tests['svgclippaths'] = function() {
        return !!document.createElementNS && /SVGClipPath/.test(toString.call(document.createElementNS(ns.svg, 'clipPath')));
      };
      function webforms() {
        Modernizr['input'] = (function(props) {
          for (var i = 0,
              len = props.length; i < len; i++) {
            attrs[props[i]] = !!(props[i] in inputElem);
          }
          if (attrs.list) {
            attrs.list = !!(document.createElement('datalist') && window.HTMLDataListElement);
          }
          return attrs;
        })('autocomplete autofocus list placeholder max min multiple pattern required step'.split(' '));
        Modernizr['inputtypes'] = (function(props) {
          for (var i = 0,
              bool,
              inputElemType,
              defaultView,
              len = props.length; i < len; i++) {
            inputElem.setAttribute('type', inputElemType = props[i]);
            bool = inputElem.type !== 'text';
            if (bool) {
              inputElem.value = smile;
              inputElem.style.cssText = 'position:absolute;visibility:hidden;';
              if (/^range$/.test(inputElemType) && inputElem.style.WebkitAppearance !== undefined) {
                docElement.appendChild(inputElem);
                defaultView = document.defaultView;
                bool = defaultView.getComputedStyle && defaultView.getComputedStyle(inputElem, null).WebkitAppearance !== 'textfield' && (inputElem.offsetHeight !== 0);
                docElement.removeChild(inputElem);
              } else if (/^(search|tel)$/.test(inputElemType)) {} else if (/^(url|email)$/.test(inputElemType)) {
                bool = inputElem.checkValidity && inputElem.checkValidity() === false;
              } else {
                bool = inputElem.value != smile;
              }
            }
            inputs[props[i]] = !!bool;
          }
          return inputs;
        })('search tel url email datetime date month week time datetime-local number range color'.split(' '));
      }
      for (var feature in tests) {
        if (hasOwnProp(tests, feature)) {
          featureName = feature.toLowerCase();
          Modernizr[featureName] = tests[feature]();
          classes.push((Modernizr[featureName] ? '' : 'no-') + featureName);
        }
      }
      Modernizr.input || webforms();
      Modernizr.addTest = function(feature, test) {
        if (typeof feature == 'object') {
          for (var key in feature) {
            if (hasOwnProp(feature, key)) {
              Modernizr.addTest(key, feature[key]);
            }
          }
        } else {
          feature = feature.toLowerCase();
          if (Modernizr[feature] !== undefined) {
            return Modernizr;
          }
          test = typeof test == 'function' ? test() : test;
          if (typeof enableClasses !== "undefined" && enableClasses) {
            docElement.className += ' ' + (test ? '' : 'no-') + feature;
          }
          Modernizr[feature] = test;
        }
        return Modernizr;
      };
      setCss('');
      modElem = inputElem = null;
      ;
      (function(window, document) {
        var version = '3.7.0';
        var options = window.html5 || {};
        var reSkip = /^<|^(?:button|map|select|textarea|object|iframe|option|optgroup)$/i;
        var saveClones = /^(?:a|b|code|div|fieldset|h1|h2|h3|h4|h5|h6|i|label|li|ol|p|q|span|strong|style|table|tbody|td|th|tr|ul)$/i;
        var supportsHtml5Styles;
        var expando = '_html5shiv';
        var expanID = 0;
        var expandoData = {};
        var supportsUnknownElements;
        (function() {
          try {
            var a = document.createElement('a');
            a.innerHTML = '<xyz></xyz>';
            supportsHtml5Styles = ('hidden' in a);
            supportsUnknownElements = a.childNodes.length == 1 || (function() {
              (document.createElement)('a');
              var frag = document.createDocumentFragment();
              return (typeof frag.cloneNode == 'undefined' || typeof frag.createDocumentFragment == 'undefined' || typeof frag.createElement == 'undefined');
            }());
          } catch (e) {
            supportsHtml5Styles = true;
            supportsUnknownElements = true;
          }
        }());
        function addStyleSheet(ownerDocument, cssText) {
          var p = ownerDocument.createElement('p'),
              parent = ownerDocument.getElementsByTagName('head')[0] || ownerDocument.documentElement;
          p.innerHTML = 'x<style>' + cssText + '</style>';
          return parent.insertBefore(p.lastChild, parent.firstChild);
        }
        function getElements() {
          var elements = html5.elements;
          return typeof elements == 'string' ? elements.split(' ') : elements;
        }
        function getExpandoData(ownerDocument) {
          var data = expandoData[ownerDocument[expando]];
          if (!data) {
            data = {};
            expanID++;
            ownerDocument[expando] = expanID;
            expandoData[expanID] = data;
          }
          return data;
        }
        function createElement(nodeName, ownerDocument, data) {
          if (!ownerDocument) {
            ownerDocument = document;
          }
          if (supportsUnknownElements) {
            return ownerDocument.createElement(nodeName);
          }
          if (!data) {
            data = getExpandoData(ownerDocument);
          }
          var node;
          if (data.cache[nodeName]) {
            node = data.cache[nodeName].cloneNode();
          } else if (saveClones.test(nodeName)) {
            node = (data.cache[nodeName] = data.createElem(nodeName)).cloneNode();
          } else {
            node = data.createElem(nodeName);
          }
          return node.canHaveChildren && !reSkip.test(nodeName) && !node.tagUrn ? data.frag.appendChild(node) : node;
        }
        function createDocumentFragment(ownerDocument, data) {
          if (!ownerDocument) {
            ownerDocument = document;
          }
          if (supportsUnknownElements) {
            return ownerDocument.createDocumentFragment();
          }
          data = data || getExpandoData(ownerDocument);
          var clone = data.frag.cloneNode(),
              i = 0,
              elems = getElements(),
              l = elems.length;
          for (; i < l; i++) {
            clone.createElement(elems[i]);
          }
          return clone;
        }
        function shivMethods(ownerDocument, data) {
          if (!data.cache) {
            data.cache = {};
            data.createElem = ownerDocument.createElement;
            data.createFrag = ownerDocument.createDocumentFragment;
            data.frag = data.createFrag();
          }
          ownerDocument.createElement = function(nodeName) {
            if (!html5.shivMethods) {
              return data.createElem(nodeName);
            }
            return createElement(nodeName, ownerDocument, data);
          };
          ownerDocument.createDocumentFragment = Function('h,f', 'return function(){' + 'var n=f.cloneNode(),c=n.createElement;' + 'h.shivMethods&&(' + getElements().join().replace(/[\w\-]+/g, function(nodeName) {
            data.createElem(nodeName);
            data.frag.createElement(nodeName);
            return 'c("' + nodeName + '")';
          }) + ');return n}')(html5, data.frag);
        }
        function shivDocument(ownerDocument) {
          if (!ownerDocument) {
            ownerDocument = document;
          }
          var data = getExpandoData(ownerDocument);
          if (html5.shivCSS && !supportsHtml5Styles && !data.hasCSS) {
            data.hasCSS = !!addStyleSheet(ownerDocument, 'article,aside,dialog,figcaption,figure,footer,header,hgroup,main,nav,section{display:block}' + 'mark{background:#FF0;color:#000}' + 'template{display:none}');
          }
          if (!supportsUnknownElements) {
            shivMethods(ownerDocument, data);
          }
          return ownerDocument;
        }
        var html5 = {
          'elements': options.elements || 'abbr article aside audio bdi canvas data datalist details dialog figcaption figure footer header hgroup main mark meter nav output progress section summary template time video',
          'version': version,
          'shivCSS': (options.shivCSS !== false),
          'supportsUnknownElements': supportsUnknownElements,
          'shivMethods': (options.shivMethods !== false),
          'type': 'default',
          'shivDocument': shivDocument,
          createElement: createElement,
          createDocumentFragment: createDocumentFragment
        };
        window.html5 = html5;
        shivDocument(document);
      }(this, document));
      Modernizr._version = version;
      Modernizr._prefixes = prefixes;
      Modernizr._domPrefixes = domPrefixes;
      Modernizr._cssomPrefixes = cssomPrefixes;
      Modernizr.mq = testMediaQuery;
      Modernizr.hasEvent = isEventSupported;
      Modernizr.testProp = function(prop) {
        return testProps([prop]);
      };
      Modernizr.testAllProps = testPropsAll;
      Modernizr.testStyles = injectElementWithStyles;
      Modernizr.prefixed = function(prop, obj, elem) {
        if (!obj) {
          return testPropsAll(prop, 'pfx');
        } else {
          return testPropsAll(prop, obj, elem);
        }
      };
      docElement.className = docElement.className.replace(/(^|\s)no-js(\s|$)/, '$1$2') + (enableClasses ? ' js ' + classes.join(' ') : '');
      return Modernizr;
    })(this, this.document);
  })();
  return _retrieveGlobal();
});

System.registerDynamic("github:Modernizr/Modernizr@2.8.3.js", ["github:Modernizr/Modernizr@2.8.3/modernizr.js"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = $__require('github:Modernizr/Modernizr@2.8.3/modernizr.js');
  global.define = __define;
  return module.exports;
});

System.registerDynamic("github:angular-ui/angular-ui-router-bower@0.3.1/release/angular-ui-router.js", [], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  if (typeof module !== "undefined" && typeof exports !== "undefined" && module.exports === exports) {
    module.exports = 'ui.router';
  }
  (function(window, angular, undefined) {
    'use strict';
    var isDefined = angular.isDefined,
        isFunction = angular.isFunction,
        isString = angular.isString,
        isObject = angular.isObject,
        isArray = angular.isArray,
        forEach = angular.forEach,
        extend = angular.extend,
        copy = angular.copy,
        toJson = angular.toJson;
    function inherit(parent, extra) {
      return extend(new (extend(function() {}, {prototype: parent}))(), extra);
    }
    function merge(dst) {
      forEach(arguments, function(obj) {
        if (obj !== dst) {
          forEach(obj, function(value, key) {
            if (!dst.hasOwnProperty(key))
              dst[key] = value;
          });
        }
      });
      return dst;
    }
    function ancestors(first, second) {
      var path = [];
      for (var n in first.path) {
        if (first.path[n] !== second.path[n])
          break;
        path.push(first.path[n]);
      }
      return path;
    }
    function objectKeys(object) {
      if (Object.keys) {
        return Object.keys(object);
      }
      var result = [];
      forEach(object, function(val, key) {
        result.push(key);
      });
      return result;
    }
    function indexOf(array, value) {
      if (Array.prototype.indexOf) {
        return array.indexOf(value, Number(arguments[2]) || 0);
      }
      var len = array.length >>> 0,
          from = Number(arguments[2]) || 0;
      from = (from < 0) ? Math.ceil(from) : Math.floor(from);
      if (from < 0)
        from += len;
      for (; from < len; from++) {
        if (from in array && array[from] === value)
          return from;
      }
      return -1;
    }
    function inheritParams(currentParams, newParams, $current, $to) {
      var parents = ancestors($current, $to),
          parentParams,
          inherited = {},
          inheritList = [];
      for (var i in parents) {
        if (!parents[i] || !parents[i].params)
          continue;
        parentParams = objectKeys(parents[i].params);
        if (!parentParams.length)
          continue;
        for (var j in parentParams) {
          if (indexOf(inheritList, parentParams[j]) >= 0)
            continue;
          inheritList.push(parentParams[j]);
          inherited[parentParams[j]] = currentParams[parentParams[j]];
        }
      }
      return extend({}, inherited, newParams);
    }
    function equalForKeys(a, b, keys) {
      if (!keys) {
        keys = [];
        for (var n in a)
          keys.push(n);
      }
      for (var i = 0; i < keys.length; i++) {
        var k = keys[i];
        if (a[k] != b[k])
          return false;
      }
      return true;
    }
    function filterByKeys(keys, values) {
      var filtered = {};
      forEach(keys, function(name) {
        filtered[name] = values[name];
      });
      return filtered;
    }
    function indexBy(array, propName) {
      var result = {};
      forEach(array, function(item) {
        result[item[propName]] = item;
      });
      return result;
    }
    function pick(obj) {
      var copy = {};
      var keys = Array.prototype.concat.apply(Array.prototype, Array.prototype.slice.call(arguments, 1));
      forEach(keys, function(key) {
        if (key in obj)
          copy[key] = obj[key];
      });
      return copy;
    }
    function omit(obj) {
      var copy = {};
      var keys = Array.prototype.concat.apply(Array.prototype, Array.prototype.slice.call(arguments, 1));
      for (var key in obj) {
        if (indexOf(keys, key) == -1)
          copy[key] = obj[key];
      }
      return copy;
    }
    function pluck(collection, key) {
      var result = isArray(collection) ? [] : {};
      forEach(collection, function(val, i) {
        result[i] = isFunction(key) ? key(val) : val[key];
      });
      return result;
    }
    function filter(collection, callback) {
      var array = isArray(collection);
      var result = array ? [] : {};
      forEach(collection, function(val, i) {
        if (callback(val, i)) {
          result[array ? result.length : i] = val;
        }
      });
      return result;
    }
    function map(collection, callback) {
      var result = isArray(collection) ? [] : {};
      forEach(collection, function(val, i) {
        result[i] = callback(val, i);
      });
      return result;
    }
    angular.module('ui.router.util', ['ng']);
    angular.module('ui.router.router', ['ui.router.util']);
    angular.module('ui.router.state', ['ui.router.router', 'ui.router.util']);
    angular.module('ui.router', ['ui.router.state']);
    angular.module('ui.router.compat', ['ui.router']);
    $Resolve.$inject = ['$q', '$injector'];
    function $Resolve($q, $injector) {
      var VISIT_IN_PROGRESS = 1,
          VISIT_DONE = 2,
          NOTHING = {},
          NO_DEPENDENCIES = [],
          NO_LOCALS = NOTHING,
          NO_PARENT = extend($q.when(NOTHING), {
            $$promises: NOTHING,
            $$values: NOTHING
          });
      this.study = function(invocables) {
        if (!isObject(invocables))
          throw new Error("'invocables' must be an object");
        var invocableKeys = objectKeys(invocables || {});
        var plan = [],
            cycle = [],
            visited = {};
        function visit(value, key) {
          if (visited[key] === VISIT_DONE)
            return;
          cycle.push(key);
          if (visited[key] === VISIT_IN_PROGRESS) {
            cycle.splice(0, indexOf(cycle, key));
            throw new Error("Cyclic dependency: " + cycle.join(" -> "));
          }
          visited[key] = VISIT_IN_PROGRESS;
          if (isString(value)) {
            plan.push(key, [function() {
              return $injector.get(value);
            }], NO_DEPENDENCIES);
          } else {
            var params = $injector.annotate(value);
            forEach(params, function(param) {
              if (param !== key && invocables.hasOwnProperty(param))
                visit(invocables[param], param);
            });
            plan.push(key, value, params);
          }
          cycle.pop();
          visited[key] = VISIT_DONE;
        }
        forEach(invocables, visit);
        invocables = cycle = visited = null;
        function isResolve(value) {
          return isObject(value) && value.then && value.$$promises;
        }
        return function(locals, parent, self) {
          if (isResolve(locals) && self === undefined) {
            self = parent;
            parent = locals;
            locals = null;
          }
          if (!locals)
            locals = NO_LOCALS;
          else if (!isObject(locals)) {
            throw new Error("'locals' must be an object");
          }
          if (!parent)
            parent = NO_PARENT;
          else if (!isResolve(parent)) {
            throw new Error("'parent' must be a promise returned by $resolve.resolve()");
          }
          var resolution = $q.defer(),
              result = resolution.promise,
              promises = result.$$promises = {},
              values = extend({}, locals),
              wait = 1 + plan.length / 3,
              merged = false;
          function done() {
            if (!--wait) {
              if (!merged)
                merge(values, parent.$$values);
              result.$$values = values;
              result.$$promises = result.$$promises || true;
              delete result.$$inheritedValues;
              resolution.resolve(values);
            }
          }
          function fail(reason) {
            result.$$failure = reason;
            resolution.reject(reason);
          }
          if (isDefined(parent.$$failure)) {
            fail(parent.$$failure);
            return result;
          }
          if (parent.$$inheritedValues) {
            merge(values, omit(parent.$$inheritedValues, invocableKeys));
          }
          extend(promises, parent.$$promises);
          if (parent.$$values) {
            merged = merge(values, omit(parent.$$values, invocableKeys));
            result.$$inheritedValues = omit(parent.$$values, invocableKeys);
            done();
          } else {
            if (parent.$$inheritedValues) {
              result.$$inheritedValues = omit(parent.$$inheritedValues, invocableKeys);
            }
            parent.then(done, fail);
          }
          for (var i = 0,
              ii = plan.length; i < ii; i += 3) {
            if (locals.hasOwnProperty(plan[i]))
              done();
            else
              invoke(plan[i], plan[i + 1], plan[i + 2]);
          }
          function invoke(key, invocable, params) {
            var invocation = $q.defer(),
                waitParams = 0;
            function onfailure(reason) {
              invocation.reject(reason);
              fail(reason);
            }
            forEach(params, function(dep) {
              if (promises.hasOwnProperty(dep) && !locals.hasOwnProperty(dep)) {
                waitParams++;
                promises[dep].then(function(result) {
                  values[dep] = result;
                  if (!(--waitParams))
                    proceed();
                }, onfailure);
              }
            });
            if (!waitParams)
              proceed();
            function proceed() {
              if (isDefined(result.$$failure))
                return;
              try {
                invocation.resolve($injector.invoke(invocable, self, values));
                invocation.promise.then(function(result) {
                  values[key] = result;
                  done();
                }, onfailure);
              } catch (e) {
                onfailure(e);
              }
            }
            promises[key] = invocation.promise;
          }
          return result;
        };
      };
      this.resolve = function(invocables, locals, parent, self) {
        return this.study(invocables)(locals, parent, self);
      };
    }
    angular.module('ui.router.util').service('$resolve', $Resolve);
    $TemplateFactory.$inject = ['$http', '$templateCache', '$injector'];
    function $TemplateFactory($http, $templateCache, $injector) {
      this.fromConfig = function(config, params, locals) {
        return (isDefined(config.template) ? this.fromString(config.template, params) : isDefined(config.templateUrl) ? this.fromUrl(config.templateUrl, params) : isDefined(config.templateProvider) ? this.fromProvider(config.templateProvider, params, locals) : null);
      };
      this.fromString = function(template, params) {
        return isFunction(template) ? template(params) : template;
      };
      this.fromUrl = function(url, params) {
        if (isFunction(url))
          url = url(params);
        if (url == null)
          return null;
        else
          return $http.get(url, {
            cache: $templateCache,
            headers: {Accept: 'text/html'}
          }).then(function(response) {
            return response.data;
          });
      };
      this.fromProvider = function(provider, params, locals) {
        return $injector.invoke(provider, null, locals || {params: params});
      };
    }
    angular.module('ui.router.util').service('$templateFactory', $TemplateFactory);
    var $$UMFP;
    function UrlMatcher(pattern, config, parentMatcher) {
      config = extend({params: {}}, isObject(config) ? config : {});
      var placeholder = /([:*])([\w\[\]]+)|\{([\w\[\]]+)(?:\:\s*((?:[^{}\\]+|\\.|\{(?:[^{}\\]+|\\.)*\})+))?\}/g,
          searchPlaceholder = /([:]?)([\w\[\].-]+)|\{([\w\[\].-]+)(?:\:\s*((?:[^{}\\]+|\\.|\{(?:[^{}\\]+|\\.)*\})+))?\}/g,
          compiled = '^',
          last = 0,
          m,
          segments = this.segments = [],
          parentParams = parentMatcher ? parentMatcher.params : {},
          params = this.params = parentMatcher ? parentMatcher.params.$$new() : new $$UMFP.ParamSet(),
          paramNames = [];
      function addParameter(id, type, config, location) {
        paramNames.push(id);
        if (parentParams[id])
          return parentParams[id];
        if (!/^\w+([-.]+\w+)*(?:\[\])?$/.test(id))
          throw new Error("Invalid parameter name '" + id + "' in pattern '" + pattern + "'");
        if (params[id])
          throw new Error("Duplicate parameter name '" + id + "' in pattern '" + pattern + "'");
        params[id] = new $$UMFP.Param(id, type, config, location);
        return params[id];
      }
      function quoteRegExp(string, pattern, squash, optional) {
        var surroundPattern = ['', ''],
            result = string.replace(/[\\\[\]\^$*+?.()|{}]/g, "\\$&");
        if (!pattern)
          return result;
        switch (squash) {
          case false:
            surroundPattern = ['(', ')' + (optional ? "?" : "")];
            break;
          case true:
            result = result.replace(/\/$/, '');
            surroundPattern = ['(?:\/(', ')|\/)?'];
            break;
          default:
            surroundPattern = ['(' + squash + "|", ')?'];
            break;
        }
        return result + surroundPattern[0] + pattern + surroundPattern[1];
      }
      this.source = pattern;
      function matchDetails(m, isSearch) {
        var id,
            regexp,
            segment,
            type,
            cfg,
            arrayMode;
        id = m[2] || m[3];
        cfg = config.params[id];
        segment = pattern.substring(last, m.index);
        regexp = isSearch ? m[4] : m[4] || (m[1] == '*' ? '.*' : null);
        if (regexp) {
          type = $$UMFP.type(regexp) || inherit($$UMFP.type("string"), {pattern: new RegExp(regexp, config.caseInsensitive ? 'i' : undefined)});
        }
        return {
          id: id,
          regexp: regexp,
          segment: segment,
          type: type,
          cfg: cfg
        };
      }
      var p,
          param,
          segment;
      while ((m = placeholder.exec(pattern))) {
        p = matchDetails(m, false);
        if (p.segment.indexOf('?') >= 0)
          break;
        param = addParameter(p.id, p.type, p.cfg, "path");
        compiled += quoteRegExp(p.segment, param.type.pattern.source, param.squash, param.isOptional);
        segments.push(p.segment);
        last = placeholder.lastIndex;
      }
      segment = pattern.substring(last);
      var i = segment.indexOf('?');
      if (i >= 0) {
        var search = this.sourceSearch = segment.substring(i);
        segment = segment.substring(0, i);
        this.sourcePath = pattern.substring(0, last + i);
        if (search.length > 0) {
          last = 0;
          while ((m = searchPlaceholder.exec(search))) {
            p = matchDetails(m, true);
            param = addParameter(p.id, p.type, p.cfg, "search");
            last = placeholder.lastIndex;
          }
        }
      } else {
        this.sourcePath = pattern;
        this.sourceSearch = '';
      }
      compiled += quoteRegExp(segment) + (config.strict === false ? '\/?' : '') + '$';
      segments.push(segment);
      this.regexp = new RegExp(compiled, config.caseInsensitive ? 'i' : undefined);
      this.prefix = segments[0];
      this.$$paramNames = paramNames;
    }
    UrlMatcher.prototype.concat = function(pattern, config) {
      var defaultConfig = {
        caseInsensitive: $$UMFP.caseInsensitive(),
        strict: $$UMFP.strictMode(),
        squash: $$UMFP.defaultSquashPolicy()
      };
      return new UrlMatcher(this.sourcePath + pattern + this.sourceSearch, extend(defaultConfig, config), this);
    };
    UrlMatcher.prototype.toString = function() {
      return this.source;
    };
    UrlMatcher.prototype.exec = function(path, searchParams) {
      var m = this.regexp.exec(path);
      if (!m)
        return null;
      searchParams = searchParams || {};
      var paramNames = this.parameters(),
          nTotal = paramNames.length,
          nPath = this.segments.length - 1,
          values = {},
          i,
          j,
          cfg,
          paramName;
      if (nPath !== m.length - 1)
        throw new Error("Unbalanced capture group in route '" + this.source + "'");
      function decodePathArray(string) {
        function reverseString(str) {
          return str.split("").reverse().join("");
        }
        function unquoteDashes(str) {
          return str.replace(/\\-/g, "-");
        }
        var split = reverseString(string).split(/-(?!\\)/);
        var allReversed = map(split, reverseString);
        return map(allReversed, unquoteDashes).reverse();
      }
      var param,
          paramVal;
      for (i = 0; i < nPath; i++) {
        paramName = paramNames[i];
        param = this.params[paramName];
        paramVal = m[i + 1];
        for (j = 0; j < param.replace.length; j++) {
          if (param.replace[j].from === paramVal)
            paramVal = param.replace[j].to;
        }
        if (paramVal && param.array === true)
          paramVal = decodePathArray(paramVal);
        if (isDefined(paramVal))
          paramVal = param.type.decode(paramVal);
        values[paramName] = param.value(paramVal);
      }
      for (; i < nTotal; i++) {
        paramName = paramNames[i];
        values[paramName] = this.params[paramName].value(searchParams[paramName]);
        param = this.params[paramName];
        paramVal = searchParams[paramName];
        for (j = 0; j < param.replace.length; j++) {
          if (param.replace[j].from === paramVal)
            paramVal = param.replace[j].to;
        }
        if (isDefined(paramVal))
          paramVal = param.type.decode(paramVal);
        values[paramName] = param.value(paramVal);
      }
      return values;
    };
    UrlMatcher.prototype.parameters = function(param) {
      if (!isDefined(param))
        return this.$$paramNames;
      return this.params[param] || null;
    };
    UrlMatcher.prototype.validates = function(params) {
      return this.params.$$validates(params);
    };
    UrlMatcher.prototype.format = function(values) {
      values = values || {};
      var segments = this.segments,
          params = this.parameters(),
          paramset = this.params;
      if (!this.validates(values))
        return null;
      var i,
          search = false,
          nPath = segments.length - 1,
          nTotal = params.length,
          result = segments[0];
      function encodeDashes(str) {
        return encodeURIComponent(str).replace(/-/g, function(c) {
          return '%5C%' + c.charCodeAt(0).toString(16).toUpperCase();
        });
      }
      for (i = 0; i < nTotal; i++) {
        var isPathParam = i < nPath;
        var name = params[i],
            param = paramset[name],
            value = param.value(values[name]);
        var isDefaultValue = param.isOptional && param.type.equals(param.value(), value);
        var squash = isDefaultValue ? param.squash : false;
        var encoded = param.type.encode(value);
        if (isPathParam) {
          var nextSegment = segments[i + 1];
          var isFinalPathParam = i + 1 === nPath;
          if (squash === false) {
            if (encoded != null) {
              if (isArray(encoded)) {
                result += map(encoded, encodeDashes).join("-");
              } else {
                result += encodeURIComponent(encoded);
              }
            }
            result += nextSegment;
          } else if (squash === true) {
            var capture = result.match(/\/$/) ? /\/?(.*)/ : /(.*)/;
            result += nextSegment.match(capture)[1];
          } else if (isString(squash)) {
            result += squash + nextSegment;
          }
          if (isFinalPathParam && param.squash === true && result.slice(-1) === '/')
            result = result.slice(0, -1);
        } else {
          if (encoded == null || (isDefaultValue && squash !== false))
            continue;
          if (!isArray(encoded))
            encoded = [encoded];
          if (encoded.length === 0)
            continue;
          encoded = map(encoded, encodeURIComponent).join('&' + name + '=');
          result += (search ? '&' : '?') + (name + '=' + encoded);
          search = true;
        }
      }
      return result;
    };
    function Type(config) {
      extend(this, config);
    }
    Type.prototype.is = function(val, key) {
      return true;
    };
    Type.prototype.encode = function(val, key) {
      return val;
    };
    Type.prototype.decode = function(val, key) {
      return val;
    };
    Type.prototype.equals = function(a, b) {
      return a == b;
    };
    Type.prototype.$subPattern = function() {
      var sub = this.pattern.toString();
      return sub.substr(1, sub.length - 2);
    };
    Type.prototype.pattern = /.*/;
    Type.prototype.toString = function() {
      return "{Type:" + this.name + "}";
    };
    Type.prototype.$normalize = function(val) {
      return this.is(val) ? val : this.decode(val);
    };
    Type.prototype.$asArray = function(mode, isSearch) {
      if (!mode)
        return this;
      if (mode === "auto" && !isSearch)
        throw new Error("'auto' array mode is for query parameters only");
      function ArrayType(type, mode) {
        function bindTo(type, callbackName) {
          return function() {
            return type[callbackName].apply(type, arguments);
          };
        }
        function arrayWrap(val) {
          return isArray(val) ? val : (isDefined(val) ? [val] : []);
        }
        function arrayUnwrap(val) {
          switch (val.length) {
            case 0:
              return undefined;
            case 1:
              return mode === "auto" ? val[0] : val;
            default:
              return val;
          }
        }
        function falsey(val) {
          return !val;
        }
        function arrayHandler(callback, allTruthyMode) {
          return function handleArray(val) {
            if (isArray(val) && val.length === 0)
              return val;
            val = arrayWrap(val);
            var result = map(val, callback);
            if (allTruthyMode === true)
              return filter(result, falsey).length === 0;
            return arrayUnwrap(result);
          };
        }
        function arrayEqualsHandler(callback) {
          return function handleArray(val1, val2) {
            var left = arrayWrap(val1),
                right = arrayWrap(val2);
            if (left.length !== right.length)
              return false;
            for (var i = 0; i < left.length; i++) {
              if (!callback(left[i], right[i]))
                return false;
            }
            return true;
          };
        }
        this.encode = arrayHandler(bindTo(type, 'encode'));
        this.decode = arrayHandler(bindTo(type, 'decode'));
        this.is = arrayHandler(bindTo(type, 'is'), true);
        this.equals = arrayEqualsHandler(bindTo(type, 'equals'));
        this.pattern = type.pattern;
        this.$normalize = arrayHandler(bindTo(type, '$normalize'));
        this.name = type.name;
        this.$arrayMode = mode;
      }
      return new ArrayType(this, mode);
    };
    function $UrlMatcherFactory() {
      $$UMFP = this;
      var isCaseInsensitive = false,
          isStrictMode = true,
          defaultSquashPolicy = false;
      function valToString(val) {
        return val != null ? val.toString().replace(/~/g, "~~").replace(/\//g, "~2F") : val;
      }
      function valFromString(val) {
        return val != null ? val.toString().replace(/~2F/g, "/").replace(/~~/g, "~") : val;
      }
      var $types = {},
          enqueue = true,
          typeQueue = [],
          injector,
          defaultTypes = {
            "string": {
              encode: valToString,
              decode: valFromString,
              is: function(val) {
                return val == null || !isDefined(val) || typeof val === "string";
              },
              pattern: /[^/]*/
            },
            "int": {
              encode: valToString,
              decode: function(val) {
                return parseInt(val, 10);
              },
              is: function(val) {
                return isDefined(val) && this.decode(val.toString()) === val;
              },
              pattern: /\d+/
            },
            "bool": {
              encode: function(val) {
                return val ? 1 : 0;
              },
              decode: function(val) {
                return parseInt(val, 10) !== 0;
              },
              is: function(val) {
                return val === true || val === false;
              },
              pattern: /0|1/
            },
            "date": {
              encode: function(val) {
                if (!this.is(val))
                  return undefined;
                return [val.getFullYear(), ('0' + (val.getMonth() + 1)).slice(-2), ('0' + val.getDate()).slice(-2)].join("-");
              },
              decode: function(val) {
                if (this.is(val))
                  return val;
                var match = this.capture.exec(val);
                return match ? new Date(match[1], match[2] - 1, match[3]) : undefined;
              },
              is: function(val) {
                return val instanceof Date && !isNaN(val.valueOf());
              },
              equals: function(a, b) {
                return this.is(a) && this.is(b) && a.toISOString() === b.toISOString();
              },
              pattern: /[0-9]{4}-(?:0[1-9]|1[0-2])-(?:0[1-9]|[1-2][0-9]|3[0-1])/,
              capture: /([0-9]{4})-(0[1-9]|1[0-2])-(0[1-9]|[1-2][0-9]|3[0-1])/
            },
            "json": {
              encode: angular.toJson,
              decode: angular.fromJson,
              is: angular.isObject,
              equals: angular.equals,
              pattern: /[^/]*/
            },
            "any": {
              encode: angular.identity,
              decode: angular.identity,
              equals: angular.equals,
              pattern: /.*/
            }
          };
      function getDefaultConfig() {
        return {
          strict: isStrictMode,
          caseInsensitive: isCaseInsensitive
        };
      }
      function isInjectable(value) {
        return (isFunction(value) || (isArray(value) && isFunction(value[value.length - 1])));
      }
      $UrlMatcherFactory.$$getDefaultValue = function(config) {
        if (!isInjectable(config.value))
          return config.value;
        if (!injector)
          throw new Error("Injectable functions cannot be called at configuration time");
        return injector.invoke(config.value);
      };
      this.caseInsensitive = function(value) {
        if (isDefined(value))
          isCaseInsensitive = value;
        return isCaseInsensitive;
      };
      this.strictMode = function(value) {
        if (isDefined(value))
          isStrictMode = value;
        return isStrictMode;
      };
      this.defaultSquashPolicy = function(value) {
        if (!isDefined(value))
          return defaultSquashPolicy;
        if (value !== true && value !== false && !isString(value))
          throw new Error("Invalid squash policy: " + value + ". Valid policies: false, true, arbitrary-string");
        defaultSquashPolicy = value;
        return value;
      };
      this.compile = function(pattern, config) {
        return new UrlMatcher(pattern, extend(getDefaultConfig(), config));
      };
      this.isMatcher = function(o) {
        if (!isObject(o))
          return false;
        var result = true;
        forEach(UrlMatcher.prototype, function(val, name) {
          if (isFunction(val)) {
            result = result && (isDefined(o[name]) && isFunction(o[name]));
          }
        });
        return result;
      };
      this.type = function(name, definition, definitionFn) {
        if (!isDefined(definition))
          return $types[name];
        if ($types.hasOwnProperty(name))
          throw new Error("A type named '" + name + "' has already been defined.");
        $types[name] = new Type(extend({name: name}, definition));
        if (definitionFn) {
          typeQueue.push({
            name: name,
            def: definitionFn
          });
          if (!enqueue)
            flushTypeQueue();
        }
        return this;
      };
      function flushTypeQueue() {
        while (typeQueue.length) {
          var type = typeQueue.shift();
          if (type.pattern)
            throw new Error("You cannot override a type's .pattern at runtime.");
          angular.extend($types[type.name], injector.invoke(type.def));
        }
      }
      forEach(defaultTypes, function(type, name) {
        $types[name] = new Type(extend({name: name}, type));
      });
      $types = inherit($types, {});
      this.$get = ['$injector', function($injector) {
        injector = $injector;
        enqueue = false;
        flushTypeQueue();
        forEach(defaultTypes, function(type, name) {
          if (!$types[name])
            $types[name] = new Type(type);
        });
        return this;
      }];
      this.Param = function Param(id, type, config, location) {
        var self = this;
        config = unwrapShorthand(config);
        type = getType(config, type, location);
        var arrayMode = getArrayMode();
        type = arrayMode ? type.$asArray(arrayMode, location === "search") : type;
        if (type.name === "string" && !arrayMode && location === "path" && config.value === undefined)
          config.value = "";
        var isOptional = config.value !== undefined;
        var squash = getSquashPolicy(config, isOptional);
        var replace = getReplace(config, arrayMode, isOptional, squash);
        function unwrapShorthand(config) {
          var keys = isObject(config) ? objectKeys(config) : [];
          var isShorthand = indexOf(keys, "value") === -1 && indexOf(keys, "type") === -1 && indexOf(keys, "squash") === -1 && indexOf(keys, "array") === -1;
          if (isShorthand)
            config = {value: config};
          config.$$fn = isInjectable(config.value) ? config.value : function() {
            return config.value;
          };
          return config;
        }
        function getType(config, urlType, location) {
          if (config.type && urlType)
            throw new Error("Param '" + id + "' has two type configurations.");
          if (urlType)
            return urlType;
          if (!config.type)
            return (location === "config" ? $types.any : $types.string);
          if (angular.isString(config.type))
            return $types[config.type];
          if (config.type instanceof Type)
            return config.type;
          return new Type(config.type);
        }
        function getArrayMode() {
          var arrayDefaults = {array: (location === "search" ? "auto" : false)};
          var arrayParamNomenclature = id.match(/\[\]$/) ? {array: true} : {};
          return extend(arrayDefaults, arrayParamNomenclature, config).array;
        }
        function getSquashPolicy(config, isOptional) {
          var squash = config.squash;
          if (!isOptional || squash === false)
            return false;
          if (!isDefined(squash) || squash == null)
            return defaultSquashPolicy;
          if (squash === true || isString(squash))
            return squash;
          throw new Error("Invalid squash policy: '" + squash + "'. Valid policies: false, true, or arbitrary string");
        }
        function getReplace(config, arrayMode, isOptional, squash) {
          var replace,
              configuredKeys,
              defaultPolicy = [{
                from: "",
                to: (isOptional || arrayMode ? undefined : "")
              }, {
                from: null,
                to: (isOptional || arrayMode ? undefined : "")
              }];
          replace = isArray(config.replace) ? config.replace : [];
          if (isString(squash))
            replace.push({
              from: squash,
              to: undefined
            });
          configuredKeys = map(replace, function(item) {
            return item.from;
          });
          return filter(defaultPolicy, function(item) {
            return indexOf(configuredKeys, item.from) === -1;
          }).concat(replace);
        }
        function $$getDefaultValue() {
          if (!injector)
            throw new Error("Injectable functions cannot be called at configuration time");
          var defaultValue = injector.invoke(config.$$fn);
          if (defaultValue !== null && defaultValue !== undefined && !self.type.is(defaultValue))
            throw new Error("Default value (" + defaultValue + ") for parameter '" + self.id + "' is not an instance of Type (" + self.type.name + ")");
          return defaultValue;
        }
        function $value(value) {
          function hasReplaceVal(val) {
            return function(obj) {
              return obj.from === val;
            };
          }
          function $replace(value) {
            var replacement = map(filter(self.replace, hasReplaceVal(value)), function(obj) {
              return obj.to;
            });
            return replacement.length ? replacement[0] : value;
          }
          value = $replace(value);
          return !isDefined(value) ? $$getDefaultValue() : self.type.$normalize(value);
        }
        function toString() {
          return "{Param:" + id + " " + type + " squash: '" + squash + "' optional: " + isOptional + "}";
        }
        extend(this, {
          id: id,
          type: type,
          location: location,
          array: arrayMode,
          squash: squash,
          replace: replace,
          isOptional: isOptional,
          value: $value,
          dynamic: undefined,
          config: config,
          toString: toString
        });
      };
      function ParamSet(params) {
        extend(this, params || {});
      }
      ParamSet.prototype = {
        $$new: function() {
          return inherit(this, extend(new ParamSet(), {$$parent: this}));
        },
        $$keys: function() {
          var keys = [],
              chain = [],
              parent = this,
              ignore = objectKeys(ParamSet.prototype);
          while (parent) {
            chain.push(parent);
            parent = parent.$$parent;
          }
          chain.reverse();
          forEach(chain, function(paramset) {
            forEach(objectKeys(paramset), function(key) {
              if (indexOf(keys, key) === -1 && indexOf(ignore, key) === -1)
                keys.push(key);
            });
          });
          return keys;
        },
        $$values: function(paramValues) {
          var values = {},
              self = this;
          forEach(self.$$keys(), function(key) {
            values[key] = self[key].value(paramValues && paramValues[key]);
          });
          return values;
        },
        $$equals: function(paramValues1, paramValues2) {
          var equal = true,
              self = this;
          forEach(self.$$keys(), function(key) {
            var left = paramValues1 && paramValues1[key],
                right = paramValues2 && paramValues2[key];
            if (!self[key].type.equals(left, right))
              equal = false;
          });
          return equal;
        },
        $$validates: function $$validate(paramValues) {
          var keys = this.$$keys(),
              i,
              param,
              rawVal,
              normalized,
              encoded;
          for (i = 0; i < keys.length; i++) {
            param = this[keys[i]];
            rawVal = paramValues[keys[i]];
            if ((rawVal === undefined || rawVal === null) && param.isOptional)
              break;
            normalized = param.type.$normalize(rawVal);
            if (!param.type.is(normalized))
              return false;
            encoded = param.type.encode(normalized);
            if (angular.isString(encoded) && !param.type.pattern.exec(encoded))
              return false;
          }
          return true;
        },
        $$parent: undefined
      };
      this.ParamSet = ParamSet;
    }
    angular.module('ui.router.util').provider('$urlMatcherFactory', $UrlMatcherFactory);
    angular.module('ui.router.util').run(['$urlMatcherFactory', function($urlMatcherFactory) {}]);
    $UrlRouterProvider.$inject = ['$locationProvider', '$urlMatcherFactoryProvider'];
    function $UrlRouterProvider($locationProvider, $urlMatcherFactory) {
      var rules = [],
          otherwise = null,
          interceptDeferred = false,
          listener;
      function regExpPrefix(re) {
        var prefix = /^\^((?:\\[^a-zA-Z0-9]|[^\\\[\]\^$*+?.()|{}]+)*)/.exec(re.source);
        return (prefix != null) ? prefix[1].replace(/\\(.)/g, "$1") : '';
      }
      function interpolate(pattern, match) {
        return pattern.replace(/\$(\$|\d{1,2})/, function(m, what) {
          return match[what === '$' ? 0 : Number(what)];
        });
      }
      this.rule = function(rule) {
        if (!isFunction(rule))
          throw new Error("'rule' must be a function");
        rules.push(rule);
        return this;
      };
      this.otherwise = function(rule) {
        if (isString(rule)) {
          var redirect = rule;
          rule = function() {
            return redirect;
          };
        } else if (!isFunction(rule))
          throw new Error("'rule' must be a function");
        otherwise = rule;
        return this;
      };
      function handleIfMatch($injector, handler, match) {
        if (!match)
          return false;
        var result = $injector.invoke(handler, handler, {$match: match});
        return isDefined(result) ? result : true;
      }
      this.when = function(what, handler) {
        var redirect,
            handlerIsString = isString(handler);
        if (isString(what))
          what = $urlMatcherFactory.compile(what);
        if (!handlerIsString && !isFunction(handler) && !isArray(handler))
          throw new Error("invalid 'handler' in when()");
        var strategies = {
          matcher: function(what, handler) {
            if (handlerIsString) {
              redirect = $urlMatcherFactory.compile(handler);
              handler = ['$match', function($match) {
                return redirect.format($match);
              }];
            }
            return extend(function($injector, $location) {
              return handleIfMatch($injector, handler, what.exec($location.path(), $location.search()));
            }, {prefix: isString(what.prefix) ? what.prefix : ''});
          },
          regex: function(what, handler) {
            if (what.global || what.sticky)
              throw new Error("when() RegExp must not be global or sticky");
            if (handlerIsString) {
              redirect = handler;
              handler = ['$match', function($match) {
                return interpolate(redirect, $match);
              }];
            }
            return extend(function($injector, $location) {
              return handleIfMatch($injector, handler, what.exec($location.path()));
            }, {prefix: regExpPrefix(what)});
          }
        };
        var check = {
          matcher: $urlMatcherFactory.isMatcher(what),
          regex: what instanceof RegExp
        };
        for (var n in check) {
          if (check[n])
            return this.rule(strategies[n](what, handler));
        }
        throw new Error("invalid 'what' in when()");
      };
      this.deferIntercept = function(defer) {
        if (defer === undefined)
          defer = true;
        interceptDeferred = defer;
      };
      this.$get = $get;
      $get.$inject = ['$location', '$rootScope', '$injector', '$browser', '$sniffer'];
      function $get($location, $rootScope, $injector, $browser, $sniffer) {
        var baseHref = $browser.baseHref(),
            location = $location.url(),
            lastPushedUrl;
        function appendBasePath(url, isHtml5, absolute) {
          if (baseHref === '/')
            return url;
          if (isHtml5)
            return baseHref.slice(0, -1) + url;
          if (absolute)
            return baseHref.slice(1) + url;
          return url;
        }
        function update(evt) {
          if (evt && evt.defaultPrevented)
            return;
          var ignoreUpdate = lastPushedUrl && $location.url() === lastPushedUrl;
          lastPushedUrl = undefined;
          function check(rule) {
            var handled = rule($injector, $location);
            if (!handled)
              return false;
            if (isString(handled))
              $location.replace().url(handled);
            return true;
          }
          var n = rules.length,
              i;
          for (i = 0; i < n; i++) {
            if (check(rules[i]))
              return;
          }
          if (otherwise)
            check(otherwise);
        }
        function listen() {
          listener = listener || $rootScope.$on('$locationChangeSuccess', update);
          return listener;
        }
        if (!interceptDeferred)
          listen();
        return {
          sync: function() {
            update();
          },
          listen: function() {
            return listen();
          },
          update: function(read) {
            if (read) {
              location = $location.url();
              return;
            }
            if ($location.url() === location)
              return;
            $location.url(location);
            $location.replace();
          },
          push: function(urlMatcher, params, options) {
            var url = urlMatcher.format(params || {});
            if (url !== null && params && params['#']) {
              url += '#' + params['#'];
            }
            $location.url(url);
            lastPushedUrl = options && options.$$avoidResync ? $location.url() : undefined;
            if (options && options.replace)
              $location.replace();
          },
          href: function(urlMatcher, params, options) {
            if (!urlMatcher.validates(params))
              return null;
            var isHtml5 = $locationProvider.html5Mode();
            if (angular.isObject(isHtml5)) {
              isHtml5 = isHtml5.enabled;
            }
            isHtml5 = isHtml5 && $sniffer.history;
            var url = urlMatcher.format(params);
            options = options || {};
            if (!isHtml5 && url !== null) {
              url = "#" + $locationProvider.hashPrefix() + url;
            }
            if (url !== null && params && params['#']) {
              url += '#' + params['#'];
            }
            url = appendBasePath(url, isHtml5, options.absolute);
            if (!options.absolute || !url) {
              return url;
            }
            var slash = (!isHtml5 && url ? '/' : ''),
                port = $location.port();
            port = (port === 80 || port === 443 ? '' : ':' + port);
            return [$location.protocol(), '://', $location.host(), port, slash, url].join('');
          }
        };
      }
    }
    angular.module('ui.router.router').provider('$urlRouter', $UrlRouterProvider);
    $StateProvider.$inject = ['$urlRouterProvider', '$urlMatcherFactoryProvider'];
    function $StateProvider($urlRouterProvider, $urlMatcherFactory) {
      var root,
          states = {},
          $state,
          queue = {},
          abstractKey = 'abstract';
      var stateBuilder = {
        parent: function(state) {
          if (isDefined(state.parent) && state.parent)
            return findState(state.parent);
          var compositeName = /^(.+)\.[^.]+$/.exec(state.name);
          return compositeName ? findState(compositeName[1]) : root;
        },
        data: function(state) {
          if (state.parent && state.parent.data) {
            state.data = state.self.data = inherit(state.parent.data, state.data);
          }
          return state.data;
        },
        url: function(state) {
          var url = state.url,
              config = {params: state.params || {}};
          if (isString(url)) {
            if (url.charAt(0) == '^')
              return $urlMatcherFactory.compile(url.substring(1), config);
            return (state.parent.navigable || root).url.concat(url, config);
          }
          if (!url || $urlMatcherFactory.isMatcher(url))
            return url;
          throw new Error("Invalid url '" + url + "' in state '" + state + "'");
        },
        navigable: function(state) {
          return state.url ? state : (state.parent ? state.parent.navigable : null);
        },
        ownParams: function(state) {
          var params = state.url && state.url.params || new $$UMFP.ParamSet();
          forEach(state.params || {}, function(config, id) {
            if (!params[id])
              params[id] = new $$UMFP.Param(id, null, config, "config");
          });
          return params;
        },
        params: function(state) {
          var ownParams = pick(state.ownParams, state.ownParams.$$keys());
          return state.parent && state.parent.params ? extend(state.parent.params.$$new(), ownParams) : new $$UMFP.ParamSet();
        },
        views: function(state) {
          var views = {};
          forEach(isDefined(state.views) ? state.views : {'': state}, function(view, name) {
            if (name.indexOf('@') < 0)
              name += '@' + state.parent.name;
            view.resolveAs = view.resolveAs || state.resolveAs || '$resolve';
            views[name] = view;
          });
          return views;
        },
        path: function(state) {
          return state.parent ? state.parent.path.concat(state) : [];
        },
        includes: function(state) {
          var includes = state.parent ? extend({}, state.parent.includes) : {};
          includes[state.name] = true;
          return includes;
        },
        $delegates: {}
      };
      function isRelative(stateName) {
        return stateName.indexOf(".") === 0 || stateName.indexOf("^") === 0;
      }
      function findState(stateOrName, base) {
        if (!stateOrName)
          return undefined;
        var isStr = isString(stateOrName),
            name = isStr ? stateOrName : stateOrName.name,
            path = isRelative(name);
        if (path) {
          if (!base)
            throw new Error("No reference point given for path '" + name + "'");
          base = findState(base);
          var rel = name.split("."),
              i = 0,
              pathLength = rel.length,
              current = base;
          for (; i < pathLength; i++) {
            if (rel[i] === "" && i === 0) {
              current = base;
              continue;
            }
            if (rel[i] === "^") {
              if (!current.parent)
                throw new Error("Path '" + name + "' not valid for state '" + base.name + "'");
              current = current.parent;
              continue;
            }
            break;
          }
          rel = rel.slice(i).join(".");
          name = current.name + (current.name && rel ? "." : "") + rel;
        }
        var state = states[name];
        if (state && (isStr || (!isStr && (state === stateOrName || state.self === stateOrName)))) {
          return state;
        }
        return undefined;
      }
      function queueState(parentName, state) {
        if (!queue[parentName]) {
          queue[parentName] = [];
        }
        queue[parentName].push(state);
      }
      function flushQueuedChildren(parentName) {
        var queued = queue[parentName] || [];
        while (queued.length) {
          registerState(queued.shift());
        }
      }
      function registerState(state) {
        state = inherit(state, {
          self: state,
          resolve: state.resolve || {},
          toString: function() {
            return this.name;
          }
        });
        var name = state.name;
        if (!isString(name) || name.indexOf('@') >= 0)
          throw new Error("State must have a valid name");
        if (states.hasOwnProperty(name))
          throw new Error("State '" + name + "' is already defined");
        var parentName = (name.indexOf('.') !== -1) ? name.substring(0, name.lastIndexOf('.')) : (isString(state.parent)) ? state.parent : (isObject(state.parent) && isString(state.parent.name)) ? state.parent.name : '';
        if (parentName && !states[parentName]) {
          return queueState(parentName, state.self);
        }
        for (var key in stateBuilder) {
          if (isFunction(stateBuilder[key]))
            state[key] = stateBuilder[key](state, stateBuilder.$delegates[key]);
        }
        states[name] = state;
        if (!state[abstractKey] && state.url) {
          $urlRouterProvider.when(state.url, ['$match', '$stateParams', function($match, $stateParams) {
            if ($state.$current.navigable != state || !equalForKeys($match, $stateParams)) {
              $state.transitionTo(state, $match, {
                inherit: true,
                location: false
              });
            }
          }]);
        }
        flushQueuedChildren(name);
        return state;
      }
      function isGlob(text) {
        return text.indexOf('*') > -1;
      }
      function doesStateMatchGlob(glob) {
        var globSegments = glob.split('.'),
            segments = $state.$current.name.split('.');
        for (var i = 0,
            l = globSegments.length; i < l; i++) {
          if (globSegments[i] === '*') {
            segments[i] = '*';
          }
        }
        if (globSegments[0] === '**') {
          segments = segments.slice(indexOf(segments, globSegments[1]));
          segments.unshift('**');
        }
        if (globSegments[globSegments.length - 1] === '**') {
          segments.splice(indexOf(segments, globSegments[globSegments.length - 2]) + 1, Number.MAX_VALUE);
          segments.push('**');
        }
        if (globSegments.length != segments.length) {
          return false;
        }
        return segments.join('') === globSegments.join('');
      }
      root = registerState({
        name: '',
        url: '^',
        views: null,
        'abstract': true
      });
      root.navigable = null;
      this.decorator = decorator;
      function decorator(name, func) {
        if (isString(name) && !isDefined(func)) {
          return stateBuilder[name];
        }
        if (!isFunction(func) || !isString(name)) {
          return this;
        }
        if (stateBuilder[name] && !stateBuilder.$delegates[name]) {
          stateBuilder.$delegates[name] = stateBuilder[name];
        }
        stateBuilder[name] = func;
        return this;
      }
      this.state = state;
      function state(name, definition) {
        if (isObject(name))
          definition = name;
        else
          definition.name = name;
        registerState(definition);
        return this;
      }
      this.$get = $get;
      $get.$inject = ['$rootScope', '$q', '$view', '$injector', '$resolve', '$stateParams', '$urlRouter', '$location', '$urlMatcherFactory'];
      function $get($rootScope, $q, $view, $injector, $resolve, $stateParams, $urlRouter, $location, $urlMatcherFactory) {
        var TransitionSuperseded = $q.reject(new Error('transition superseded'));
        var TransitionPrevented = $q.reject(new Error('transition prevented'));
        var TransitionAborted = $q.reject(new Error('transition aborted'));
        var TransitionFailed = $q.reject(new Error('transition failed'));
        function handleRedirect(redirect, state, params, options) {
          var evt = $rootScope.$broadcast('$stateNotFound', redirect, state, params);
          if (evt.defaultPrevented) {
            $urlRouter.update();
            return TransitionAborted;
          }
          if (!evt.retry) {
            return null;
          }
          if (options.$retry) {
            $urlRouter.update();
            return TransitionFailed;
          }
          var retryTransition = $state.transition = $q.when(evt.retry);
          retryTransition.then(function() {
            if (retryTransition !== $state.transition)
              return TransitionSuperseded;
            redirect.options.$retry = true;
            return $state.transitionTo(redirect.to, redirect.toParams, redirect.options);
          }, function() {
            return TransitionAborted;
          });
          $urlRouter.update();
          return retryTransition;
        }
        root.locals = {
          resolve: null,
          globals: {$stateParams: {}}
        };
        $state = {
          params: {},
          current: root.self,
          $current: root,
          transition: null
        };
        $state.reload = function reload(state) {
          return $state.transitionTo($state.current, $stateParams, {
            reload: state || true,
            inherit: false,
            notify: true
          });
        };
        $state.go = function go(to, params, options) {
          return $state.transitionTo(to, params, extend({
            inherit: true,
            relative: $state.$current
          }, options));
        };
        $state.transitionTo = function transitionTo(to, toParams, options) {
          toParams = toParams || {};
          options = extend({
            location: true,
            inherit: false,
            relative: null,
            notify: true,
            reload: false,
            $retry: false
          }, options || {});
          var from = $state.$current,
              fromParams = $state.params,
              fromPath = from.path;
          var evt,
              toState = findState(to, options.relative);
          var hash = toParams['#'];
          if (!isDefined(toState)) {
            var redirect = {
              to: to,
              toParams: toParams,
              options: options
            };
            var redirectResult = handleRedirect(redirect, from.self, fromParams, options);
            if (redirectResult) {
              return redirectResult;
            }
            to = redirect.to;
            toParams = redirect.toParams;
            options = redirect.options;
            toState = findState(to, options.relative);
            if (!isDefined(toState)) {
              if (!options.relative)
                throw new Error("No such state '" + to + "'");
              throw new Error("Could not resolve '" + to + "' from state '" + options.relative + "'");
            }
          }
          if (toState[abstractKey])
            throw new Error("Cannot transition to abstract state '" + to + "'");
          if (options.inherit)
            toParams = inheritParams($stateParams, toParams || {}, $state.$current, toState);
          if (!toState.params.$$validates(toParams))
            return TransitionFailed;
          toParams = toState.params.$$values(toParams);
          to = toState;
          var toPath = to.path;
          var keep = 0,
              state = toPath[keep],
              locals = root.locals,
              toLocals = [];
          if (!options.reload) {
            while (state && state === fromPath[keep] && state.ownParams.$$equals(toParams, fromParams)) {
              locals = toLocals[keep] = state.locals;
              keep++;
              state = toPath[keep];
            }
          } else if (isString(options.reload) || isObject(options.reload)) {
            if (isObject(options.reload) && !options.reload.name) {
              throw new Error('Invalid reload state object');
            }
            var reloadState = options.reload === true ? fromPath[0] : findState(options.reload);
            if (options.reload && !reloadState) {
              throw new Error("No such reload state '" + (isString(options.reload) ? options.reload : options.reload.name) + "'");
            }
            while (state && state === fromPath[keep] && state !== reloadState) {
              locals = toLocals[keep] = state.locals;
              keep++;
              state = toPath[keep];
            }
          }
          if (shouldSkipReload(to, toParams, from, fromParams, locals, options)) {
            if (hash)
              toParams['#'] = hash;
            $state.params = toParams;
            copy($state.params, $stateParams);
            copy(filterByKeys(to.params.$$keys(), $stateParams), to.locals.globals.$stateParams);
            if (options.location && to.navigable && to.navigable.url) {
              $urlRouter.push(to.navigable.url, toParams, {
                $$avoidResync: true,
                replace: options.location === 'replace'
              });
              $urlRouter.update(true);
            }
            $state.transition = null;
            return $q.when($state.current);
          }
          toParams = filterByKeys(to.params.$$keys(), toParams || {});
          if (hash)
            toParams['#'] = hash;
          if (options.notify) {
            if ($rootScope.$broadcast('$stateChangeStart', to.self, toParams, from.self, fromParams, options).defaultPrevented) {
              $rootScope.$broadcast('$stateChangeCancel', to.self, toParams, from.self, fromParams);
              if ($state.transition == null)
                $urlRouter.update();
              return TransitionPrevented;
            }
          }
          var resolved = $q.when(locals);
          for (var l = keep; l < toPath.length; l++, state = toPath[l]) {
            locals = toLocals[l] = inherit(locals);
            resolved = resolveState(state, toParams, state === to, resolved, locals, options);
          }
          var transition = $state.transition = resolved.then(function() {
            var l,
                entering,
                exiting;
            if ($state.transition !== transition)
              return TransitionSuperseded;
            for (l = fromPath.length - 1; l >= keep; l--) {
              exiting = fromPath[l];
              if (exiting.self.onExit) {
                $injector.invoke(exiting.self.onExit, exiting.self, exiting.locals.globals);
              }
              exiting.locals = null;
            }
            for (l = keep; l < toPath.length; l++) {
              entering = toPath[l];
              entering.locals = toLocals[l];
              if (entering.self.onEnter) {
                $injector.invoke(entering.self.onEnter, entering.self, entering.locals.globals);
              }
            }
            if ($state.transition !== transition)
              return TransitionSuperseded;
            $state.$current = to;
            $state.current = to.self;
            $state.params = toParams;
            copy($state.params, $stateParams);
            $state.transition = null;
            if (options.location && to.navigable) {
              $urlRouter.push(to.navigable.url, to.navigable.locals.globals.$stateParams, {
                $$avoidResync: true,
                replace: options.location === 'replace'
              });
            }
            if (options.notify) {
              $rootScope.$broadcast('$stateChangeSuccess', to.self, toParams, from.self, fromParams);
            }
            $urlRouter.update(true);
            return $state.current;
          }).then(null, function(error) {
            if ($state.transition !== transition)
              return TransitionSuperseded;
            $state.transition = null;
            evt = $rootScope.$broadcast('$stateChangeError', to.self, toParams, from.self, fromParams, error);
            if (!evt.defaultPrevented) {
              $urlRouter.update();
            }
            return $q.reject(error);
          });
          return transition;
        };
        $state.is = function is(stateOrName, params, options) {
          options = extend({relative: $state.$current}, options || {});
          var state = findState(stateOrName, options.relative);
          if (!isDefined(state)) {
            return undefined;
          }
          if ($state.$current !== state) {
            return false;
          }
          return params ? equalForKeys(state.params.$$values(params), $stateParams) : true;
        };
        $state.includes = function includes(stateOrName, params, options) {
          options = extend({relative: $state.$current}, options || {});
          if (isString(stateOrName) && isGlob(stateOrName)) {
            if (!doesStateMatchGlob(stateOrName)) {
              return false;
            }
            stateOrName = $state.$current.name;
          }
          var state = findState(stateOrName, options.relative);
          if (!isDefined(state)) {
            return undefined;
          }
          if (!isDefined($state.$current.includes[state.name])) {
            return false;
          }
          return params ? equalForKeys(state.params.$$values(params), $stateParams, objectKeys(params)) : true;
        };
        $state.href = function href(stateOrName, params, options) {
          options = extend({
            lossy: true,
            inherit: true,
            absolute: false,
            relative: $state.$current
          }, options || {});
          var state = findState(stateOrName, options.relative);
          if (!isDefined(state))
            return null;
          if (options.inherit)
            params = inheritParams($stateParams, params || {}, $state.$current, state);
          var nav = (state && options.lossy) ? state.navigable : state;
          if (!nav || nav.url === undefined || nav.url === null) {
            return null;
          }
          return $urlRouter.href(nav.url, filterByKeys(state.params.$$keys().concat('#'), params || {}), {absolute: options.absolute});
        };
        $state.get = function(stateOrName, context) {
          if (arguments.length === 0)
            return map(objectKeys(states), function(name) {
              return states[name].self;
            });
          var state = findState(stateOrName, context || $state.$current);
          return (state && state.self) ? state.self : null;
        };
        function resolveState(state, params, paramsAreFiltered, inherited, dst, options) {
          var $stateParams = (paramsAreFiltered) ? params : filterByKeys(state.params.$$keys(), params);
          var locals = {$stateParams: $stateParams};
          dst.resolve = $resolve.resolve(state.resolve, locals, dst.resolve, state);
          var promises = [dst.resolve.then(function(globals) {
            dst.globals = globals;
          })];
          if (inherited)
            promises.push(inherited);
          function resolveViews() {
            var viewsPromises = [];
            forEach(state.views, function(view, name) {
              var injectables = (view.resolve && view.resolve !== state.resolve ? view.resolve : {});
              injectables.$template = [function() {
                return $view.load(name, {
                  view: view,
                  locals: dst.globals,
                  params: $stateParams,
                  notify: options.notify
                }) || '';
              }];
              viewsPromises.push($resolve.resolve(injectables, dst.globals, dst.resolve, state).then(function(result) {
                if (isFunction(view.controllerProvider) || isArray(view.controllerProvider)) {
                  var injectLocals = angular.extend({}, injectables, dst.globals);
                  result.$$controller = $injector.invoke(view.controllerProvider, null, injectLocals);
                } else {
                  result.$$controller = view.controller;
                }
                result.$$state = state;
                result.$$controllerAs = view.controllerAs;
                result.$$resolveAs = view.resolveAs;
                dst[name] = result;
              }));
            });
            return $q.all(viewsPromises).then(function() {
              return dst.globals;
            });
          }
          return $q.all(promises).then(resolveViews).then(function(values) {
            return dst;
          });
        }
        return $state;
      }
      function shouldSkipReload(to, toParams, from, fromParams, locals, options) {
        function nonSearchParamsEqual(fromAndToState, fromParams, toParams) {
          function notSearchParam(key) {
            return fromAndToState.params[key].location != "search";
          }
          var nonQueryParamKeys = fromAndToState.params.$$keys().filter(notSearchParam);
          var nonQueryParams = pick.apply({}, [fromAndToState.params].concat(nonQueryParamKeys));
          var nonQueryParamSet = new $$UMFP.ParamSet(nonQueryParams);
          return nonQueryParamSet.$$equals(fromParams, toParams);
        }
        if (!options.reload && to === from && (locals === from.locals || (to.self.reloadOnSearch === false && nonSearchParamsEqual(from, fromParams, toParams)))) {
          return true;
        }
      }
    }
    angular.module('ui.router.state').factory('$stateParams', function() {
      return {};
    }).constant("$state.runtime", {autoinject: true}).provider('$state', $StateProvider).run(['$injector', function($injector) {
      if ($injector.get("$state.runtime").autoinject) {
        $injector.get('$state');
      }
    }]);
    $ViewProvider.$inject = [];
    function $ViewProvider() {
      this.$get = $get;
      $get.$inject = ['$rootScope', '$templateFactory'];
      function $get($rootScope, $templateFactory) {
        return {load: function load(name, options) {
            var result,
                defaults = {
                  template: null,
                  controller: null,
                  view: null,
                  locals: null,
                  notify: true,
                  async: true,
                  params: {}
                };
            options = extend(defaults, options);
            if (options.view) {
              result = $templateFactory.fromConfig(options.view, options.params, options.locals);
            }
            return result;
          }};
      }
    }
    angular.module('ui.router.state').provider('$view', $ViewProvider);
    function $ViewScrollProvider() {
      var useAnchorScroll = false;
      this.useAnchorScroll = function() {
        useAnchorScroll = true;
      };
      this.$get = ['$anchorScroll', '$timeout', function($anchorScroll, $timeout) {
        if (useAnchorScroll) {
          return $anchorScroll;
        }
        return function($element) {
          return $timeout(function() {
            $element[0].scrollIntoView();
          }, 0, false);
        };
      }];
    }
    angular.module('ui.router.state').provider('$uiViewScroll', $ViewScrollProvider);
    $ViewDirective.$inject = ['$state', '$injector', '$uiViewScroll', '$interpolate', '$q'];
    function $ViewDirective($state, $injector, $uiViewScroll, $interpolate, $q) {
      function getService() {
        return ($injector.has) ? function(service) {
          return $injector.has(service) ? $injector.get(service) : null;
        } : function(service) {
          try {
            return $injector.get(service);
          } catch (e) {
            return null;
          }
        };
      }
      var service = getService(),
          $animator = service('$animator'),
          $animate = service('$animate');
      function getRenderer(attrs, scope) {
        var statics = function() {
          return {
            enter: function(element, target, cb) {
              target.after(element);
              cb();
            },
            leave: function(element, cb) {
              element.remove();
              cb();
            }
          };
        };
        if ($animate) {
          return {
            enter: function(element, target, cb) {
              if (angular.version.minor > 2) {
                $animate.enter(element, null, target).then(cb);
              } else {
                $animate.enter(element, null, target, cb);
              }
            },
            leave: function(element, cb) {
              if (angular.version.minor > 2) {
                $animate.leave(element).then(cb);
              } else {
                $animate.leave(element, cb);
              }
            }
          };
        }
        if ($animator) {
          var animate = $animator && $animator(scope, attrs);
          return {
            enter: function(element, target, cb) {
              animate.enter(element, null, target);
              cb();
            },
            leave: function(element, cb) {
              animate.leave(element);
              cb();
            }
          };
        }
        return statics();
      }
      var directive = {
        restrict: 'ECA',
        terminal: true,
        priority: 400,
        transclude: 'element',
        compile: function(tElement, tAttrs, $transclude) {
          return function(scope, $element, attrs) {
            var previousEl,
                currentEl,
                currentScope,
                latestLocals,
                onloadExp = attrs.onload || '',
                autoScrollExp = attrs.autoscroll,
                renderer = getRenderer(attrs, scope),
                inherited = $element.inheritedData('$uiView');
            scope.$on('$stateChangeSuccess', function() {
              updateView(false);
            });
            updateView(true);
            function cleanupLastView() {
              if (previousEl) {
                previousEl.remove();
                previousEl = null;
              }
              if (currentScope) {
                currentScope.$destroy();
                currentScope = null;
              }
              if (currentEl) {
                var $uiViewData = currentEl.data('$uiViewAnim');
                renderer.leave(currentEl, function() {
                  $uiViewData.$$animLeave.resolve();
                  previousEl = null;
                });
                previousEl = currentEl;
                currentEl = null;
              }
            }
            function updateView(firstTime) {
              var newScope,
                  name = getUiViewName(scope, attrs, $element, $interpolate),
                  previousLocals = name && $state.$current && $state.$current.locals[name];
              if (!firstTime && previousLocals === latestLocals)
                return;
              newScope = scope.$new();
              latestLocals = $state.$current.locals[name];
              newScope.$emit('$viewContentLoading', name);
              var clone = $transclude(newScope, function(clone) {
                var animEnter = $q.defer(),
                    animLeave = $q.defer();
                var viewAnimData = {
                  $animEnter: animEnter.promise,
                  $animLeave: animLeave.promise,
                  $$animLeave: animLeave
                };
                clone.data('$uiViewAnim', viewAnimData);
                renderer.enter(clone, $element, function onUiViewEnter() {
                  animEnter.resolve();
                  if (currentScope) {
                    currentScope.$emit('$viewContentAnimationEnded');
                  }
                  if (angular.isDefined(autoScrollExp) && !autoScrollExp || scope.$eval(autoScrollExp)) {
                    $uiViewScroll(clone);
                  }
                });
                cleanupLastView();
              });
              currentEl = clone;
              currentScope = newScope;
              currentScope.$emit('$viewContentLoaded', name);
              currentScope.$eval(onloadExp);
            }
          };
        }
      };
      return directive;
    }
    $ViewDirectiveFill.$inject = ['$compile', '$controller', '$state', '$interpolate'];
    function $ViewDirectiveFill($compile, $controller, $state, $interpolate) {
      return {
        restrict: 'ECA',
        priority: -400,
        compile: function(tElement) {
          var initial = tElement.html();
          return function(scope, $element, attrs) {
            var current = $state.$current,
                name = getUiViewName(scope, attrs, $element, $interpolate),
                locals = current && current.locals[name];
            if (!locals) {
              return;
            }
            $element.data('$uiView', {
              name: name,
              state: locals.$$state
            });
            $element.html(locals.$template ? locals.$template : initial);
            var resolveData = angular.extend({}, locals);
            scope[locals.$$resolveAs] = resolveData;
            var link = $compile($element.contents());
            if (locals.$$controller) {
              locals.$scope = scope;
              locals.$element = $element;
              var controller = $controller(locals.$$controller, locals);
              if (locals.$$controllerAs) {
                scope[locals.$$controllerAs] = controller;
                scope[locals.$$controllerAs][locals.$$resolveAs] = resolveData;
              }
              if (isFunction(controller.$onInit))
                controller.$onInit();
              $element.data('$ngControllerController', controller);
              $element.children().data('$ngControllerController', controller);
            }
            link(scope);
          };
        }
      };
    }
    function getUiViewName(scope, attrs, element, $interpolate) {
      var name = $interpolate(attrs.uiView || attrs.name || '')(scope);
      var uiViewCreatedBy = element.inheritedData('$uiView');
      return name.indexOf('@') >= 0 ? name : (name + '@' + (uiViewCreatedBy ? uiViewCreatedBy.state.name : ''));
    }
    angular.module('ui.router.state').directive('uiView', $ViewDirective);
    angular.module('ui.router.state').directive('uiView', $ViewDirectiveFill);
    function parseStateRef(ref, current) {
      var preparsed = ref.match(/^\s*({[^}]*})\s*$/),
          parsed;
      if (preparsed)
        ref = current + '(' + preparsed[1] + ')';
      parsed = ref.replace(/\n/g, " ").match(/^([^(]+?)\s*(\((.*)\))?$/);
      if (!parsed || parsed.length !== 4)
        throw new Error("Invalid state ref '" + ref + "'");
      return {
        state: parsed[1],
        paramExpr: parsed[3] || null
      };
    }
    function stateContext(el) {
      var stateData = el.parent().inheritedData('$uiView');
      if (stateData && stateData.state && stateData.state.name) {
        return stateData.state;
      }
    }
    function getTypeInfo(el) {
      var isSvg = Object.prototype.toString.call(el.prop('href')) === '[object SVGAnimatedString]';
      var isForm = el[0].nodeName === "FORM";
      return {
        attr: isForm ? "action" : (isSvg ? 'xlink:href' : 'href'),
        isAnchor: el.prop("tagName").toUpperCase() === "A",
        clickable: !isForm
      };
    }
    function clickHook(el, $state, $timeout, type, current) {
      return function(e) {
        var button = e.which || e.button,
            target = current();
        if (!(button > 1 || e.ctrlKey || e.metaKey || e.shiftKey || el.attr('target'))) {
          var transition = $timeout(function() {
            $state.go(target.state, target.params, target.options);
          });
          e.preventDefault();
          var ignorePreventDefaultCount = type.isAnchor && !target.href ? 1 : 0;
          e.preventDefault = function() {
            if (ignorePreventDefaultCount-- <= 0)
              $timeout.cancel(transition);
          };
        }
      };
    }
    function defaultOpts(el, $state) {
      return {
        relative: stateContext(el) || $state.$current,
        inherit: true
      };
    }
    $StateRefDirective.$inject = ['$state', '$timeout'];
    function $StateRefDirective($state, $timeout) {
      return {
        restrict: 'A',
        require: ['?^uiSrefActive', '?^uiSrefActiveEq'],
        link: function(scope, element, attrs, uiSrefActive) {
          var ref = parseStateRef(attrs.uiSref, $state.current.name);
          var def = {
            state: ref.state,
            href: null,
            params: null
          };
          var type = getTypeInfo(element);
          var active = uiSrefActive[1] || uiSrefActive[0];
          var unlinkInfoFn = null;
          var hookFn;
          def.options = extend(defaultOpts(element, $state), attrs.uiSrefOpts ? scope.$eval(attrs.uiSrefOpts) : {});
          var update = function(val) {
            if (val)
              def.params = angular.copy(val);
            def.href = $state.href(ref.state, def.params, def.options);
            if (unlinkInfoFn)
              unlinkInfoFn();
            if (active)
              unlinkInfoFn = active.$$addStateInfo(ref.state, def.params);
            if (def.href !== null)
              attrs.$set(type.attr, def.href);
          };
          if (ref.paramExpr) {
            scope.$watch(ref.paramExpr, function(val) {
              if (val !== def.params)
                update(val);
            }, true);
            def.params = angular.copy(scope.$eval(ref.paramExpr));
          }
          update();
          if (!type.clickable)
            return;
          hookFn = clickHook(element, $state, $timeout, type, function() {
            return def;
          });
          element.bind("click", hookFn);
          scope.$on('$destroy', function() {
            element.unbind("click", hookFn);
          });
        }
      };
    }
    $StateRefDynamicDirective.$inject = ['$state', '$timeout'];
    function $StateRefDynamicDirective($state, $timeout) {
      return {
        restrict: 'A',
        require: ['?^uiSrefActive', '?^uiSrefActiveEq'],
        link: function(scope, element, attrs, uiSrefActive) {
          var type = getTypeInfo(element);
          var active = uiSrefActive[1] || uiSrefActive[0];
          var group = [attrs.uiState, attrs.uiStateParams || null, attrs.uiStateOpts || null];
          var watch = '[' + group.map(function(val) {
            return val || 'null';
          }).join(', ') + ']';
          var def = {
            state: null,
            params: null,
            options: null,
            href: null
          };
          var unlinkInfoFn = null;
          var hookFn;
          function runStateRefLink(group) {
            def.state = group[0];
            def.params = group[1];
            def.options = group[2];
            def.href = $state.href(def.state, def.params, def.options);
            if (unlinkInfoFn)
              unlinkInfoFn();
            if (active)
              unlinkInfoFn = active.$$addStateInfo(def.state, def.params);
            if (def.href)
              attrs.$set(type.attr, def.href);
          }
          scope.$watch(watch, runStateRefLink, true);
          runStateRefLink(scope.$eval(watch));
          if (!type.clickable)
            return;
          hookFn = clickHook(element, $state, $timeout, type, function() {
            return def;
          });
          element.bind("click", hookFn);
          scope.$on('$destroy', function() {
            element.unbind("click", hookFn);
          });
        }
      };
    }
    $StateRefActiveDirective.$inject = ['$state', '$stateParams', '$interpolate'];
    function $StateRefActiveDirective($state, $stateParams, $interpolate) {
      return {
        restrict: "A",
        controller: ['$scope', '$element', '$attrs', '$timeout', function($scope, $element, $attrs, $timeout) {
          var states = [],
              activeClasses = {},
              activeEqClass,
              uiSrefActive;
          activeEqClass = $interpolate($attrs.uiSrefActiveEq || '', false)($scope);
          try {
            uiSrefActive = $scope.$eval($attrs.uiSrefActive);
          } catch (e) {}
          uiSrefActive = uiSrefActive || $interpolate($attrs.uiSrefActive || '', false)($scope);
          if (isObject(uiSrefActive)) {
            forEach(uiSrefActive, function(stateOrName, activeClass) {
              if (isString(stateOrName)) {
                var ref = parseStateRef(stateOrName, $state.current.name);
                addState(ref.state, $scope.$eval(ref.paramExpr), activeClass);
              }
            });
          }
          this.$$addStateInfo = function(newState, newParams) {
            if (isObject(uiSrefActive) && states.length > 0) {
              return;
            }
            var deregister = addState(newState, newParams, uiSrefActive);
            update();
            return deregister;
          };
          $scope.$on('$stateChangeSuccess', update);
          function addState(stateName, stateParams, activeClass) {
            var state = $state.get(stateName, stateContext($element));
            var stateHash = createStateHash(stateName, stateParams);
            var stateInfo = {
              state: state || {name: stateName},
              params: stateParams,
              hash: stateHash
            };
            states.push(stateInfo);
            activeClasses[stateHash] = activeClass;
            return function removeState() {
              var idx = states.indexOf(stateInfo);
              if (idx !== -1)
                states.splice(idx, 1);
            };
          }
          function createStateHash(state, params) {
            if (!isString(state)) {
              throw new Error('state should be a string');
            }
            if (isObject(params)) {
              return state + toJson(params);
            }
            params = $scope.$eval(params);
            if (isObject(params)) {
              return state + toJson(params);
            }
            return state;
          }
          function update() {
            for (var i = 0; i < states.length; i++) {
              if (anyMatch(states[i].state, states[i].params)) {
                addClass($element, activeClasses[states[i].hash]);
              } else {
                removeClass($element, activeClasses[states[i].hash]);
              }
              if (exactMatch(states[i].state, states[i].params)) {
                addClass($element, activeEqClass);
              } else {
                removeClass($element, activeEqClass);
              }
            }
          }
          function addClass(el, className) {
            $timeout(function() {
              el.addClass(className);
            });
          }
          function removeClass(el, className) {
            el.removeClass(className);
          }
          function anyMatch(state, params) {
            return $state.includes(state.name, params);
          }
          function exactMatch(state, params) {
            return $state.is(state.name, params);
          }
          update();
        }]
      };
    }
    angular.module('ui.router.state').directive('uiSref', $StateRefDirective).directive('uiSrefActive', $StateRefActiveDirective).directive('uiSrefActiveEq', $StateRefActiveDirective).directive('uiState', $StateRefDynamicDirective);
    $IsStateFilter.$inject = ['$state'];
    function $IsStateFilter($state) {
      var isFilter = function(state, params) {
        return $state.is(state, params);
      };
      isFilter.$stateful = true;
      return isFilter;
    }
    $IncludedByStateFilter.$inject = ['$state'];
    function $IncludedByStateFilter($state) {
      var includesFilter = function(state, params, options) {
        return $state.includes(state, params, options);
      };
      includesFilter.$stateful = true;
      return includesFilter;
    }
    angular.module('ui.router.state').filter('isState', $IsStateFilter).filter('includedByState', $IncludedByStateFilter);
  })(window, window.angular);
  global.define = __define;
  return module.exports;
});

System.registerDynamic("github:angular-ui/angular-ui-router-bower@0.3.1.js", ["github:angular-ui/angular-ui-router-bower@0.3.1/release/angular-ui-router.js"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = $__require('github:angular-ui/angular-ui-router-bower@0.3.1/release/angular-ui-router.js');
  global.define = __define;
  return module.exports;
});

System.registerDynamic("github:angular/bower-angular-animate@1.5.7/angular-animate.js", ["github:angular/bower-angular@1.5.7.js"], false, function(__require, __exports, __module) {
  var _retrieveGlobal = System.get("@@global-helpers").prepareGlobal(__module.id, null, null);
  (function() {
    "format global";
    "deps angular";
    (function(window, angular) {
      'use strict';
      var noop = angular.noop;
      var copy = angular.copy;
      var extend = angular.extend;
      var jqLite = angular.element;
      var forEach = angular.forEach;
      var isArray = angular.isArray;
      var isString = angular.isString;
      var isObject = angular.isObject;
      var isUndefined = angular.isUndefined;
      var isDefined = angular.isDefined;
      var isFunction = angular.isFunction;
      var isElement = angular.isElement;
      var ELEMENT_NODE = 1;
      var COMMENT_NODE = 8;
      var ADD_CLASS_SUFFIX = '-add';
      var REMOVE_CLASS_SUFFIX = '-remove';
      var EVENT_CLASS_PREFIX = 'ng-';
      var ACTIVE_CLASS_SUFFIX = '-active';
      var PREPARE_CLASS_SUFFIX = '-prepare';
      var NG_ANIMATE_CLASSNAME = 'ng-animate';
      var NG_ANIMATE_CHILDREN_DATA = '$$ngAnimateChildren';
      var CSS_PREFIX = '',
          TRANSITION_PROP,
          TRANSITIONEND_EVENT,
          ANIMATION_PROP,
          ANIMATIONEND_EVENT;
      if (isUndefined(window.ontransitionend) && isDefined(window.onwebkittransitionend)) {
        CSS_PREFIX = '-webkit-';
        TRANSITION_PROP = 'WebkitTransition';
        TRANSITIONEND_EVENT = 'webkitTransitionEnd transitionend';
      } else {
        TRANSITION_PROP = 'transition';
        TRANSITIONEND_EVENT = 'transitionend';
      }
      if (isUndefined(window.onanimationend) && isDefined(window.onwebkitanimationend)) {
        CSS_PREFIX = '-webkit-';
        ANIMATION_PROP = 'WebkitAnimation';
        ANIMATIONEND_EVENT = 'webkitAnimationEnd animationend';
      } else {
        ANIMATION_PROP = 'animation';
        ANIMATIONEND_EVENT = 'animationend';
      }
      var DURATION_KEY = 'Duration';
      var PROPERTY_KEY = 'Property';
      var DELAY_KEY = 'Delay';
      var TIMING_KEY = 'TimingFunction';
      var ANIMATION_ITERATION_COUNT_KEY = 'IterationCount';
      var ANIMATION_PLAYSTATE_KEY = 'PlayState';
      var SAFE_FAST_FORWARD_DURATION_VALUE = 9999;
      var ANIMATION_DELAY_PROP = ANIMATION_PROP + DELAY_KEY;
      var ANIMATION_DURATION_PROP = ANIMATION_PROP + DURATION_KEY;
      var TRANSITION_DELAY_PROP = TRANSITION_PROP + DELAY_KEY;
      var TRANSITION_DURATION_PROP = TRANSITION_PROP + DURATION_KEY;
      var isPromiseLike = function(p) {
        return p && p.then ? true : false;
      };
      var ngMinErr = angular.$$minErr('ng');
      function assertArg(arg, name, reason) {
        if (!arg) {
          throw ngMinErr('areq', "Argument '{0}' is {1}", (name || '?'), (reason || "required"));
        }
        return arg;
      }
      function mergeClasses(a, b) {
        if (!a && !b)
          return '';
        if (!a)
          return b;
        if (!b)
          return a;
        if (isArray(a))
          a = a.join(' ');
        if (isArray(b))
          b = b.join(' ');
        return a + ' ' + b;
      }
      function packageStyles(options) {
        var styles = {};
        if (options && (options.to || options.from)) {
          styles.to = options.to;
          styles.from = options.from;
        }
        return styles;
      }
      function pendClasses(classes, fix, isPrefix) {
        var className = '';
        classes = isArray(classes) ? classes : classes && isString(classes) && classes.length ? classes.split(/\s+/) : [];
        forEach(classes, function(klass, i) {
          if (klass && klass.length > 0) {
            className += (i > 0) ? ' ' : '';
            className += isPrefix ? fix + klass : klass + fix;
          }
        });
        return className;
      }
      function removeFromArray(arr, val) {
        var index = arr.indexOf(val);
        if (val >= 0) {
          arr.splice(index, 1);
        }
      }
      function stripCommentsFromElement(element) {
        if (element instanceof jqLite) {
          switch (element.length) {
            case 0:
              return element;
              break;
            case 1:
              if (element[0].nodeType === ELEMENT_NODE) {
                return element;
              }
              break;
            default:
              return jqLite(extractElementNode(element));
              break;
          }
        }
        if (element.nodeType === ELEMENT_NODE) {
          return jqLite(element);
        }
      }
      function extractElementNode(element) {
        if (!element[0])
          return element;
        for (var i = 0; i < element.length; i++) {
          var elm = element[i];
          if (elm.nodeType == ELEMENT_NODE) {
            return elm;
          }
        }
      }
      function $$addClass($$jqLite, element, className) {
        forEach(element, function(elm) {
          $$jqLite.addClass(elm, className);
        });
      }
      function $$removeClass($$jqLite, element, className) {
        forEach(element, function(elm) {
          $$jqLite.removeClass(elm, className);
        });
      }
      function applyAnimationClassesFactory($$jqLite) {
        return function(element, options) {
          if (options.addClass) {
            $$addClass($$jqLite, element, options.addClass);
            options.addClass = null;
          }
          if (options.removeClass) {
            $$removeClass($$jqLite, element, options.removeClass);
            options.removeClass = null;
          }
        };
      }
      function prepareAnimationOptions(options) {
        options = options || {};
        if (!options.$$prepared) {
          var domOperation = options.domOperation || noop;
          options.domOperation = function() {
            options.$$domOperationFired = true;
            domOperation();
            domOperation = noop;
          };
          options.$$prepared = true;
        }
        return options;
      }
      function applyAnimationStyles(element, options) {
        applyAnimationFromStyles(element, options);
        applyAnimationToStyles(element, options);
      }
      function applyAnimationFromStyles(element, options) {
        if (options.from) {
          element.css(options.from);
          options.from = null;
        }
      }
      function applyAnimationToStyles(element, options) {
        if (options.to) {
          element.css(options.to);
          options.to = null;
        }
      }
      function mergeAnimationDetails(element, oldAnimation, newAnimation) {
        var target = oldAnimation.options || {};
        var newOptions = newAnimation.options || {};
        var toAdd = (target.addClass || '') + ' ' + (newOptions.addClass || '');
        var toRemove = (target.removeClass || '') + ' ' + (newOptions.removeClass || '');
        var classes = resolveElementClasses(element.attr('class'), toAdd, toRemove);
        if (newOptions.preparationClasses) {
          target.preparationClasses = concatWithSpace(newOptions.preparationClasses, target.preparationClasses);
          delete newOptions.preparationClasses;
        }
        var realDomOperation = target.domOperation !== noop ? target.domOperation : null;
        extend(target, newOptions);
        if (realDomOperation) {
          target.domOperation = realDomOperation;
        }
        if (classes.addClass) {
          target.addClass = classes.addClass;
        } else {
          target.addClass = null;
        }
        if (classes.removeClass) {
          target.removeClass = classes.removeClass;
        } else {
          target.removeClass = null;
        }
        oldAnimation.addClass = target.addClass;
        oldAnimation.removeClass = target.removeClass;
        return target;
      }
      function resolveElementClasses(existing, toAdd, toRemove) {
        var ADD_CLASS = 1;
        var REMOVE_CLASS = -1;
        var flags = {};
        existing = splitClassesToLookup(existing);
        toAdd = splitClassesToLookup(toAdd);
        forEach(toAdd, function(value, key) {
          flags[key] = ADD_CLASS;
        });
        toRemove = splitClassesToLookup(toRemove);
        forEach(toRemove, function(value, key) {
          flags[key] = flags[key] === ADD_CLASS ? null : REMOVE_CLASS;
        });
        var classes = {
          addClass: '',
          removeClass: ''
        };
        forEach(flags, function(val, klass) {
          var prop,
              allow;
          if (val === ADD_CLASS) {
            prop = 'addClass';
            allow = !existing[klass];
          } else if (val === REMOVE_CLASS) {
            prop = 'removeClass';
            allow = existing[klass];
          }
          if (allow) {
            if (classes[prop].length) {
              classes[prop] += ' ';
            }
            classes[prop] += klass;
          }
        });
        function splitClassesToLookup(classes) {
          if (isString(classes)) {
            classes = classes.split(' ');
          }
          var obj = {};
          forEach(classes, function(klass) {
            if (klass.length) {
              obj[klass] = true;
            }
          });
          return obj;
        }
        return classes;
      }
      function getDomNode(element) {
        return (element instanceof angular.element) ? element[0] : element;
      }
      function applyGeneratedPreparationClasses(element, event, options) {
        var classes = '';
        if (event) {
          classes = pendClasses(event, EVENT_CLASS_PREFIX, true);
        }
        if (options.addClass) {
          classes = concatWithSpace(classes, pendClasses(options.addClass, ADD_CLASS_SUFFIX));
        }
        if (options.removeClass) {
          classes = concatWithSpace(classes, pendClasses(options.removeClass, REMOVE_CLASS_SUFFIX));
        }
        if (classes.length) {
          options.preparationClasses = classes;
          element.addClass(classes);
        }
      }
      function clearGeneratedClasses(element, options) {
        if (options.preparationClasses) {
          element.removeClass(options.preparationClasses);
          options.preparationClasses = null;
        }
        if (options.activeClasses) {
          element.removeClass(options.activeClasses);
          options.activeClasses = null;
        }
      }
      function blockTransitions(node, duration) {
        var value = duration ? '-' + duration + 's' : '';
        applyInlineStyle(node, [TRANSITION_DELAY_PROP, value]);
        return [TRANSITION_DELAY_PROP, value];
      }
      function blockKeyframeAnimations(node, applyBlock) {
        var value = applyBlock ? 'paused' : '';
        var key = ANIMATION_PROP + ANIMATION_PLAYSTATE_KEY;
        applyInlineStyle(node, [key, value]);
        return [key, value];
      }
      function applyInlineStyle(node, styleTuple) {
        var prop = styleTuple[0];
        var value = styleTuple[1];
        node.style[prop] = value;
      }
      function concatWithSpace(a, b) {
        if (!a)
          return b;
        if (!b)
          return a;
        return a + ' ' + b;
      }
      var $$rAFSchedulerFactory = ['$$rAF', function($$rAF) {
        var queue,
            cancelFn;
        function scheduler(tasks) {
          queue = queue.concat(tasks);
          nextTick();
        }
        queue = scheduler.queue = [];
        scheduler.waitUntilQuiet = function(fn) {
          if (cancelFn)
            cancelFn();
          cancelFn = $$rAF(function() {
            cancelFn = null;
            fn();
            nextTick();
          });
        };
        return scheduler;
        function nextTick() {
          if (!queue.length)
            return;
          var items = queue.shift();
          for (var i = 0; i < items.length; i++) {
            items[i]();
          }
          if (!cancelFn) {
            $$rAF(function() {
              if (!cancelFn)
                nextTick();
            });
          }
        }
      }];
      var $$AnimateChildrenDirective = ['$interpolate', function($interpolate) {
        return {link: function(scope, element, attrs) {
            var val = attrs.ngAnimateChildren;
            if (angular.isString(val) && val.length === 0) {
              element.data(NG_ANIMATE_CHILDREN_DATA, true);
            } else {
              setData($interpolate(val)(scope));
              attrs.$observe('ngAnimateChildren', setData);
            }
            function setData(value) {
              value = value === 'on' || value === 'true';
              element.data(NG_ANIMATE_CHILDREN_DATA, value);
            }
          }};
      }];
      var ANIMATE_TIMER_KEY = '$$animateCss';
      var ONE_SECOND = 1000;
      var BASE_TEN = 10;
      var ELAPSED_TIME_MAX_DECIMAL_PLACES = 3;
      var CLOSING_TIME_BUFFER = 1.5;
      var DETECT_CSS_PROPERTIES = {
        transitionDuration: TRANSITION_DURATION_PROP,
        transitionDelay: TRANSITION_DELAY_PROP,
        transitionProperty: TRANSITION_PROP + PROPERTY_KEY,
        animationDuration: ANIMATION_DURATION_PROP,
        animationDelay: ANIMATION_DELAY_PROP,
        animationIterationCount: ANIMATION_PROP + ANIMATION_ITERATION_COUNT_KEY
      };
      var DETECT_STAGGER_CSS_PROPERTIES = {
        transitionDuration: TRANSITION_DURATION_PROP,
        transitionDelay: TRANSITION_DELAY_PROP,
        animationDuration: ANIMATION_DURATION_PROP,
        animationDelay: ANIMATION_DELAY_PROP
      };
      function getCssKeyframeDurationStyle(duration) {
        return [ANIMATION_DURATION_PROP, duration + 's'];
      }
      function getCssDelayStyle(delay, isKeyframeAnimation) {
        var prop = isKeyframeAnimation ? ANIMATION_DELAY_PROP : TRANSITION_DELAY_PROP;
        return [prop, delay + 's'];
      }
      function computeCssStyles($window, element, properties) {
        var styles = Object.create(null);
        var detectedStyles = $window.getComputedStyle(element) || {};
        forEach(properties, function(formalStyleName, actualStyleName) {
          var val = detectedStyles[formalStyleName];
          if (val) {
            var c = val.charAt(0);
            if (c === '-' || c === '+' || c >= 0) {
              val = parseMaxTime(val);
            }
            if (val === 0) {
              val = null;
            }
            styles[actualStyleName] = val;
          }
        });
        return styles;
      }
      function parseMaxTime(str) {
        var maxValue = 0;
        var values = str.split(/\s*,\s*/);
        forEach(values, function(value) {
          if (value.charAt(value.length - 1) == 's') {
            value = value.substring(0, value.length - 1);
          }
          value = parseFloat(value) || 0;
          maxValue = maxValue ? Math.max(value, maxValue) : value;
        });
        return maxValue;
      }
      function truthyTimingValue(val) {
        return val === 0 || val != null;
      }
      function getCssTransitionDurationStyle(duration, applyOnlyDuration) {
        var style = TRANSITION_PROP;
        var value = duration + 's';
        if (applyOnlyDuration) {
          style += DURATION_KEY;
        } else {
          value += ' linear all';
        }
        return [style, value];
      }
      function createLocalCacheLookup() {
        var cache = Object.create(null);
        return {
          flush: function() {
            cache = Object.create(null);
          },
          count: function(key) {
            var entry = cache[key];
            return entry ? entry.total : 0;
          },
          get: function(key) {
            var entry = cache[key];
            return entry && entry.value;
          },
          put: function(key, value) {
            if (!cache[key]) {
              cache[key] = {
                total: 1,
                value: value
              };
            } else {
              cache[key].total++;
            }
          }
        };
      }
      function registerRestorableStyles(backup, node, properties) {
        forEach(properties, function(prop) {
          backup[prop] = isDefined(backup[prop]) ? backup[prop] : node.style.getPropertyValue(prop);
        });
      }
      var $AnimateCssProvider = ['$animateProvider', function($animateProvider) {
        var gcsLookup = createLocalCacheLookup();
        var gcsStaggerLookup = createLocalCacheLookup();
        this.$get = ['$window', '$$jqLite', '$$AnimateRunner', '$timeout', '$$forceReflow', '$sniffer', '$$rAFScheduler', '$$animateQueue', function($window, $$jqLite, $$AnimateRunner, $timeout, $$forceReflow, $sniffer, $$rAFScheduler, $$animateQueue) {
          var applyAnimationClasses = applyAnimationClassesFactory($$jqLite);
          var parentCounter = 0;
          function gcsHashFn(node, extraClasses) {
            var KEY = "$$ngAnimateParentKey";
            var parentNode = node.parentNode;
            var parentID = parentNode[KEY] || (parentNode[KEY] = ++parentCounter);
            return parentID + '-' + node.getAttribute('class') + '-' + extraClasses;
          }
          function computeCachedCssStyles(node, className, cacheKey, properties) {
            var timings = gcsLookup.get(cacheKey);
            if (!timings) {
              timings = computeCssStyles($window, node, properties);
              if (timings.animationIterationCount === 'infinite') {
                timings.animationIterationCount = 1;
              }
            }
            gcsLookup.put(cacheKey, timings);
            return timings;
          }
          function computeCachedCssStaggerStyles(node, className, cacheKey, properties) {
            var stagger;
            if (gcsLookup.count(cacheKey) > 0) {
              stagger = gcsStaggerLookup.get(cacheKey);
              if (!stagger) {
                var staggerClassName = pendClasses(className, '-stagger');
                $$jqLite.addClass(node, staggerClassName);
                stagger = computeCssStyles($window, node, properties);
                stagger.animationDuration = Math.max(stagger.animationDuration, 0);
                stagger.transitionDuration = Math.max(stagger.transitionDuration, 0);
                $$jqLite.removeClass(node, staggerClassName);
                gcsStaggerLookup.put(cacheKey, stagger);
              }
            }
            return stagger || {};
          }
          var cancelLastRAFRequest;
          var rafWaitQueue = [];
          function waitUntilQuiet(callback) {
            rafWaitQueue.push(callback);
            $$rAFScheduler.waitUntilQuiet(function() {
              gcsLookup.flush();
              gcsStaggerLookup.flush();
              var pageWidth = $$forceReflow();
              for (var i = 0; i < rafWaitQueue.length; i++) {
                rafWaitQueue[i](pageWidth);
              }
              rafWaitQueue.length = 0;
            });
          }
          function computeTimings(node, className, cacheKey) {
            var timings = computeCachedCssStyles(node, className, cacheKey, DETECT_CSS_PROPERTIES);
            var aD = timings.animationDelay;
            var tD = timings.transitionDelay;
            timings.maxDelay = aD && tD ? Math.max(aD, tD) : (aD || tD);
            timings.maxDuration = Math.max(timings.animationDuration * timings.animationIterationCount, timings.transitionDuration);
            return timings;
          }
          return function init(element, initialOptions) {
            var options = initialOptions || {};
            if (!options.$$prepared) {
              options = prepareAnimationOptions(copy(options));
            }
            var restoreStyles = {};
            var node = getDomNode(element);
            if (!node || !node.parentNode || !$$animateQueue.enabled()) {
              return closeAndReturnNoopAnimator();
            }
            var temporaryStyles = [];
            var classes = element.attr('class');
            var styles = packageStyles(options);
            var animationClosed;
            var animationPaused;
            var animationCompleted;
            var runner;
            var runnerHost;
            var maxDelay;
            var maxDelayTime;
            var maxDuration;
            var maxDurationTime;
            var startTime;
            var events = [];
            if (options.duration === 0 || (!$sniffer.animations && !$sniffer.transitions)) {
              return closeAndReturnNoopAnimator();
            }
            var method = options.event && isArray(options.event) ? options.event.join(' ') : options.event;
            var isStructural = method && options.structural;
            var structuralClassName = '';
            var addRemoveClassName = '';
            if (isStructural) {
              structuralClassName = pendClasses(method, EVENT_CLASS_PREFIX, true);
            } else if (method) {
              structuralClassName = method;
            }
            if (options.addClass) {
              addRemoveClassName += pendClasses(options.addClass, ADD_CLASS_SUFFIX);
            }
            if (options.removeClass) {
              if (addRemoveClassName.length) {
                addRemoveClassName += ' ';
              }
              addRemoveClassName += pendClasses(options.removeClass, REMOVE_CLASS_SUFFIX);
            }
            if (options.applyClassesEarly && addRemoveClassName.length) {
              applyAnimationClasses(element, options);
            }
            var preparationClasses = [structuralClassName, addRemoveClassName].join(' ').trim();
            var fullClassName = classes + ' ' + preparationClasses;
            var activeClasses = pendClasses(preparationClasses, ACTIVE_CLASS_SUFFIX);
            var hasToStyles = styles.to && Object.keys(styles.to).length > 0;
            var containsKeyframeAnimation = (options.keyframeStyle || '').length > 0;
            if (!containsKeyframeAnimation && !hasToStyles && !preparationClasses) {
              return closeAndReturnNoopAnimator();
            }
            var cacheKey,
                stagger;
            if (options.stagger > 0) {
              var staggerVal = parseFloat(options.stagger);
              stagger = {
                transitionDelay: staggerVal,
                animationDelay: staggerVal,
                transitionDuration: 0,
                animationDuration: 0
              };
            } else {
              cacheKey = gcsHashFn(node, fullClassName);
              stagger = computeCachedCssStaggerStyles(node, preparationClasses, cacheKey, DETECT_STAGGER_CSS_PROPERTIES);
            }
            if (!options.$$skipPreparationClasses) {
              $$jqLite.addClass(element, preparationClasses);
            }
            var applyOnlyDuration;
            if (options.transitionStyle) {
              var transitionStyle = [TRANSITION_PROP, options.transitionStyle];
              applyInlineStyle(node, transitionStyle);
              temporaryStyles.push(transitionStyle);
            }
            if (options.duration >= 0) {
              applyOnlyDuration = node.style[TRANSITION_PROP].length > 0;
              var durationStyle = getCssTransitionDurationStyle(options.duration, applyOnlyDuration);
              applyInlineStyle(node, durationStyle);
              temporaryStyles.push(durationStyle);
            }
            if (options.keyframeStyle) {
              var keyframeStyle = [ANIMATION_PROP, options.keyframeStyle];
              applyInlineStyle(node, keyframeStyle);
              temporaryStyles.push(keyframeStyle);
            }
            var itemIndex = stagger ? options.staggerIndex >= 0 ? options.staggerIndex : gcsLookup.count(cacheKey) : 0;
            var isFirst = itemIndex === 0;
            if (isFirst && !options.skipBlocking) {
              blockTransitions(node, SAFE_FAST_FORWARD_DURATION_VALUE);
            }
            var timings = computeTimings(node, fullClassName, cacheKey);
            var relativeDelay = timings.maxDelay;
            maxDelay = Math.max(relativeDelay, 0);
            maxDuration = timings.maxDuration;
            var flags = {};
            flags.hasTransitions = timings.transitionDuration > 0;
            flags.hasAnimations = timings.animationDuration > 0;
            flags.hasTransitionAll = flags.hasTransitions && timings.transitionProperty == 'all';
            flags.applyTransitionDuration = hasToStyles && ((flags.hasTransitions && !flags.hasTransitionAll) || (flags.hasAnimations && !flags.hasTransitions));
            flags.applyAnimationDuration = options.duration && flags.hasAnimations;
            flags.applyTransitionDelay = truthyTimingValue(options.delay) && (flags.applyTransitionDuration || flags.hasTransitions);
            flags.applyAnimationDelay = truthyTimingValue(options.delay) && flags.hasAnimations;
            flags.recalculateTimingStyles = addRemoveClassName.length > 0;
            if (flags.applyTransitionDuration || flags.applyAnimationDuration) {
              maxDuration = options.duration ? parseFloat(options.duration) : maxDuration;
              if (flags.applyTransitionDuration) {
                flags.hasTransitions = true;
                timings.transitionDuration = maxDuration;
                applyOnlyDuration = node.style[TRANSITION_PROP + PROPERTY_KEY].length > 0;
                temporaryStyles.push(getCssTransitionDurationStyle(maxDuration, applyOnlyDuration));
              }
              if (flags.applyAnimationDuration) {
                flags.hasAnimations = true;
                timings.animationDuration = maxDuration;
                temporaryStyles.push(getCssKeyframeDurationStyle(maxDuration));
              }
            }
            if (maxDuration === 0 && !flags.recalculateTimingStyles) {
              return closeAndReturnNoopAnimator();
            }
            if (options.delay != null) {
              var delayStyle;
              if (typeof options.delay !== "boolean") {
                delayStyle = parseFloat(options.delay);
                maxDelay = Math.max(delayStyle, 0);
              }
              if (flags.applyTransitionDelay) {
                temporaryStyles.push(getCssDelayStyle(delayStyle));
              }
              if (flags.applyAnimationDelay) {
                temporaryStyles.push(getCssDelayStyle(delayStyle, true));
              }
            }
            if (options.duration == null && timings.transitionDuration > 0) {
              flags.recalculateTimingStyles = flags.recalculateTimingStyles || isFirst;
            }
            maxDelayTime = maxDelay * ONE_SECOND;
            maxDurationTime = maxDuration * ONE_SECOND;
            if (!options.skipBlocking) {
              flags.blockTransition = timings.transitionDuration > 0;
              flags.blockKeyframeAnimation = timings.animationDuration > 0 && stagger.animationDelay > 0 && stagger.animationDuration === 0;
            }
            if (options.from) {
              if (options.cleanupStyles) {
                registerRestorableStyles(restoreStyles, node, Object.keys(options.from));
              }
              applyAnimationFromStyles(element, options);
            }
            if (flags.blockTransition || flags.blockKeyframeAnimation) {
              applyBlocking(maxDuration);
            } else if (!options.skipBlocking) {
              blockTransitions(node, false);
            }
            return {
              $$willAnimate: true,
              end: endFn,
              start: function() {
                if (animationClosed)
                  return;
                runnerHost = {
                  end: endFn,
                  cancel: cancelFn,
                  resume: null,
                  pause: null
                };
                runner = new $$AnimateRunner(runnerHost);
                waitUntilQuiet(start);
                return runner;
              }
            };
            function endFn() {
              close();
            }
            function cancelFn() {
              close(true);
            }
            function close(rejected) {
              if (animationClosed || (animationCompleted && animationPaused))
                return;
              animationClosed = true;
              animationPaused = false;
              if (!options.$$skipPreparationClasses) {
                $$jqLite.removeClass(element, preparationClasses);
              }
              $$jqLite.removeClass(element, activeClasses);
              blockKeyframeAnimations(node, false);
              blockTransitions(node, false);
              forEach(temporaryStyles, function(entry) {
                node.style[entry[0]] = '';
              });
              applyAnimationClasses(element, options);
              applyAnimationStyles(element, options);
              if (Object.keys(restoreStyles).length) {
                forEach(restoreStyles, function(value, prop) {
                  value ? node.style.setProperty(prop, value) : node.style.removeProperty(prop);
                });
              }
              if (options.onDone) {
                options.onDone();
              }
              if (events && events.length) {
                element.off(events.join(' '), onAnimationProgress);
              }
              var animationTimerData = element.data(ANIMATE_TIMER_KEY);
              if (animationTimerData) {
                $timeout.cancel(animationTimerData[0].timer);
                element.removeData(ANIMATE_TIMER_KEY);
              }
              if (runner) {
                runner.complete(!rejected);
              }
            }
            function applyBlocking(duration) {
              if (flags.blockTransition) {
                blockTransitions(node, duration);
              }
              if (flags.blockKeyframeAnimation) {
                blockKeyframeAnimations(node, !!duration);
              }
            }
            function closeAndReturnNoopAnimator() {
              runner = new $$AnimateRunner({
                end: endFn,
                cancel: cancelFn
              });
              waitUntilQuiet(noop);
              close();
              return {
                $$willAnimate: false,
                start: function() {
                  return runner;
                },
                end: endFn
              };
            }
            function onAnimationProgress(event) {
              event.stopPropagation();
              var ev = event.originalEvent || event;
              var timeStamp = ev.$manualTimeStamp || Date.now();
              var elapsedTime = parseFloat(ev.elapsedTime.toFixed(ELAPSED_TIME_MAX_DECIMAL_PLACES));
              if (Math.max(timeStamp - startTime, 0) >= maxDelayTime && elapsedTime >= maxDuration) {
                animationCompleted = true;
                close();
              }
            }
            function start() {
              if (animationClosed)
                return;
              if (!node.parentNode) {
                close();
                return;
              }
              var playPause = function(playAnimation) {
                if (!animationCompleted) {
                  animationPaused = !playAnimation;
                  if (timings.animationDuration) {
                    var value = blockKeyframeAnimations(node, animationPaused);
                    animationPaused ? temporaryStyles.push(value) : removeFromArray(temporaryStyles, value);
                  }
                } else if (animationPaused && playAnimation) {
                  animationPaused = false;
                  close();
                }
              };
              var maxStagger = itemIndex > 0 && ((timings.transitionDuration && stagger.transitionDuration === 0) || (timings.animationDuration && stagger.animationDuration === 0)) && Math.max(stagger.animationDelay, stagger.transitionDelay);
              if (maxStagger) {
                $timeout(triggerAnimationStart, Math.floor(maxStagger * itemIndex * ONE_SECOND), false);
              } else {
                triggerAnimationStart();
              }
              runnerHost.resume = function() {
                playPause(true);
              };
              runnerHost.pause = function() {
                playPause(false);
              };
              function triggerAnimationStart() {
                if (animationClosed)
                  return;
                applyBlocking(false);
                forEach(temporaryStyles, function(entry) {
                  var key = entry[0];
                  var value = entry[1];
                  node.style[key] = value;
                });
                applyAnimationClasses(element, options);
                $$jqLite.addClass(element, activeClasses);
                if (flags.recalculateTimingStyles) {
                  fullClassName = node.className + ' ' + preparationClasses;
                  cacheKey = gcsHashFn(node, fullClassName);
                  timings = computeTimings(node, fullClassName, cacheKey);
                  relativeDelay = timings.maxDelay;
                  maxDelay = Math.max(relativeDelay, 0);
                  maxDuration = timings.maxDuration;
                  if (maxDuration === 0) {
                    close();
                    return;
                  }
                  flags.hasTransitions = timings.transitionDuration > 0;
                  flags.hasAnimations = timings.animationDuration > 0;
                }
                if (flags.applyAnimationDelay) {
                  relativeDelay = typeof options.delay !== "boolean" && truthyTimingValue(options.delay) ? parseFloat(options.delay) : relativeDelay;
                  maxDelay = Math.max(relativeDelay, 0);
                  timings.animationDelay = relativeDelay;
                  delayStyle = getCssDelayStyle(relativeDelay, true);
                  temporaryStyles.push(delayStyle);
                  node.style[delayStyle[0]] = delayStyle[1];
                }
                maxDelayTime = maxDelay * ONE_SECOND;
                maxDurationTime = maxDuration * ONE_SECOND;
                if (options.easing) {
                  var easeProp,
                      easeVal = options.easing;
                  if (flags.hasTransitions) {
                    easeProp = TRANSITION_PROP + TIMING_KEY;
                    temporaryStyles.push([easeProp, easeVal]);
                    node.style[easeProp] = easeVal;
                  }
                  if (flags.hasAnimations) {
                    easeProp = ANIMATION_PROP + TIMING_KEY;
                    temporaryStyles.push([easeProp, easeVal]);
                    node.style[easeProp] = easeVal;
                  }
                }
                if (timings.transitionDuration) {
                  events.push(TRANSITIONEND_EVENT);
                }
                if (timings.animationDuration) {
                  events.push(ANIMATIONEND_EVENT);
                }
                startTime = Date.now();
                var timerTime = maxDelayTime + CLOSING_TIME_BUFFER * maxDurationTime;
                var endTime = startTime + timerTime;
                var animationsData = element.data(ANIMATE_TIMER_KEY) || [];
                var setupFallbackTimer = true;
                if (animationsData.length) {
                  var currentTimerData = animationsData[0];
                  setupFallbackTimer = endTime > currentTimerData.expectedEndTime;
                  if (setupFallbackTimer) {
                    $timeout.cancel(currentTimerData.timer);
                  } else {
                    animationsData.push(close);
                  }
                }
                if (setupFallbackTimer) {
                  var timer = $timeout(onAnimationExpired, timerTime, false);
                  animationsData[0] = {
                    timer: timer,
                    expectedEndTime: endTime
                  };
                  animationsData.push(close);
                  element.data(ANIMATE_TIMER_KEY, animationsData);
                }
                if (events.length) {
                  element.on(events.join(' '), onAnimationProgress);
                }
                if (options.to) {
                  if (options.cleanupStyles) {
                    registerRestorableStyles(restoreStyles, node, Object.keys(options.to));
                  }
                  applyAnimationToStyles(element, options);
                }
              }
              function onAnimationExpired() {
                var animationsData = element.data(ANIMATE_TIMER_KEY);
                if (animationsData) {
                  for (var i = 1; i < animationsData.length; i++) {
                    animationsData[i]();
                  }
                  element.removeData(ANIMATE_TIMER_KEY);
                }
              }
            }
          };
        }];
      }];
      var $$AnimateCssDriverProvider = ['$$animationProvider', function($$animationProvider) {
        $$animationProvider.drivers.push('$$animateCssDriver');
        var NG_ANIMATE_SHIM_CLASS_NAME = 'ng-animate-shim';
        var NG_ANIMATE_ANCHOR_CLASS_NAME = 'ng-anchor';
        var NG_OUT_ANCHOR_CLASS_NAME = 'ng-anchor-out';
        var NG_IN_ANCHOR_CLASS_NAME = 'ng-anchor-in';
        function isDocumentFragment(node) {
          return node.parentNode && node.parentNode.nodeType === 11;
        }
        this.$get = ['$animateCss', '$rootScope', '$$AnimateRunner', '$rootElement', '$sniffer', '$$jqLite', '$document', function($animateCss, $rootScope, $$AnimateRunner, $rootElement, $sniffer, $$jqLite, $document) {
          if (!$sniffer.animations && !$sniffer.transitions)
            return noop;
          var bodyNode = $document[0].body;
          var rootNode = getDomNode($rootElement);
          var rootBodyElement = jqLite(isDocumentFragment(rootNode) || bodyNode.contains(rootNode) ? rootNode : bodyNode);
          var applyAnimationClasses = applyAnimationClassesFactory($$jqLite);
          return function initDriverFn(animationDetails) {
            return animationDetails.from && animationDetails.to ? prepareFromToAnchorAnimation(animationDetails.from, animationDetails.to, animationDetails.classes, animationDetails.anchors) : prepareRegularAnimation(animationDetails);
          };
          function filterCssClasses(classes) {
            return classes.replace(/\bng-\S+\b/g, '');
          }
          function getUniqueValues(a, b) {
            if (isString(a))
              a = a.split(' ');
            if (isString(b))
              b = b.split(' ');
            return a.filter(function(val) {
              return b.indexOf(val) === -1;
            }).join(' ');
          }
          function prepareAnchoredAnimation(classes, outAnchor, inAnchor) {
            var clone = jqLite(getDomNode(outAnchor).cloneNode(true));
            var startingClasses = filterCssClasses(getClassVal(clone));
            outAnchor.addClass(NG_ANIMATE_SHIM_CLASS_NAME);
            inAnchor.addClass(NG_ANIMATE_SHIM_CLASS_NAME);
            clone.addClass(NG_ANIMATE_ANCHOR_CLASS_NAME);
            rootBodyElement.append(clone);
            var animatorIn,
                animatorOut = prepareOutAnimation();
            if (!animatorOut) {
              animatorIn = prepareInAnimation();
              if (!animatorIn) {
                return end();
              }
            }
            var startingAnimator = animatorOut || animatorIn;
            return {start: function() {
                var runner;
                var currentAnimation = startingAnimator.start();
                currentAnimation.done(function() {
                  currentAnimation = null;
                  if (!animatorIn) {
                    animatorIn = prepareInAnimation();
                    if (animatorIn) {
                      currentAnimation = animatorIn.start();
                      currentAnimation.done(function() {
                        currentAnimation = null;
                        end();
                        runner.complete();
                      });
                      return currentAnimation;
                    }
                  }
                  end();
                  runner.complete();
                });
                runner = new $$AnimateRunner({
                  end: endFn,
                  cancel: endFn
                });
                return runner;
                function endFn() {
                  if (currentAnimation) {
                    currentAnimation.end();
                  }
                }
              }};
            function calculateAnchorStyles(anchor) {
              var styles = {};
              var coords = getDomNode(anchor).getBoundingClientRect();
              forEach(['width', 'height', 'top', 'left'], function(key) {
                var value = coords[key];
                switch (key) {
                  case 'top':
                    value += bodyNode.scrollTop;
                    break;
                  case 'left':
                    value += bodyNode.scrollLeft;
                    break;
                }
                styles[key] = Math.floor(value) + 'px';
              });
              return styles;
            }
            function prepareOutAnimation() {
              var animator = $animateCss(clone, {
                addClass: NG_OUT_ANCHOR_CLASS_NAME,
                delay: true,
                from: calculateAnchorStyles(outAnchor)
              });
              return animator.$$willAnimate ? animator : null;
            }
            function getClassVal(element) {
              return element.attr('class') || '';
            }
            function prepareInAnimation() {
              var endingClasses = filterCssClasses(getClassVal(inAnchor));
              var toAdd = getUniqueValues(endingClasses, startingClasses);
              var toRemove = getUniqueValues(startingClasses, endingClasses);
              var animator = $animateCss(clone, {
                to: calculateAnchorStyles(inAnchor),
                addClass: NG_IN_ANCHOR_CLASS_NAME + ' ' + toAdd,
                removeClass: NG_OUT_ANCHOR_CLASS_NAME + ' ' + toRemove,
                delay: true
              });
              return animator.$$willAnimate ? animator : null;
            }
            function end() {
              clone.remove();
              outAnchor.removeClass(NG_ANIMATE_SHIM_CLASS_NAME);
              inAnchor.removeClass(NG_ANIMATE_SHIM_CLASS_NAME);
            }
          }
          function prepareFromToAnchorAnimation(from, to, classes, anchors) {
            var fromAnimation = prepareRegularAnimation(from, noop);
            var toAnimation = prepareRegularAnimation(to, noop);
            var anchorAnimations = [];
            forEach(anchors, function(anchor) {
              var outElement = anchor['out'];
              var inElement = anchor['in'];
              var animator = prepareAnchoredAnimation(classes, outElement, inElement);
              if (animator) {
                anchorAnimations.push(animator);
              }
            });
            if (!fromAnimation && !toAnimation && anchorAnimations.length === 0)
              return;
            return {start: function() {
                var animationRunners = [];
                if (fromAnimation) {
                  animationRunners.push(fromAnimation.start());
                }
                if (toAnimation) {
                  animationRunners.push(toAnimation.start());
                }
                forEach(anchorAnimations, function(animation) {
                  animationRunners.push(animation.start());
                });
                var runner = new $$AnimateRunner({
                  end: endFn,
                  cancel: endFn
                });
                $$AnimateRunner.all(animationRunners, function(status) {
                  runner.complete(status);
                });
                return runner;
                function endFn() {
                  forEach(animationRunners, function(runner) {
                    runner.end();
                  });
                }
              }};
          }
          function prepareRegularAnimation(animationDetails) {
            var element = animationDetails.element;
            var options = animationDetails.options || {};
            if (animationDetails.structural) {
              options.event = animationDetails.event;
              options.structural = true;
              options.applyClassesEarly = true;
              if (animationDetails.event === 'leave') {
                options.onDone = options.domOperation;
              }
            }
            if (options.preparationClasses) {
              options.event = concatWithSpace(options.event, options.preparationClasses);
            }
            var animator = $animateCss(element, options);
            return animator.$$willAnimate ? animator : null;
          }
        }];
      }];
      var $$AnimateJsProvider = ['$animateProvider', function($animateProvider) {
        this.$get = ['$injector', '$$AnimateRunner', '$$jqLite', function($injector, $$AnimateRunner, $$jqLite) {
          var applyAnimationClasses = applyAnimationClassesFactory($$jqLite);
          return function(element, event, classes, options) {
            var animationClosed = false;
            if (arguments.length === 3 && isObject(classes)) {
              options = classes;
              classes = null;
            }
            options = prepareAnimationOptions(options);
            if (!classes) {
              classes = element.attr('class') || '';
              if (options.addClass) {
                classes += ' ' + options.addClass;
              }
              if (options.removeClass) {
                classes += ' ' + options.removeClass;
              }
            }
            var classesToAdd = options.addClass;
            var classesToRemove = options.removeClass;
            var animations = lookupAnimations(classes);
            var before,
                after;
            if (animations.length) {
              var afterFn,
                  beforeFn;
              if (event == 'leave') {
                beforeFn = 'leave';
                afterFn = 'afterLeave';
              } else {
                beforeFn = 'before' + event.charAt(0).toUpperCase() + event.substr(1);
                afterFn = event;
              }
              if (event !== 'enter' && event !== 'move') {
                before = packageAnimations(element, event, options, animations, beforeFn);
              }
              after = packageAnimations(element, event, options, animations, afterFn);
            }
            if (!before && !after)
              return;
            function applyOptions() {
              options.domOperation();
              applyAnimationClasses(element, options);
            }
            function close() {
              animationClosed = true;
              applyOptions();
              applyAnimationStyles(element, options);
            }
            var runner;
            return {
              $$willAnimate: true,
              end: function() {
                if (runner) {
                  runner.end();
                } else {
                  close();
                  runner = new $$AnimateRunner();
                  runner.complete(true);
                }
                return runner;
              },
              start: function() {
                if (runner) {
                  return runner;
                }
                runner = new $$AnimateRunner();
                var closeActiveAnimations;
                var chain = [];
                if (before) {
                  chain.push(function(fn) {
                    closeActiveAnimations = before(fn);
                  });
                }
                if (chain.length) {
                  chain.push(function(fn) {
                    applyOptions();
                    fn(true);
                  });
                } else {
                  applyOptions();
                }
                if (after) {
                  chain.push(function(fn) {
                    closeActiveAnimations = after(fn);
                  });
                }
                runner.setHost({
                  end: function() {
                    endAnimations();
                  },
                  cancel: function() {
                    endAnimations(true);
                  }
                });
                $$AnimateRunner.chain(chain, onComplete);
                return runner;
                function onComplete(success) {
                  close(success);
                  runner.complete(success);
                }
                function endAnimations(cancelled) {
                  if (!animationClosed) {
                    (closeActiveAnimations || noop)(cancelled);
                    onComplete(cancelled);
                  }
                }
              }
            };
            function executeAnimationFn(fn, element, event, options, onDone) {
              var args;
              switch (event) {
                case 'animate':
                  args = [element, options.from, options.to, onDone];
                  break;
                case 'setClass':
                  args = [element, classesToAdd, classesToRemove, onDone];
                  break;
                case 'addClass':
                  args = [element, classesToAdd, onDone];
                  break;
                case 'removeClass':
                  args = [element, classesToRemove, onDone];
                  break;
                default:
                  args = [element, onDone];
                  break;
              }
              args.push(options);
              var value = fn.apply(fn, args);
              if (value) {
                if (isFunction(value.start)) {
                  value = value.start();
                }
                if (value instanceof $$AnimateRunner) {
                  value.done(onDone);
                } else if (isFunction(value)) {
                  return value;
                }
              }
              return noop;
            }
            function groupEventedAnimations(element, event, options, animations, fnName) {
              var operations = [];
              forEach(animations, function(ani) {
                var animation = ani[fnName];
                if (!animation)
                  return;
                operations.push(function() {
                  var runner;
                  var endProgressCb;
                  var resolved = false;
                  var onAnimationComplete = function(rejected) {
                    if (!resolved) {
                      resolved = true;
                      (endProgressCb || noop)(rejected);
                      runner.complete(!rejected);
                    }
                  };
                  runner = new $$AnimateRunner({
                    end: function() {
                      onAnimationComplete();
                    },
                    cancel: function() {
                      onAnimationComplete(true);
                    }
                  });
                  endProgressCb = executeAnimationFn(animation, element, event, options, function(result) {
                    var cancelled = result === false;
                    onAnimationComplete(cancelled);
                  });
                  return runner;
                });
              });
              return operations;
            }
            function packageAnimations(element, event, options, animations, fnName) {
              var operations = groupEventedAnimations(element, event, options, animations, fnName);
              if (operations.length === 0) {
                var a,
                    b;
                if (fnName === 'beforeSetClass') {
                  a = groupEventedAnimations(element, 'removeClass', options, animations, 'beforeRemoveClass');
                  b = groupEventedAnimations(element, 'addClass', options, animations, 'beforeAddClass');
                } else if (fnName === 'setClass') {
                  a = groupEventedAnimations(element, 'removeClass', options, animations, 'removeClass');
                  b = groupEventedAnimations(element, 'addClass', options, animations, 'addClass');
                }
                if (a) {
                  operations = operations.concat(a);
                }
                if (b) {
                  operations = operations.concat(b);
                }
              }
              if (operations.length === 0)
                return;
              return function startAnimation(callback) {
                var runners = [];
                if (operations.length) {
                  forEach(operations, function(animateFn) {
                    runners.push(animateFn());
                  });
                }
                runners.length ? $$AnimateRunner.all(runners, callback) : callback();
                return function endFn(reject) {
                  forEach(runners, function(runner) {
                    reject ? runner.cancel() : runner.end();
                  });
                };
              };
            }
          };
          function lookupAnimations(classes) {
            classes = isArray(classes) ? classes : classes.split(' ');
            var matches = [],
                flagMap = {};
            for (var i = 0; i < classes.length; i++) {
              var klass = classes[i],
                  animationFactory = $animateProvider.$$registeredAnimations[klass];
              if (animationFactory && !flagMap[klass]) {
                matches.push($injector.get(animationFactory));
                flagMap[klass] = true;
              }
            }
            return matches;
          }
        }];
      }];
      var $$AnimateJsDriverProvider = ['$$animationProvider', function($$animationProvider) {
        $$animationProvider.drivers.push('$$animateJsDriver');
        this.$get = ['$$animateJs', '$$AnimateRunner', function($$animateJs, $$AnimateRunner) {
          return function initDriverFn(animationDetails) {
            if (animationDetails.from && animationDetails.to) {
              var fromAnimation = prepareAnimation(animationDetails.from);
              var toAnimation = prepareAnimation(animationDetails.to);
              if (!fromAnimation && !toAnimation)
                return;
              return {start: function() {
                  var animationRunners = [];
                  if (fromAnimation) {
                    animationRunners.push(fromAnimation.start());
                  }
                  if (toAnimation) {
                    animationRunners.push(toAnimation.start());
                  }
                  $$AnimateRunner.all(animationRunners, done);
                  var runner = new $$AnimateRunner({
                    end: endFnFactory(),
                    cancel: endFnFactory()
                  });
                  return runner;
                  function endFnFactory() {
                    return function() {
                      forEach(animationRunners, function(runner) {
                        runner.end();
                      });
                    };
                  }
                  function done(status) {
                    runner.complete(status);
                  }
                }};
            } else {
              return prepareAnimation(animationDetails);
            }
          };
          function prepareAnimation(animationDetails) {
            var element = animationDetails.element;
            var event = animationDetails.event;
            var options = animationDetails.options;
            var classes = animationDetails.classes;
            return $$animateJs(element, event, classes, options);
          }
        }];
      }];
      var NG_ANIMATE_ATTR_NAME = 'data-ng-animate';
      var NG_ANIMATE_PIN_DATA = '$ngAnimatePin';
      var $$AnimateQueueProvider = ['$animateProvider', function($animateProvider) {
        var PRE_DIGEST_STATE = 1;
        var RUNNING_STATE = 2;
        var ONE_SPACE = ' ';
        var rules = this.rules = {
          skip: [],
          cancel: [],
          join: []
        };
        function makeTruthyCssClassMap(classString) {
          if (!classString) {
            return null;
          }
          var keys = classString.split(ONE_SPACE);
          var map = Object.create(null);
          forEach(keys, function(key) {
            map[key] = true;
          });
          return map;
        }
        function hasMatchingClasses(newClassString, currentClassString) {
          if (newClassString && currentClassString) {
            var currentClassMap = makeTruthyCssClassMap(currentClassString);
            return newClassString.split(ONE_SPACE).some(function(className) {
              return currentClassMap[className];
            });
          }
        }
        function isAllowed(ruleType, element, currentAnimation, previousAnimation) {
          return rules[ruleType].some(function(fn) {
            return fn(element, currentAnimation, previousAnimation);
          });
        }
        function hasAnimationClasses(animation, and) {
          var a = (animation.addClass || '').length > 0;
          var b = (animation.removeClass || '').length > 0;
          return and ? a && b : a || b;
        }
        rules.join.push(function(element, newAnimation, currentAnimation) {
          return !newAnimation.structural && hasAnimationClasses(newAnimation);
        });
        rules.skip.push(function(element, newAnimation, currentAnimation) {
          return !newAnimation.structural && !hasAnimationClasses(newAnimation);
        });
        rules.skip.push(function(element, newAnimation, currentAnimation) {
          return currentAnimation.event == 'leave' && newAnimation.structural;
        });
        rules.skip.push(function(element, newAnimation, currentAnimation) {
          return currentAnimation.structural && currentAnimation.state === RUNNING_STATE && !newAnimation.structural;
        });
        rules.cancel.push(function(element, newAnimation, currentAnimation) {
          return currentAnimation.structural && newAnimation.structural;
        });
        rules.cancel.push(function(element, newAnimation, currentAnimation) {
          return currentAnimation.state === RUNNING_STATE && newAnimation.structural;
        });
        rules.cancel.push(function(element, newAnimation, currentAnimation) {
          if (currentAnimation.structural)
            return false;
          var nA = newAnimation.addClass;
          var nR = newAnimation.removeClass;
          var cA = currentAnimation.addClass;
          var cR = currentAnimation.removeClass;
          if ((isUndefined(nA) && isUndefined(nR)) || (isUndefined(cA) && isUndefined(cR))) {
            return false;
          }
          return hasMatchingClasses(nA, cR) || hasMatchingClasses(nR, cA);
        });
        this.$get = ['$$rAF', '$rootScope', '$rootElement', '$document', '$$HashMap', '$$animation', '$$AnimateRunner', '$templateRequest', '$$jqLite', '$$forceReflow', function($$rAF, $rootScope, $rootElement, $document, $$HashMap, $$animation, $$AnimateRunner, $templateRequest, $$jqLite, $$forceReflow) {
          var activeAnimationsLookup = new $$HashMap();
          var disabledElementsLookup = new $$HashMap();
          var animationsEnabled = null;
          function postDigestTaskFactory() {
            var postDigestCalled = false;
            return function(fn) {
              if (postDigestCalled) {
                fn();
              } else {
                $rootScope.$$postDigest(function() {
                  postDigestCalled = true;
                  fn();
                });
              }
            };
          }
          var deregisterWatch = $rootScope.$watch(function() {
            return $templateRequest.totalPendingRequests === 0;
          }, function(isEmpty) {
            if (!isEmpty)
              return;
            deregisterWatch();
            $rootScope.$$postDigest(function() {
              $rootScope.$$postDigest(function() {
                if (animationsEnabled === null) {
                  animationsEnabled = true;
                }
              });
            });
          });
          var callbackRegistry = {};
          var classNameFilter = $animateProvider.classNameFilter();
          var isAnimatableClassName = !classNameFilter ? function() {
            return true;
          } : function(className) {
            return classNameFilter.test(className);
          };
          var applyAnimationClasses = applyAnimationClassesFactory($$jqLite);
          function normalizeAnimationDetails(element, animation) {
            return mergeAnimationDetails(element, animation, {});
          }
          var contains = window.Node.prototype.contains || function(arg) {
            return this === arg || !!(this.compareDocumentPosition(arg) & 16);
          };
          function findCallbacks(parent, element, event) {
            var targetNode = getDomNode(element);
            var targetParentNode = getDomNode(parent);
            var matches = [];
            var entries = callbackRegistry[event];
            if (entries) {
              forEach(entries, function(entry) {
                if (contains.call(entry.node, targetNode)) {
                  matches.push(entry.callback);
                } else if (event === 'leave' && contains.call(entry.node, targetParentNode)) {
                  matches.push(entry.callback);
                }
              });
            }
            return matches;
          }
          function filterFromRegistry(list, matchContainer, matchCallback) {
            var containerNode = extractElementNode(matchContainer);
            return list.filter(function(entry) {
              var isMatch = entry.node === containerNode && (!matchCallback || entry.callback === matchCallback);
              return !isMatch;
            });
          }
          function cleanupEventListeners(phase, element) {
            if (phase === 'close' && !element[0].parentNode) {
              $animate.off(element);
            }
          }
          var $animate = {
            on: function(event, container, callback) {
              var node = extractElementNode(container);
              callbackRegistry[event] = callbackRegistry[event] || [];
              callbackRegistry[event].push({
                node: node,
                callback: callback
              });
              jqLite(container).on('$destroy', function() {
                var animationDetails = activeAnimationsLookup.get(node);
                if (!animationDetails) {
                  $animate.off(event, container, callback);
                }
              });
            },
            off: function(event, container, callback) {
              if (arguments.length === 1 && !angular.isString(arguments[0])) {
                container = arguments[0];
                for (var eventType in callbackRegistry) {
                  callbackRegistry[eventType] = filterFromRegistry(callbackRegistry[eventType], container);
                }
                return;
              }
              var entries = callbackRegistry[event];
              if (!entries)
                return;
              callbackRegistry[event] = arguments.length === 1 ? null : filterFromRegistry(entries, container, callback);
            },
            pin: function(element, parentElement) {
              assertArg(isElement(element), 'element', 'not an element');
              assertArg(isElement(parentElement), 'parentElement', 'not an element');
              element.data(NG_ANIMATE_PIN_DATA, parentElement);
            },
            push: function(element, event, options, domOperation) {
              options = options || {};
              options.domOperation = domOperation;
              return queueAnimation(element, event, options);
            },
            enabled: function(element, bool) {
              var argCount = arguments.length;
              if (argCount === 0) {
                bool = !!animationsEnabled;
              } else {
                var hasElement = isElement(element);
                if (!hasElement) {
                  bool = animationsEnabled = !!element;
                } else {
                  var node = getDomNode(element);
                  var recordExists = disabledElementsLookup.get(node);
                  if (argCount === 1) {
                    bool = !recordExists;
                  } else {
                    disabledElementsLookup.put(node, !bool);
                  }
                }
              }
              return bool;
            }
          };
          return $animate;
          function queueAnimation(element, event, initialOptions) {
            var options = copy(initialOptions);
            var node,
                parent;
            element = stripCommentsFromElement(element);
            if (element) {
              node = getDomNode(element);
              parent = element.parent();
            }
            options = prepareAnimationOptions(options);
            var runner = new $$AnimateRunner();
            var runInNextPostDigestOrNow = postDigestTaskFactory();
            if (isArray(options.addClass)) {
              options.addClass = options.addClass.join(' ');
            }
            if (options.addClass && !isString(options.addClass)) {
              options.addClass = null;
            }
            if (isArray(options.removeClass)) {
              options.removeClass = options.removeClass.join(' ');
            }
            if (options.removeClass && !isString(options.removeClass)) {
              options.removeClass = null;
            }
            if (options.from && !isObject(options.from)) {
              options.from = null;
            }
            if (options.to && !isObject(options.to)) {
              options.to = null;
            }
            if (!node) {
              close();
              return runner;
            }
            var className = [node.className, options.addClass, options.removeClass].join(' ');
            if (!isAnimatableClassName(className)) {
              close();
              return runner;
            }
            var isStructural = ['enter', 'move', 'leave'].indexOf(event) >= 0;
            var documentHidden = $document[0].hidden;
            var skipAnimations = !animationsEnabled || documentHidden || disabledElementsLookup.get(node);
            var existingAnimation = (!skipAnimations && activeAnimationsLookup.get(node)) || {};
            var hasExistingAnimation = !!existingAnimation.state;
            if (!skipAnimations && (!hasExistingAnimation || existingAnimation.state != PRE_DIGEST_STATE)) {
              skipAnimations = !areAnimationsAllowed(element, parent, event);
            }
            if (skipAnimations) {
              if (documentHidden)
                notifyProgress(runner, event, 'start');
              close();
              if (documentHidden)
                notifyProgress(runner, event, 'close');
              return runner;
            }
            if (isStructural) {
              closeChildAnimations(element);
            }
            var newAnimation = {
              structural: isStructural,
              element: element,
              event: event,
              addClass: options.addClass,
              removeClass: options.removeClass,
              close: close,
              options: options,
              runner: runner
            };
            if (hasExistingAnimation) {
              var skipAnimationFlag = isAllowed('skip', element, newAnimation, existingAnimation);
              if (skipAnimationFlag) {
                if (existingAnimation.state === RUNNING_STATE) {
                  close();
                  return runner;
                } else {
                  mergeAnimationDetails(element, existingAnimation, newAnimation);
                  return existingAnimation.runner;
                }
              }
              var cancelAnimationFlag = isAllowed('cancel', element, newAnimation, existingAnimation);
              if (cancelAnimationFlag) {
                if (existingAnimation.state === RUNNING_STATE) {
                  existingAnimation.runner.end();
                } else if (existingAnimation.structural) {
                  existingAnimation.close();
                } else {
                  mergeAnimationDetails(element, existingAnimation, newAnimation);
                  return existingAnimation.runner;
                }
              } else {
                var joinAnimationFlag = isAllowed('join', element, newAnimation, existingAnimation);
                if (joinAnimationFlag) {
                  if (existingAnimation.state === RUNNING_STATE) {
                    normalizeAnimationDetails(element, newAnimation);
                  } else {
                    applyGeneratedPreparationClasses(element, isStructural ? event : null, options);
                    event = newAnimation.event = existingAnimation.event;
                    options = mergeAnimationDetails(element, existingAnimation, newAnimation);
                    return existingAnimation.runner;
                  }
                }
              }
            } else {
              normalizeAnimationDetails(element, newAnimation);
            }
            var isValidAnimation = newAnimation.structural;
            if (!isValidAnimation) {
              isValidAnimation = (newAnimation.event === 'animate' && Object.keys(newAnimation.options.to || {}).length > 0) || hasAnimationClasses(newAnimation);
            }
            if (!isValidAnimation) {
              close();
              clearElementAnimationState(element);
              return runner;
            }
            var counter = (existingAnimation.counter || 0) + 1;
            newAnimation.counter = counter;
            markElementAnimationState(element, PRE_DIGEST_STATE, newAnimation);
            $rootScope.$$postDigest(function() {
              var animationDetails = activeAnimationsLookup.get(node);
              var animationCancelled = !animationDetails;
              animationDetails = animationDetails || {};
              var parentElement = element.parent() || [];
              var isValidAnimation = parentElement.length > 0 && (animationDetails.event === 'animate' || animationDetails.structural || hasAnimationClasses(animationDetails));
              if (animationCancelled || animationDetails.counter !== counter || !isValidAnimation) {
                if (animationCancelled) {
                  applyAnimationClasses(element, options);
                  applyAnimationStyles(element, options);
                }
                if (animationCancelled || (isStructural && animationDetails.event !== event)) {
                  options.domOperation();
                  runner.end();
                }
                if (!isValidAnimation) {
                  clearElementAnimationState(element);
                }
                return;
              }
              event = !animationDetails.structural && hasAnimationClasses(animationDetails, true) ? 'setClass' : animationDetails.event;
              markElementAnimationState(element, RUNNING_STATE);
              var realRunner = $$animation(element, event, animationDetails.options);
              runner.setHost(realRunner);
              notifyProgress(runner, event, 'start', {});
              realRunner.done(function(status) {
                close(!status);
                var animationDetails = activeAnimationsLookup.get(node);
                if (animationDetails && animationDetails.counter === counter) {
                  clearElementAnimationState(getDomNode(element));
                }
                notifyProgress(runner, event, 'close', {});
              });
            });
            return runner;
            function notifyProgress(runner, event, phase, data) {
              runInNextPostDigestOrNow(function() {
                var callbacks = findCallbacks(parent, element, event);
                if (callbacks.length) {
                  $$rAF(function() {
                    forEach(callbacks, function(callback) {
                      callback(element, phase, data);
                    });
                    cleanupEventListeners(phase, element);
                  });
                } else {
                  cleanupEventListeners(phase, element);
                }
              });
              runner.progress(event, phase, data);
            }
            function close(reject) {
              clearGeneratedClasses(element, options);
              applyAnimationClasses(element, options);
              applyAnimationStyles(element, options);
              options.domOperation();
              runner.complete(!reject);
            }
          }
          function closeChildAnimations(element) {
            var node = getDomNode(element);
            var children = node.querySelectorAll('[' + NG_ANIMATE_ATTR_NAME + ']');
            forEach(children, function(child) {
              var state = parseInt(child.getAttribute(NG_ANIMATE_ATTR_NAME));
              var animationDetails = activeAnimationsLookup.get(child);
              if (animationDetails) {
                switch (state) {
                  case RUNNING_STATE:
                    animationDetails.runner.end();
                  case PRE_DIGEST_STATE:
                    activeAnimationsLookup.remove(child);
                    break;
                }
              }
            });
          }
          function clearElementAnimationState(element) {
            var node = getDomNode(element);
            node.removeAttribute(NG_ANIMATE_ATTR_NAME);
            activeAnimationsLookup.remove(node);
          }
          function isMatchingElement(nodeOrElmA, nodeOrElmB) {
            return getDomNode(nodeOrElmA) === getDomNode(nodeOrElmB);
          }
          function areAnimationsAllowed(element, parentElement, event) {
            var bodyElement = jqLite($document[0].body);
            var bodyElementDetected = isMatchingElement(element, bodyElement) || element[0].nodeName === 'HTML';
            var rootElementDetected = isMatchingElement(element, $rootElement);
            var parentAnimationDetected = false;
            var animateChildren;
            var elementDisabled = disabledElementsLookup.get(getDomNode(element));
            var parentHost = jqLite.data(element[0], NG_ANIMATE_PIN_DATA);
            if (parentHost) {
              parentElement = parentHost;
            }
            parentElement = getDomNode(parentElement);
            while (parentElement) {
              if (!rootElementDetected) {
                rootElementDetected = isMatchingElement(parentElement, $rootElement);
              }
              if (parentElement.nodeType !== ELEMENT_NODE) {
                break;
              }
              var details = activeAnimationsLookup.get(parentElement) || {};
              if (!parentAnimationDetected) {
                var parentElementDisabled = disabledElementsLookup.get(parentElement);
                if (parentElementDisabled === true && elementDisabled !== false) {
                  elementDisabled = true;
                  break;
                } else if (parentElementDisabled === false) {
                  elementDisabled = false;
                }
                parentAnimationDetected = details.structural;
              }
              if (isUndefined(animateChildren) || animateChildren === true) {
                var value = jqLite.data(parentElement, NG_ANIMATE_CHILDREN_DATA);
                if (isDefined(value)) {
                  animateChildren = value;
                }
              }
              if (parentAnimationDetected && animateChildren === false)
                break;
              if (!bodyElementDetected) {
                bodyElementDetected = isMatchingElement(parentElement, bodyElement);
              }
              if (bodyElementDetected && rootElementDetected) {
                break;
              }
              if (!rootElementDetected) {
                parentHost = jqLite.data(parentElement, NG_ANIMATE_PIN_DATA);
                if (parentHost) {
                  parentElement = getDomNode(parentHost);
                  continue;
                }
              }
              parentElement = parentElement.parentNode;
            }
            var allowAnimation = (!parentAnimationDetected || animateChildren) && elementDisabled !== true;
            return allowAnimation && rootElementDetected && bodyElementDetected;
          }
          function markElementAnimationState(element, state, details) {
            details = details || {};
            details.state = state;
            var node = getDomNode(element);
            node.setAttribute(NG_ANIMATE_ATTR_NAME, state);
            var oldValue = activeAnimationsLookup.get(node);
            var newValue = oldValue ? extend(oldValue, details) : details;
            activeAnimationsLookup.put(node, newValue);
          }
        }];
      }];
      var $$AnimationProvider = ['$animateProvider', function($animateProvider) {
        var NG_ANIMATE_REF_ATTR = 'ng-animate-ref';
        var drivers = this.drivers = [];
        var RUNNER_STORAGE_KEY = '$$animationRunner';
        function setRunner(element, runner) {
          element.data(RUNNER_STORAGE_KEY, runner);
        }
        function removeRunner(element) {
          element.removeData(RUNNER_STORAGE_KEY);
        }
        function getRunner(element) {
          return element.data(RUNNER_STORAGE_KEY);
        }
        this.$get = ['$$jqLite', '$rootScope', '$injector', '$$AnimateRunner', '$$HashMap', '$$rAFScheduler', function($$jqLite, $rootScope, $injector, $$AnimateRunner, $$HashMap, $$rAFScheduler) {
          var animationQueue = [];
          var applyAnimationClasses = applyAnimationClassesFactory($$jqLite);
          function sortAnimations(animations) {
            var tree = {children: []};
            var i,
                lookup = new $$HashMap();
            for (i = 0; i < animations.length; i++) {
              var animation = animations[i];
              lookup.put(animation.domNode, animations[i] = {
                domNode: animation.domNode,
                fn: animation.fn,
                children: []
              });
            }
            for (i = 0; i < animations.length; i++) {
              processNode(animations[i]);
            }
            return flatten(tree);
            function processNode(entry) {
              if (entry.processed)
                return entry;
              entry.processed = true;
              var elementNode = entry.domNode;
              var parentNode = elementNode.parentNode;
              lookup.put(elementNode, entry);
              var parentEntry;
              while (parentNode) {
                parentEntry = lookup.get(parentNode);
                if (parentEntry) {
                  if (!parentEntry.processed) {
                    parentEntry = processNode(parentEntry);
                  }
                  break;
                }
                parentNode = parentNode.parentNode;
              }
              (parentEntry || tree).children.push(entry);
              return entry;
            }
            function flatten(tree) {
              var result = [];
              var queue = [];
              var i;
              for (i = 0; i < tree.children.length; i++) {
                queue.push(tree.children[i]);
              }
              var remainingLevelEntries = queue.length;
              var nextLevelEntries = 0;
              var row = [];
              for (i = 0; i < queue.length; i++) {
                var entry = queue[i];
                if (remainingLevelEntries <= 0) {
                  remainingLevelEntries = nextLevelEntries;
                  nextLevelEntries = 0;
                  result.push(row);
                  row = [];
                }
                row.push(entry.fn);
                entry.children.forEach(function(childEntry) {
                  nextLevelEntries++;
                  queue.push(childEntry);
                });
                remainingLevelEntries--;
              }
              if (row.length) {
                result.push(row);
              }
              return result;
            }
          }
          return function(element, event, options) {
            options = prepareAnimationOptions(options);
            var isStructural = ['enter', 'move', 'leave'].indexOf(event) >= 0;
            var runner = new $$AnimateRunner({
              end: function() {
                close();
              },
              cancel: function() {
                close(true);
              }
            });
            if (!drivers.length) {
              close();
              return runner;
            }
            setRunner(element, runner);
            var classes = mergeClasses(element.attr('class'), mergeClasses(options.addClass, options.removeClass));
            var tempClasses = options.tempClasses;
            if (tempClasses) {
              classes += ' ' + tempClasses;
              options.tempClasses = null;
            }
            var prepareClassName;
            if (isStructural) {
              prepareClassName = 'ng-' + event + PREPARE_CLASS_SUFFIX;
              $$jqLite.addClass(element, prepareClassName);
            }
            animationQueue.push({
              element: element,
              classes: classes,
              event: event,
              structural: isStructural,
              options: options,
              beforeStart: beforeStart,
              close: close
            });
            element.on('$destroy', handleDestroyedElement);
            if (animationQueue.length > 1)
              return runner;
            $rootScope.$$postDigest(function() {
              var animations = [];
              forEach(animationQueue, function(entry) {
                if (getRunner(entry.element)) {
                  animations.push(entry);
                } else {
                  entry.close();
                }
              });
              animationQueue.length = 0;
              var groupedAnimations = groupAnimations(animations);
              var toBeSortedAnimations = [];
              forEach(groupedAnimations, function(animationEntry) {
                toBeSortedAnimations.push({
                  domNode: getDomNode(animationEntry.from ? animationEntry.from.element : animationEntry.element),
                  fn: function triggerAnimationStart() {
                    animationEntry.beforeStart();
                    var startAnimationFn,
                        closeFn = animationEntry.close;
                    var targetElement = animationEntry.anchors ? (animationEntry.from.element || animationEntry.to.element) : animationEntry.element;
                    if (getRunner(targetElement)) {
                      var operation = invokeFirstDriver(animationEntry);
                      if (operation) {
                        startAnimationFn = operation.start;
                      }
                    }
                    if (!startAnimationFn) {
                      closeFn();
                    } else {
                      var animationRunner = startAnimationFn();
                      animationRunner.done(function(status) {
                        closeFn(!status);
                      });
                      updateAnimationRunners(animationEntry, animationRunner);
                    }
                  }
                });
              });
              $$rAFScheduler(sortAnimations(toBeSortedAnimations));
            });
            return runner;
            function getAnchorNodes(node) {
              var SELECTOR = '[' + NG_ANIMATE_REF_ATTR + ']';
              var items = node.hasAttribute(NG_ANIMATE_REF_ATTR) ? [node] : node.querySelectorAll(SELECTOR);
              var anchors = [];
              forEach(items, function(node) {
                var attr = node.getAttribute(NG_ANIMATE_REF_ATTR);
                if (attr && attr.length) {
                  anchors.push(node);
                }
              });
              return anchors;
            }
            function groupAnimations(animations) {
              var preparedAnimations = [];
              var refLookup = {};
              forEach(animations, function(animation, index) {
                var element = animation.element;
                var node = getDomNode(element);
                var event = animation.event;
                var enterOrMove = ['enter', 'move'].indexOf(event) >= 0;
                var anchorNodes = animation.structural ? getAnchorNodes(node) : [];
                if (anchorNodes.length) {
                  var direction = enterOrMove ? 'to' : 'from';
                  forEach(anchorNodes, function(anchor) {
                    var key = anchor.getAttribute(NG_ANIMATE_REF_ATTR);
                    refLookup[key] = refLookup[key] || {};
                    refLookup[key][direction] = {
                      animationID: index,
                      element: jqLite(anchor)
                    };
                  });
                } else {
                  preparedAnimations.push(animation);
                }
              });
              var usedIndicesLookup = {};
              var anchorGroups = {};
              forEach(refLookup, function(operations, key) {
                var from = operations.from;
                var to = operations.to;
                if (!from || !to) {
                  var index = from ? from.animationID : to.animationID;
                  var indexKey = index.toString();
                  if (!usedIndicesLookup[indexKey]) {
                    usedIndicesLookup[indexKey] = true;
                    preparedAnimations.push(animations[index]);
                  }
                  return;
                }
                var fromAnimation = animations[from.animationID];
                var toAnimation = animations[to.animationID];
                var lookupKey = from.animationID.toString();
                if (!anchorGroups[lookupKey]) {
                  var group = anchorGroups[lookupKey] = {
                    structural: true,
                    beforeStart: function() {
                      fromAnimation.beforeStart();
                      toAnimation.beforeStart();
                    },
                    close: function() {
                      fromAnimation.close();
                      toAnimation.close();
                    },
                    classes: cssClassesIntersection(fromAnimation.classes, toAnimation.classes),
                    from: fromAnimation,
                    to: toAnimation,
                    anchors: []
                  };
                  if (group.classes.length) {
                    preparedAnimations.push(group);
                  } else {
                    preparedAnimations.push(fromAnimation);
                    preparedAnimations.push(toAnimation);
                  }
                }
                anchorGroups[lookupKey].anchors.push({
                  'out': from.element,
                  'in': to.element
                });
              });
              return preparedAnimations;
            }
            function cssClassesIntersection(a, b) {
              a = a.split(' ');
              b = b.split(' ');
              var matches = [];
              for (var i = 0; i < a.length; i++) {
                var aa = a[i];
                if (aa.substring(0, 3) === 'ng-')
                  continue;
                for (var j = 0; j < b.length; j++) {
                  if (aa === b[j]) {
                    matches.push(aa);
                    break;
                  }
                }
              }
              return matches.join(' ');
            }
            function invokeFirstDriver(animationDetails) {
              for (var i = drivers.length - 1; i >= 0; i--) {
                var driverName = drivers[i];
                var factory = $injector.get(driverName);
                var driver = factory(animationDetails);
                if (driver) {
                  return driver;
                }
              }
            }
            function beforeStart() {
              element.addClass(NG_ANIMATE_CLASSNAME);
              if (tempClasses) {
                $$jqLite.addClass(element, tempClasses);
              }
              if (prepareClassName) {
                $$jqLite.removeClass(element, prepareClassName);
                prepareClassName = null;
              }
            }
            function updateAnimationRunners(animation, newRunner) {
              if (animation.from && animation.to) {
                update(animation.from.element);
                update(animation.to.element);
              } else {
                update(animation.element);
              }
              function update(element) {
                var runner = getRunner(element);
                if (runner)
                  runner.setHost(newRunner);
              }
            }
            function handleDestroyedElement() {
              var runner = getRunner(element);
              if (runner && (event !== 'leave' || !options.$$domOperationFired)) {
                runner.end();
              }
            }
            function close(rejected) {
              element.off('$destroy', handleDestroyedElement);
              removeRunner(element);
              applyAnimationClasses(element, options);
              applyAnimationStyles(element, options);
              options.domOperation();
              if (tempClasses) {
                $$jqLite.removeClass(element, tempClasses);
              }
              element.removeClass(NG_ANIMATE_CLASSNAME);
              runner.complete(!rejected);
            }
          };
        }];
      }];
      var ngAnimateSwapDirective = ['$animate', '$rootScope', function($animate, $rootScope) {
        return {
          restrict: 'A',
          transclude: 'element',
          terminal: true,
          priority: 600,
          link: function(scope, $element, attrs, ctrl, $transclude) {
            var previousElement,
                previousScope;
            scope.$watchCollection(attrs.ngAnimateSwap || attrs['for'], function(value) {
              if (previousElement) {
                $animate.leave(previousElement);
              }
              if (previousScope) {
                previousScope.$destroy();
                previousScope = null;
              }
              if (value || value === 0) {
                previousScope = scope.$new();
                $transclude(previousScope, function(element) {
                  previousElement = element;
                  $animate.enter(element, null, $element);
                });
              }
            });
          }
        };
      }];
      angular.module('ngAnimate', []).directive('ngAnimateSwap', ngAnimateSwapDirective).directive('ngAnimateChildren', $$AnimateChildrenDirective).factory('$$rAFScheduler', $$rAFSchedulerFactory).provider('$$animateQueue', $$AnimateQueueProvider).provider('$$animation', $$AnimationProvider).provider('$animateCss', $AnimateCssProvider).provider('$$animateCssDriver', $$AnimateCssDriverProvider).provider('$$animateJs', $$AnimateJsProvider).provider('$$animateJsDriver', $$AnimateJsDriverProvider);
    })(window, window.angular);
  })();
  return _retrieveGlobal();
});

System.registerDynamic("github:angular/bower-angular-animate@1.5.7.js", ["github:angular/bower-angular-animate@1.5.7/angular-animate.js"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = $__require('github:angular/bower-angular-animate@1.5.7/angular-animate.js');
  global.define = __define;
  return module.exports;
});

System.registerDynamic("github:angular/bower-angular-messages@1.5.7/angular-messages.js", ["github:angular/bower-angular@1.5.7.js"], false, function(__require, __exports, __module) {
  var _retrieveGlobal = System.get("@@global-helpers").prepareGlobal(__module.id, null, null);
  (function() {
    "format global";
    "deps angular";
    (function(window, angular) {
      'use strict';
      var isArray = angular.isArray;
      var forEach = angular.forEach;
      var isString = angular.isString;
      var jqLite = angular.element;
      angular.module('ngMessages', []).directive('ngMessages', ['$animate', function($animate) {
        var ACTIVE_CLASS = 'ng-active';
        var INACTIVE_CLASS = 'ng-inactive';
        return {
          require: 'ngMessages',
          restrict: 'AE',
          controller: ['$element', '$scope', '$attrs', function($element, $scope, $attrs) {
            var ctrl = this;
            var latestKey = 0;
            var nextAttachId = 0;
            this.getAttachId = function getAttachId() {
              return nextAttachId++;
            };
            var messages = this.messages = {};
            var renderLater,
                cachedCollection;
            this.render = function(collection) {
              collection = collection || {};
              renderLater = false;
              cachedCollection = collection;
              var multiple = isAttrTruthy($scope, $attrs.ngMessagesMultiple) || isAttrTruthy($scope, $attrs.multiple);
              var unmatchedMessages = [];
              var matchedKeys = {};
              var messageItem = ctrl.head;
              var messageFound = false;
              var totalMessages = 0;
              while (messageItem != null) {
                totalMessages++;
                var messageCtrl = messageItem.message;
                var messageUsed = false;
                if (!messageFound) {
                  forEach(collection, function(value, key) {
                    if (!messageUsed && truthy(value) && messageCtrl.test(key)) {
                      if (matchedKeys[key])
                        return;
                      matchedKeys[key] = true;
                      messageUsed = true;
                      messageCtrl.attach();
                    }
                  });
                }
                if (messageUsed) {
                  messageFound = !multiple;
                } else {
                  unmatchedMessages.push(messageCtrl);
                }
                messageItem = messageItem.next;
              }
              forEach(unmatchedMessages, function(messageCtrl) {
                messageCtrl.detach();
              });
              unmatchedMessages.length !== totalMessages ? $animate.setClass($element, ACTIVE_CLASS, INACTIVE_CLASS) : $animate.setClass($element, INACTIVE_CLASS, ACTIVE_CLASS);
            };
            $scope.$watchCollection($attrs.ngMessages || $attrs['for'], ctrl.render);
            $element.on('$destroy', function() {
              forEach(messages, function(item) {
                item.message.detach();
              });
            });
            this.reRender = function() {
              if (!renderLater) {
                renderLater = true;
                $scope.$evalAsync(function() {
                  if (renderLater) {
                    cachedCollection && ctrl.render(cachedCollection);
                  }
                });
              }
            };
            this.register = function(comment, messageCtrl) {
              var nextKey = latestKey.toString();
              messages[nextKey] = {message: messageCtrl};
              insertMessageNode($element[0], comment, nextKey);
              comment.$$ngMessageNode = nextKey;
              latestKey++;
              ctrl.reRender();
            };
            this.deregister = function(comment) {
              var key = comment.$$ngMessageNode;
              delete comment.$$ngMessageNode;
              removeMessageNode($element[0], comment, key);
              delete messages[key];
              ctrl.reRender();
            };
            function findPreviousMessage(parent, comment) {
              var prevNode = comment;
              var parentLookup = [];
              while (prevNode && prevNode !== parent) {
                var prevKey = prevNode.$$ngMessageNode;
                if (prevKey && prevKey.length) {
                  return messages[prevKey];
                }
                if (prevNode.childNodes.length && parentLookup.indexOf(prevNode) === -1) {
                  parentLookup.push(prevNode);
                  prevNode = prevNode.childNodes[prevNode.childNodes.length - 1];
                } else if (prevNode.previousSibling) {
                  prevNode = prevNode.previousSibling;
                } else {
                  prevNode = prevNode.parentNode;
                  parentLookup.push(prevNode);
                }
              }
            }
            function insertMessageNode(parent, comment, key) {
              var messageNode = messages[key];
              if (!ctrl.head) {
                ctrl.head = messageNode;
              } else {
                var match = findPreviousMessage(parent, comment);
                if (match) {
                  messageNode.next = match.next;
                  match.next = messageNode;
                } else {
                  messageNode.next = ctrl.head;
                  ctrl.head = messageNode;
                }
              }
            }
            function removeMessageNode(parent, comment, key) {
              var messageNode = messages[key];
              var match = findPreviousMessage(parent, comment);
              if (match) {
                match.next = messageNode.next;
              } else {
                ctrl.head = messageNode.next;
              }
            }
          }]
        };
        function isAttrTruthy(scope, attr) {
          return (isString(attr) && attr.length === 0) || truthy(scope.$eval(attr));
        }
        function truthy(val) {
          return isString(val) ? val.length : !!val;
        }
      }]).directive('ngMessagesInclude', ['$templateRequest', '$document', '$compile', function($templateRequest, $document, $compile) {
        return {
          restrict: 'AE',
          require: '^^ngMessages',
          link: function($scope, element, attrs) {
            var src = attrs.ngMessagesInclude || attrs.src;
            $templateRequest(src).then(function(html) {
              if ($scope.$$destroyed)
                return;
              if (isString(html) && !html.trim()) {
                replaceElementWithMarker(element, src);
              } else {
                $compile(html)($scope, function(contents) {
                  element.after(contents);
                  replaceElementWithMarker(element, src);
                });
              }
            });
          }
        };
        function replaceElementWithMarker(element, src) {
          var comment = $compile.$$createComment ? $compile.$$createComment('ngMessagesInclude', src) : $document[0].createComment(' ngMessagesInclude: ' + src + ' ');
          var marker = jqLite(comment);
          element.after(marker);
          element.remove();
        }
      }]).directive('ngMessage', ngMessageDirectiveFactory()).directive('ngMessageExp', ngMessageDirectiveFactory());
      function ngMessageDirectiveFactory() {
        return ['$animate', function($animate) {
          return {
            restrict: 'AE',
            transclude: 'element',
            priority: 1,
            terminal: true,
            require: '^^ngMessages',
            link: function(scope, element, attrs, ngMessagesCtrl, $transclude) {
              var commentNode = element[0];
              var records;
              var staticExp = attrs.ngMessage || attrs.when;
              var dynamicExp = attrs.ngMessageExp || attrs.whenExp;
              var assignRecords = function(items) {
                records = items ? (isArray(items) ? items : items.split(/[\s,]+/)) : null;
                ngMessagesCtrl.reRender();
              };
              if (dynamicExp) {
                assignRecords(scope.$eval(dynamicExp));
                scope.$watchCollection(dynamicExp, assignRecords);
              } else {
                assignRecords(staticExp);
              }
              var currentElement,
                  messageCtrl;
              ngMessagesCtrl.register(commentNode, messageCtrl = {
                test: function(name) {
                  return contains(records, name);
                },
                attach: function() {
                  if (!currentElement) {
                    $transclude(function(elm, newScope) {
                      $animate.enter(elm, null, element);
                      currentElement = elm;
                      var $$attachId = currentElement.$$attachId = ngMessagesCtrl.getAttachId();
                      currentElement.on('$destroy', function() {
                        if (currentElement && currentElement.$$attachId === $$attachId) {
                          ngMessagesCtrl.deregister(commentNode);
                          messageCtrl.detach();
                        }
                        newScope.$destroy();
                      });
                    });
                  }
                },
                detach: function() {
                  if (currentElement) {
                    var elm = currentElement;
                    currentElement = null;
                    $animate.leave(elm);
                  }
                }
              });
            }
          };
        }];
        function contains(collection, key) {
          if (collection) {
            return isArray(collection) ? collection.indexOf(key) >= 0 : collection.hasOwnProperty(key);
          }
        }
      }
    })(window, window.angular);
  })();
  return _retrieveGlobal();
});

System.registerDynamic("github:angular/bower-angular-messages@1.5.7.js", ["github:angular/bower-angular-messages@1.5.7/angular-messages.js"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = $__require('github:angular/bower-angular-messages@1.5.7/angular-messages.js');
  global.define = __define;
  return module.exports;
});

System.registerDynamic("github:angular/bower-angular-mocks@1.5.7/angular-mocks.js", ["github:angular/bower-angular@1.5.7.js"], false, function(__require, __exports, __module) {
  var _retrieveGlobal = System.get("@@global-helpers").prepareGlobal(__module.id, null, null);
  (function() {
    "format global";
    "deps angular";
    (function(window, angular) {
      'use strict';
      angular.mock = {};
      angular.mock.$BrowserProvider = function() {
        this.$get = function() {
          return new angular.mock.$Browser();
        };
      };
      angular.mock.$Browser = function() {
        var self = this;
        this.isMock = true;
        self.$$url = "http://server/";
        self.$$lastUrl = self.$$url;
        self.pollFns = [];
        self.$$completeOutstandingRequest = angular.noop;
        self.$$incOutstandingRequestCount = angular.noop;
        self.onUrlChange = function(listener) {
          self.pollFns.push(function() {
            if (self.$$lastUrl !== self.$$url || self.$$state !== self.$$lastState) {
              self.$$lastUrl = self.$$url;
              self.$$lastState = self.$$state;
              listener(self.$$url, self.$$state);
            }
          });
          return listener;
        };
        self.$$applicationDestroyed = angular.noop;
        self.$$checkUrlChange = angular.noop;
        self.deferredFns = [];
        self.deferredNextId = 0;
        self.defer = function(fn, delay) {
          delay = delay || 0;
          self.deferredFns.push({
            time: (self.defer.now + delay),
            fn: fn,
            id: self.deferredNextId
          });
          self.deferredFns.sort(function(a, b) {
            return a.time - b.time;
          });
          return self.deferredNextId++;
        };
        self.defer.now = 0;
        self.defer.cancel = function(deferId) {
          var fnIndex;
          angular.forEach(self.deferredFns, function(fn, index) {
            if (fn.id === deferId)
              fnIndex = index;
          });
          if (angular.isDefined(fnIndex)) {
            self.deferredFns.splice(fnIndex, 1);
            return true;
          }
          return false;
        };
        self.defer.flush = function(delay) {
          if (angular.isDefined(delay)) {
            self.defer.now += delay;
          } else {
            if (self.deferredFns.length) {
              self.defer.now = self.deferredFns[self.deferredFns.length - 1].time;
            } else {
              throw new Error('No deferred tasks to be flushed');
            }
          }
          while (self.deferredFns.length && self.deferredFns[0].time <= self.defer.now) {
            self.deferredFns.shift().fn();
          }
        };
        self.$$baseHref = '/';
        self.baseHref = function() {
          return this.$$baseHref;
        };
      };
      angular.mock.$Browser.prototype = {
        poll: function poll() {
          angular.forEach(this.pollFns, function(pollFn) {
            pollFn();
          });
        },
        url: function(url, replace, state) {
          if (angular.isUndefined(state)) {
            state = null;
          }
          if (url) {
            this.$$url = url;
            this.$$state = angular.copy(state);
            return this;
          }
          return this.$$url;
        },
        state: function() {
          return this.$$state;
        },
        notifyWhenNoOutstandingRequests: function(fn) {
          fn();
        }
      };
      angular.mock.$ExceptionHandlerProvider = function() {
        var handler;
        this.mode = function(mode) {
          switch (mode) {
            case 'log':
            case 'rethrow':
              var errors = [];
              handler = function(e) {
                if (arguments.length == 1) {
                  errors.push(e);
                } else {
                  errors.push([].slice.call(arguments, 0));
                }
                if (mode === "rethrow") {
                  throw e;
                }
              };
              handler.errors = errors;
              break;
            default:
              throw new Error("Unknown mode '" + mode + "', only 'log'/'rethrow' modes are allowed!");
          }
        };
        this.$get = function() {
          return handler;
        };
        this.mode('rethrow');
      };
      angular.mock.$LogProvider = function() {
        var debug = true;
        function concat(array1, array2, index) {
          return array1.concat(Array.prototype.slice.call(array2, index));
        }
        this.debugEnabled = function(flag) {
          if (angular.isDefined(flag)) {
            debug = flag;
            return this;
          } else {
            return debug;
          }
        };
        this.$get = function() {
          var $log = {
            log: function() {
              $log.log.logs.push(concat([], arguments, 0));
            },
            warn: function() {
              $log.warn.logs.push(concat([], arguments, 0));
            },
            info: function() {
              $log.info.logs.push(concat([], arguments, 0));
            },
            error: function() {
              $log.error.logs.push(concat([], arguments, 0));
            },
            debug: function() {
              if (debug) {
                $log.debug.logs.push(concat([], arguments, 0));
              }
            }
          };
          $log.reset = function() {
            $log.log.logs = [];
            $log.info.logs = [];
            $log.warn.logs = [];
            $log.error.logs = [];
            $log.debug.logs = [];
          };
          $log.assertEmpty = function() {
            var errors = [];
            angular.forEach(['error', 'warn', 'info', 'log', 'debug'], function(logLevel) {
              angular.forEach($log[logLevel].logs, function(log) {
                angular.forEach(log, function(logItem) {
                  errors.push('MOCK $log (' + logLevel + '): ' + String(logItem) + '\n' + (logItem.stack || ''));
                });
              });
            });
            if (errors.length) {
              errors.unshift("Expected $log to be empty! Either a message was logged unexpectedly, or " + "an expected log message was not checked and removed:");
              errors.push('');
              throw new Error(errors.join('\n---------\n'));
            }
          };
          $log.reset();
          return $log;
        };
      };
      angular.mock.$IntervalProvider = function() {
        this.$get = ['$browser', '$rootScope', '$q', '$$q', function($browser, $rootScope, $q, $$q) {
          var repeatFns = [],
              nextRepeatId = 0,
              now = 0;
          var $interval = function(fn, delay, count, invokeApply) {
            var hasParams = arguments.length > 4,
                args = hasParams ? Array.prototype.slice.call(arguments, 4) : [],
                iteration = 0,
                skipApply = (angular.isDefined(invokeApply) && !invokeApply),
                deferred = (skipApply ? $$q : $q).defer(),
                promise = deferred.promise;
            count = (angular.isDefined(count)) ? count : 0;
            promise.then(null, null, (!hasParams) ? fn : function() {
              fn.apply(null, args);
            });
            promise.$$intervalId = nextRepeatId;
            function tick() {
              deferred.notify(iteration++);
              if (count > 0 && iteration >= count) {
                var fnIndex;
                deferred.resolve(iteration);
                angular.forEach(repeatFns, function(fn, index) {
                  if (fn.id === promise.$$intervalId)
                    fnIndex = index;
                });
                if (angular.isDefined(fnIndex)) {
                  repeatFns.splice(fnIndex, 1);
                }
              }
              if (skipApply) {
                $browser.defer.flush();
              } else {
                $rootScope.$apply();
              }
            }
            repeatFns.push({
              nextTime: (now + delay),
              delay: delay,
              fn: tick,
              id: nextRepeatId,
              deferred: deferred
            });
            repeatFns.sort(function(a, b) {
              return a.nextTime - b.nextTime;
            });
            nextRepeatId++;
            return promise;
          };
          $interval.cancel = function(promise) {
            if (!promise)
              return false;
            var fnIndex;
            angular.forEach(repeatFns, function(fn, index) {
              if (fn.id === promise.$$intervalId)
                fnIndex = index;
            });
            if (angular.isDefined(fnIndex)) {
              repeatFns[fnIndex].deferred.reject('canceled');
              repeatFns.splice(fnIndex, 1);
              return true;
            }
            return false;
          };
          $interval.flush = function(millis) {
            now += millis;
            while (repeatFns.length && repeatFns[0].nextTime <= now) {
              var task = repeatFns[0];
              task.fn();
              task.nextTime += task.delay;
              repeatFns.sort(function(a, b) {
                return a.nextTime - b.nextTime;
              });
            }
            return millis;
          };
          return $interval;
        }];
      };
      var R_ISO8061_STR = /^(-?\d{4})-?(\d\d)-?(\d\d)(?:T(\d\d)(?:\:?(\d\d)(?:\:?(\d\d)(?:\.(\d{3}))?)?)?(Z|([+-])(\d\d):?(\d\d)))?$/;
      function jsonStringToDate(string) {
        var match;
        if (match = string.match(R_ISO8061_STR)) {
          var date = new Date(0),
              tzHour = 0,
              tzMin = 0;
          if (match[9]) {
            tzHour = toInt(match[9] + match[10]);
            tzMin = toInt(match[9] + match[11]);
          }
          date.setUTCFullYear(toInt(match[1]), toInt(match[2]) - 1, toInt(match[3]));
          date.setUTCHours(toInt(match[4] || 0) - tzHour, toInt(match[5] || 0) - tzMin, toInt(match[6] || 0), toInt(match[7] || 0));
          return date;
        }
        return string;
      }
      function toInt(str) {
        return parseInt(str, 10);
      }
      function padNumberInMock(num, digits, trim) {
        var neg = '';
        if (num < 0) {
          neg = '-';
          num = -num;
        }
        num = '' + num;
        while (num.length < digits)
          num = '0' + num;
        if (trim) {
          num = num.substr(num.length - digits);
        }
        return neg + num;
      }
      angular.mock.TzDate = function(offset, timestamp) {
        var self = new Date(0);
        if (angular.isString(timestamp)) {
          var tsStr = timestamp;
          self.origDate = jsonStringToDate(timestamp);
          timestamp = self.origDate.getTime();
          if (isNaN(timestamp)) {
            throw {
              name: "Illegal Argument",
              message: "Arg '" + tsStr + "' passed into TzDate constructor is not a valid date string"
            };
          }
        } else {
          self.origDate = new Date(timestamp);
        }
        var localOffset = new Date(timestamp).getTimezoneOffset();
        self.offsetDiff = localOffset * 60 * 1000 - offset * 1000 * 60 * 60;
        self.date = new Date(timestamp + self.offsetDiff);
        self.getTime = function() {
          return self.date.getTime() - self.offsetDiff;
        };
        self.toLocaleDateString = function() {
          return self.date.toLocaleDateString();
        };
        self.getFullYear = function() {
          return self.date.getFullYear();
        };
        self.getMonth = function() {
          return self.date.getMonth();
        };
        self.getDate = function() {
          return self.date.getDate();
        };
        self.getHours = function() {
          return self.date.getHours();
        };
        self.getMinutes = function() {
          return self.date.getMinutes();
        };
        self.getSeconds = function() {
          return self.date.getSeconds();
        };
        self.getMilliseconds = function() {
          return self.date.getMilliseconds();
        };
        self.getTimezoneOffset = function() {
          return offset * 60;
        };
        self.getUTCFullYear = function() {
          return self.origDate.getUTCFullYear();
        };
        self.getUTCMonth = function() {
          return self.origDate.getUTCMonth();
        };
        self.getUTCDate = function() {
          return self.origDate.getUTCDate();
        };
        self.getUTCHours = function() {
          return self.origDate.getUTCHours();
        };
        self.getUTCMinutes = function() {
          return self.origDate.getUTCMinutes();
        };
        self.getUTCSeconds = function() {
          return self.origDate.getUTCSeconds();
        };
        self.getUTCMilliseconds = function() {
          return self.origDate.getUTCMilliseconds();
        };
        self.getDay = function() {
          return self.date.getDay();
        };
        if (self.toISOString) {
          self.toISOString = function() {
            return padNumberInMock(self.origDate.getUTCFullYear(), 4) + '-' + padNumberInMock(self.origDate.getUTCMonth() + 1, 2) + '-' + padNumberInMock(self.origDate.getUTCDate(), 2) + 'T' + padNumberInMock(self.origDate.getUTCHours(), 2) + ':' + padNumberInMock(self.origDate.getUTCMinutes(), 2) + ':' + padNumberInMock(self.origDate.getUTCSeconds(), 2) + '.' + padNumberInMock(self.origDate.getUTCMilliseconds(), 3) + 'Z';
          };
        }
        var unimplementedMethods = ['getUTCDay', 'getYear', 'setDate', 'setFullYear', 'setHours', 'setMilliseconds', 'setMinutes', 'setMonth', 'setSeconds', 'setTime', 'setUTCDate', 'setUTCFullYear', 'setUTCHours', 'setUTCMilliseconds', 'setUTCMinutes', 'setUTCMonth', 'setUTCSeconds', 'setYear', 'toDateString', 'toGMTString', 'toJSON', 'toLocaleFormat', 'toLocaleString', 'toLocaleTimeString', 'toSource', 'toString', 'toTimeString', 'toUTCString', 'valueOf'];
        angular.forEach(unimplementedMethods, function(methodName) {
          self[methodName] = function() {
            throw new Error("Method '" + methodName + "' is not implemented in the TzDate mock");
          };
        });
        return self;
      };
      angular.mock.TzDate.prototype = Date.prototype;
      angular.mock.animate = angular.module('ngAnimateMock', ['ng']).config(['$provide', function($provide) {
        $provide.factory('$$forceReflow', function() {
          function reflowFn() {
            reflowFn.totalReflows++;
          }
          reflowFn.totalReflows = 0;
          return reflowFn;
        });
        $provide.factory('$$animateAsyncRun', function() {
          var queue = [];
          var queueFn = function() {
            return function(fn) {
              queue.push(fn);
            };
          };
          queueFn.flush = function() {
            if (queue.length === 0)
              return false;
            for (var i = 0; i < queue.length; i++) {
              queue[i]();
            }
            queue = [];
            return true;
          };
          return queueFn;
        });
        $provide.decorator('$$animateJs', ['$delegate', function($delegate) {
          var runners = [];
          var animateJsConstructor = function() {
            var animator = $delegate.apply($delegate, arguments);
            if (animator) {
              runners.push(animator);
            }
            return animator;
          };
          animateJsConstructor.$closeAndFlush = function() {
            runners.forEach(function(runner) {
              runner.end();
            });
            runners = [];
          };
          return animateJsConstructor;
        }]);
        $provide.decorator('$animateCss', ['$delegate', function($delegate) {
          var runners = [];
          var animateCssConstructor = function(element, options) {
            var animator = $delegate(element, options);
            runners.push(animator);
            return animator;
          };
          animateCssConstructor.$closeAndFlush = function() {
            runners.forEach(function(runner) {
              runner.end();
            });
            runners = [];
          };
          return animateCssConstructor;
        }]);
        $provide.decorator('$animate', ['$delegate', '$timeout', '$browser', '$$rAF', '$animateCss', '$$animateJs', '$$forceReflow', '$$animateAsyncRun', '$rootScope', function($delegate, $timeout, $browser, $$rAF, $animateCss, $$animateJs, $$forceReflow, $$animateAsyncRun, $rootScope) {
          var animate = {
            queue: [],
            cancel: $delegate.cancel,
            on: $delegate.on,
            off: $delegate.off,
            pin: $delegate.pin,
            get reflows() {
              return $$forceReflow.totalReflows;
            },
            enabled: $delegate.enabled,
            closeAndFlush: function() {
              this.flush(true);
              $animateCss.$closeAndFlush();
              $$animateJs.$closeAndFlush();
              this.flush();
            },
            flush: function(hideErrors) {
              $rootScope.$digest();
              var doNextRun,
                  somethingFlushed = false;
              do {
                doNextRun = false;
                if ($$rAF.queue.length) {
                  $$rAF.flush();
                  doNextRun = somethingFlushed = true;
                }
                if ($$animateAsyncRun.flush()) {
                  doNextRun = somethingFlushed = true;
                }
              } while (doNextRun);
              if (!somethingFlushed && !hideErrors) {
                throw new Error('No pending animations ready to be closed or flushed');
              }
              $rootScope.$digest();
            }
          };
          angular.forEach(['animate', 'enter', 'leave', 'move', 'addClass', 'removeClass', 'setClass'], function(method) {
            animate[method] = function() {
              animate.queue.push({
                event: method,
                element: arguments[0],
                options: arguments[arguments.length - 1],
                args: arguments
              });
              return $delegate[method].apply($delegate, arguments);
            };
          });
          return animate;
        }]);
      }]);
      angular.mock.dump = function(object) {
        return serialize(object);
        function serialize(object) {
          var out;
          if (angular.isElement(object)) {
            object = angular.element(object);
            out = angular.element('<div></div>');
            angular.forEach(object, function(element) {
              out.append(angular.element(element).clone());
            });
            out = out.html();
          } else if (angular.isArray(object)) {
            out = [];
            angular.forEach(object, function(o) {
              out.push(serialize(o));
            });
            out = '[ ' + out.join(', ') + ' ]';
          } else if (angular.isObject(object)) {
            if (angular.isFunction(object.$eval) && angular.isFunction(object.$apply)) {
              out = serializeScope(object);
            } else if (object instanceof Error) {
              out = object.stack || ('' + object.name + ': ' + object.message);
            } else {
              out = angular.toJson(object, true);
            }
          } else {
            out = String(object);
          }
          return out;
        }
        function serializeScope(scope, offset) {
          offset = offset || '  ';
          var log = [offset + 'Scope(' + scope.$id + '): {'];
          for (var key in scope) {
            if (Object.prototype.hasOwnProperty.call(scope, key) && !key.match(/^(\$|this)/)) {
              log.push('  ' + key + ': ' + angular.toJson(scope[key]));
            }
          }
          var child = scope.$$childHead;
          while (child) {
            log.push(serializeScope(child, offset + '  '));
            child = child.$$nextSibling;
          }
          log.push('}');
          return log.join('\n' + offset);
        }
      };
      angular.mock.$HttpBackendProvider = function() {
        this.$get = ['$rootScope', '$timeout', createHttpBackendMock];
      };
      function createHttpBackendMock($rootScope, $timeout, $delegate, $browser) {
        var definitions = [],
            expectations = [],
            responses = [],
            responsesPush = angular.bind(responses, responses.push),
            copy = angular.copy;
        function createResponse(status, data, headers, statusText) {
          if (angular.isFunction(status))
            return status;
          return function() {
            return angular.isNumber(status) ? [status, data, headers, statusText] : [200, status, data, headers];
          };
        }
        function $httpBackend(method, url, data, callback, headers, timeout, withCredentials, responseType, eventHandlers, uploadEventHandlers) {
          var xhr = new MockXhr(),
              expectation = expectations[0],
              wasExpected = false;
          xhr.$$events = eventHandlers;
          xhr.upload.$$events = uploadEventHandlers;
          function prettyPrint(data) {
            return (angular.isString(data) || angular.isFunction(data) || data instanceof RegExp) ? data : angular.toJson(data);
          }
          function wrapResponse(wrapped) {
            if (!$browser && timeout) {
              timeout.then ? timeout.then(handleTimeout) : $timeout(handleTimeout, timeout);
            }
            return handleResponse;
            function handleResponse() {
              var response = wrapped.response(method, url, data, headers, wrapped.params(url));
              xhr.$$respHeaders = response[2];
              callback(copy(response[0]), copy(response[1]), xhr.getAllResponseHeaders(), copy(response[3] || ''));
            }
            function handleTimeout() {
              for (var i = 0,
                  ii = responses.length; i < ii; i++) {
                if (responses[i] === handleResponse) {
                  responses.splice(i, 1);
                  callback(-1, undefined, '');
                  break;
                }
              }
            }
          }
          if (expectation && expectation.match(method, url)) {
            if (!expectation.matchData(data)) {
              throw new Error('Expected ' + expectation + ' with different data\n' + 'EXPECTED: ' + prettyPrint(expectation.data) + '\nGOT:      ' + data);
            }
            if (!expectation.matchHeaders(headers)) {
              throw new Error('Expected ' + expectation + ' with different headers\n' + 'EXPECTED: ' + prettyPrint(expectation.headers) + '\nGOT:      ' + prettyPrint(headers));
            }
            expectations.shift();
            if (expectation.response) {
              responses.push(wrapResponse(expectation));
              return;
            }
            wasExpected = true;
          }
          var i = -1,
              definition;
          while ((definition = definitions[++i])) {
            if (definition.match(method, url, data, headers || {})) {
              if (definition.response) {
                ($browser ? $browser.defer : responsesPush)(wrapResponse(definition));
              } else if (definition.passThrough) {
                $delegate(method, url, data, callback, headers, timeout, withCredentials, responseType, eventHandlers, uploadEventHandlers);
              } else
                throw new Error('No response defined !');
              return;
            }
          }
          throw wasExpected ? new Error('No response defined !') : new Error('Unexpected request: ' + method + ' ' + url + '\n' + (expectation ? 'Expected ' + expectation : 'No more request expected'));
        }
        $httpBackend.when = function(method, url, data, headers, keys) {
          var definition = new MockHttpExpectation(method, url, data, headers, keys),
              chain = {respond: function(status, data, headers, statusText) {
                  definition.passThrough = undefined;
                  definition.response = createResponse(status, data, headers, statusText);
                  return chain;
                }};
          if ($browser) {
            chain.passThrough = function() {
              definition.response = undefined;
              definition.passThrough = true;
              return chain;
            };
          }
          definitions.push(definition);
          return chain;
        };
        createShortMethods('when');
        $httpBackend.whenRoute = function(method, url) {
          var pathObj = parseRoute(url);
          return $httpBackend.when(method, pathObj.regexp, undefined, undefined, pathObj.keys);
        };
        function parseRoute(url) {
          var ret = {regexp: url},
              keys = ret.keys = [];
          if (!url || !angular.isString(url))
            return ret;
          url = url.replace(/([().])/g, '\\$1').replace(/(\/)?:(\w+)([\?\*])?/g, function(_, slash, key, option) {
            var optional = option === '?' ? option : null;
            var star = option === '*' ? option : null;
            keys.push({
              name: key,
              optional: !!optional
            });
            slash = slash || '';
            return '' + (optional ? '' : slash) + '(?:' + (optional ? slash : '') + (star && '(.+?)' || '([^/]+)') + (optional || '') + ')' + (optional || '');
          }).replace(/([\/$\*])/g, '\\$1');
          ret.regexp = new RegExp('^' + url, 'i');
          return ret;
        }
        $httpBackend.expect = function(method, url, data, headers, keys) {
          var expectation = new MockHttpExpectation(method, url, data, headers, keys),
              chain = {respond: function(status, data, headers, statusText) {
                  expectation.response = createResponse(status, data, headers, statusText);
                  return chain;
                }};
          expectations.push(expectation);
          return chain;
        };
        createShortMethods('expect');
        $httpBackend.expectRoute = function(method, url) {
          var pathObj = parseRoute(url);
          return $httpBackend.expect(method, pathObj.regexp, undefined, undefined, pathObj.keys);
        };
        $httpBackend.flush = function(count, digest) {
          if (digest !== false)
            $rootScope.$digest();
          if (!responses.length)
            throw new Error('No pending request to flush !');
          if (angular.isDefined(count) && count !== null) {
            while (count--) {
              if (!responses.length)
                throw new Error('No more pending request to flush !');
              responses.shift()();
            }
          } else {
            while (responses.length) {
              responses.shift()();
            }
          }
          $httpBackend.verifyNoOutstandingExpectation(digest);
        };
        $httpBackend.verifyNoOutstandingExpectation = function(digest) {
          if (digest !== false)
            $rootScope.$digest();
          if (expectations.length) {
            throw new Error('Unsatisfied requests: ' + expectations.join(', '));
          }
        };
        $httpBackend.verifyNoOutstandingRequest = function() {
          if (responses.length) {
            throw new Error('Unflushed requests: ' + responses.length);
          }
        };
        $httpBackend.resetExpectations = function() {
          expectations.length = 0;
          responses.length = 0;
        };
        return $httpBackend;
        function createShortMethods(prefix) {
          angular.forEach(['GET', 'DELETE', 'JSONP', 'HEAD'], function(method) {
            $httpBackend[prefix + method] = function(url, headers, keys) {
              return $httpBackend[prefix](method, url, undefined, headers, keys);
            };
          });
          angular.forEach(['PUT', 'POST', 'PATCH'], function(method) {
            $httpBackend[prefix + method] = function(url, data, headers, keys) {
              return $httpBackend[prefix](method, url, data, headers, keys);
            };
          });
        }
      }
      function MockHttpExpectation(method, url, data, headers, keys) {
        function getUrlParams(u) {
          var params = u.slice(u.indexOf('?') + 1).split('&');
          return params.sort();
        }
        function compareUrl(u) {
          return (url.slice(0, url.indexOf('?')) == u.slice(0, u.indexOf('?')) && getUrlParams(url).join() == getUrlParams(u).join());
        }
        this.data = data;
        this.headers = headers;
        this.match = function(m, u, d, h) {
          if (method != m)
            return false;
          if (!this.matchUrl(u))
            return false;
          if (angular.isDefined(d) && !this.matchData(d))
            return false;
          if (angular.isDefined(h) && !this.matchHeaders(h))
            return false;
          return true;
        };
        this.matchUrl = function(u) {
          if (!url)
            return true;
          if (angular.isFunction(url.test))
            return url.test(u);
          if (angular.isFunction(url))
            return url(u);
          return (url == u || compareUrl(u));
        };
        this.matchHeaders = function(h) {
          if (angular.isUndefined(headers))
            return true;
          if (angular.isFunction(headers))
            return headers(h);
          return angular.equals(headers, h);
        };
        this.matchData = function(d) {
          if (angular.isUndefined(data))
            return true;
          if (data && angular.isFunction(data.test))
            return data.test(d);
          if (data && angular.isFunction(data))
            return data(d);
          if (data && !angular.isString(data)) {
            return angular.equals(angular.fromJson(angular.toJson(data)), angular.fromJson(d));
          }
          return data == d;
        };
        this.toString = function() {
          return method + ' ' + url;
        };
        this.params = function(u) {
          return angular.extend(parseQuery(), pathParams());
          function pathParams() {
            var keyObj = {};
            if (!url || !angular.isFunction(url.test) || !keys || keys.length === 0)
              return keyObj;
            var m = url.exec(u);
            if (!m)
              return keyObj;
            for (var i = 1,
                len = m.length; i < len; ++i) {
              var key = keys[i - 1];
              var val = m[i];
              if (key && val) {
                keyObj[key.name || key] = val;
              }
            }
            return keyObj;
          }
          function parseQuery() {
            var obj = {},
                key_value,
                key,
                queryStr = u.indexOf('?') > -1 ? u.substring(u.indexOf('?') + 1) : "";
            angular.forEach(queryStr.split('&'), function(keyValue) {
              if (keyValue) {
                key_value = keyValue.replace(/\+/g, '%20').split('=');
                key = tryDecodeURIComponent(key_value[0]);
                if (angular.isDefined(key)) {
                  var val = angular.isDefined(key_value[1]) ? tryDecodeURIComponent(key_value[1]) : true;
                  if (!hasOwnProperty.call(obj, key)) {
                    obj[key] = val;
                  } else if (angular.isArray(obj[key])) {
                    obj[key].push(val);
                  } else {
                    obj[key] = [obj[key], val];
                  }
                }
              }
            });
            return obj;
          }
          function tryDecodeURIComponent(value) {
            try {
              return decodeURIComponent(value);
            } catch (e) {}
          }
        };
      }
      function createMockXhr() {
        return new MockXhr();
      }
      function MockXhr() {
        MockXhr.$$lastInstance = this;
        this.open = function(method, url, async) {
          this.$$method = method;
          this.$$url = url;
          this.$$async = async;
          this.$$reqHeaders = {};
          this.$$respHeaders = {};
        };
        this.send = function(data) {
          this.$$data = data;
        };
        this.setRequestHeader = function(key, value) {
          this.$$reqHeaders[key] = value;
        };
        this.getResponseHeader = function(name) {
          var header = this.$$respHeaders[name];
          if (header)
            return header;
          name = angular.lowercase(name);
          header = this.$$respHeaders[name];
          if (header)
            return header;
          header = undefined;
          angular.forEach(this.$$respHeaders, function(headerVal, headerName) {
            if (!header && angular.lowercase(headerName) == name)
              header = headerVal;
          });
          return header;
        };
        this.getAllResponseHeaders = function() {
          var lines = [];
          angular.forEach(this.$$respHeaders, function(value, key) {
            lines.push(key + ': ' + value);
          });
          return lines.join('\n');
        };
        this.abort = angular.noop;
        this.$$events = {};
        this.addEventListener = function(name, listener) {
          if (angular.isUndefined(this.$$events[name]))
            this.$$events[name] = [];
          this.$$events[name].push(listener);
        };
        this.upload = {
          $$events: {},
          addEventListener: this.addEventListener
        };
      }
      angular.mock.$TimeoutDecorator = ['$delegate', '$browser', function($delegate, $browser) {
        $delegate.flush = function(delay) {
          $browser.defer.flush(delay);
        };
        $delegate.verifyNoPendingTasks = function() {
          if ($browser.deferredFns.length) {
            throw new Error('Deferred tasks to flush (' + $browser.deferredFns.length + '): ' + formatPendingTasksAsString($browser.deferredFns));
          }
        };
        function formatPendingTasksAsString(tasks) {
          var result = [];
          angular.forEach(tasks, function(task) {
            result.push('{id: ' + task.id + ', ' + 'time: ' + task.time + '}');
          });
          return result.join(', ');
        }
        return $delegate;
      }];
      angular.mock.$RAFDecorator = ['$delegate', function($delegate) {
        var rafFn = function(fn) {
          var index = rafFn.queue.length;
          rafFn.queue.push(fn);
          return function() {
            rafFn.queue.splice(index, 1);
          };
        };
        rafFn.queue = [];
        rafFn.supported = $delegate.supported;
        rafFn.flush = function() {
          if (rafFn.queue.length === 0) {
            throw new Error('No rAF callbacks present');
          }
          var length = rafFn.queue.length;
          for (var i = 0; i < length; i++) {
            rafFn.queue[i]();
          }
          rafFn.queue = rafFn.queue.slice(i);
        };
        return rafFn;
      }];
      var originalRootElement;
      angular.mock.$RootElementProvider = function() {
        this.$get = ['$injector', function($injector) {
          originalRootElement = angular.element('<div ng-app></div>').data('$injector', $injector);
          return originalRootElement;
        }];
      };
      angular.mock.$ControllerDecorator = ['$delegate', function($delegate) {
        return function(expression, locals, later, ident) {
          if (later && typeof later === 'object') {
            var instantiate = $delegate(expression, locals, true, ident);
            angular.extend(instantiate.instance, later);
            var instance = instantiate();
            if (instance !== instantiate.instance) {
              angular.extend(instance, later);
            }
            return instance;
          }
          return $delegate(expression, locals, later, ident);
        };
      }];
      angular.mock.$ComponentControllerProvider = ['$compileProvider', function($compileProvider) {
        this.$get = ['$controller', '$injector', '$rootScope', function($controller, $injector, $rootScope) {
          return function $componentController(componentName, locals, bindings, ident) {
            var directives = $injector.get(componentName + 'Directive');
            var candidateDirectives = directives.filter(function(directiveInfo) {
              return directiveInfo.controller && directiveInfo.controllerAs && directiveInfo.restrict === 'E';
            });
            if (candidateDirectives.length === 0) {
              throw new Error('No component found');
            }
            if (candidateDirectives.length > 1) {
              throw new Error('Too many components found');
            }
            var directiveInfo = candidateDirectives[0];
            locals = locals || {};
            locals.$scope = locals.$scope || $rootScope.$new(true);
            return $controller(directiveInfo.controller, locals, bindings, ident || directiveInfo.controllerAs);
          };
        }];
      }];
      angular.module('ngMock', ['ng']).provider({
        $browser: angular.mock.$BrowserProvider,
        $exceptionHandler: angular.mock.$ExceptionHandlerProvider,
        $log: angular.mock.$LogProvider,
        $interval: angular.mock.$IntervalProvider,
        $httpBackend: angular.mock.$HttpBackendProvider,
        $rootElement: angular.mock.$RootElementProvider,
        $componentController: angular.mock.$ComponentControllerProvider
      }).config(['$provide', function($provide) {
        $provide.decorator('$timeout', angular.mock.$TimeoutDecorator);
        $provide.decorator('$$rAF', angular.mock.$RAFDecorator);
        $provide.decorator('$rootScope', angular.mock.$RootScopeDecorator);
        $provide.decorator('$controller', angular.mock.$ControllerDecorator);
      }]);
      angular.module('ngMockE2E', ['ng']).config(['$provide', function($provide) {
        $provide.value('$httpBackend', angular.injector(['ng']).get('$httpBackend'));
        $provide.decorator('$httpBackend', angular.mock.e2e.$httpBackendDecorator);
      }]);
      angular.mock.e2e = {};
      angular.mock.e2e.$httpBackendDecorator = ['$rootScope', '$timeout', '$delegate', '$browser', createHttpBackendMock];
      angular.mock.$RootScopeDecorator = ['$delegate', function($delegate) {
        var $rootScopePrototype = Object.getPrototypeOf($delegate);
        $rootScopePrototype.$countChildScopes = countChildScopes;
        $rootScopePrototype.$countWatchers = countWatchers;
        return $delegate;
        function countChildScopes() {
          var count = 0;
          var pendingChildHeads = [this.$$childHead];
          var currentScope;
          while (pendingChildHeads.length) {
            currentScope = pendingChildHeads.shift();
            while (currentScope) {
              count += 1;
              pendingChildHeads.push(currentScope.$$childHead);
              currentScope = currentScope.$$nextSibling;
            }
          }
          return count;
        }
        function countWatchers() {
          var count = this.$$watchers ? this.$$watchers.length : 0;
          var pendingChildHeads = [this.$$childHead];
          var currentScope;
          while (pendingChildHeads.length) {
            currentScope = pendingChildHeads.shift();
            while (currentScope) {
              count += currentScope.$$watchers ? currentScope.$$watchers.length : 0;
              pendingChildHeads.push(currentScope.$$childHead);
              currentScope = currentScope.$$nextSibling;
            }
          }
          return count;
        }
      }];
      !(function(jasmineOrMocha) {
        if (!jasmineOrMocha) {
          return;
        }
        var currentSpec = null,
            injectorState = new InjectorState(),
            annotatedFunctions = [],
            wasInjectorCreated = function() {
              return !!currentSpec;
            };
        angular.mock.$$annotate = angular.injector.$$annotate;
        angular.injector.$$annotate = function(fn) {
          if (typeof fn === 'function' && !fn.$inject) {
            annotatedFunctions.push(fn);
          }
          return angular.mock.$$annotate.apply(this, arguments);
        };
        var module = window.module = angular.mock.module = function() {
          var moduleFns = Array.prototype.slice.call(arguments, 0);
          return wasInjectorCreated() ? workFn() : workFn;
          function workFn() {
            if (currentSpec.$injector) {
              throw new Error('Injector already created, can not register a module!');
            } else {
              var fn,
                  modules = currentSpec.$modules || (currentSpec.$modules = []);
              angular.forEach(moduleFns, function(module) {
                if (angular.isObject(module) && !angular.isArray(module)) {
                  fn = ['$provide', function($provide) {
                    angular.forEach(module, function(value, key) {
                      $provide.value(key, value);
                    });
                  }];
                } else {
                  fn = module;
                }
                if (currentSpec.$providerInjector) {
                  currentSpec.$providerInjector.invoke(fn);
                } else {
                  modules.push(fn);
                }
              });
            }
          }
        };
        module.$$beforeAllHook = (window.before || window.beforeAll);
        module.$$afterAllHook = (window.after || window.afterAll);
        module.$$currentSpec = function(to) {
          if (arguments.length === 0)
            return to;
          currentSpec = to;
        };
        module.sharedInjector = function() {
          if (!(module.$$beforeAllHook && module.$$afterAllHook)) {
            throw Error("sharedInjector() cannot be used unless your test runner defines beforeAll/afterAll");
          }
          var initialized = false;
          module.$$beforeAllHook(function() {
            if (injectorState.shared) {
              injectorState.sharedError = Error("sharedInjector() cannot be called inside a context that has already called sharedInjector()");
              throw injectorState.sharedError;
            }
            initialized = true;
            currentSpec = this;
            injectorState.shared = true;
          });
          module.$$afterAllHook(function() {
            if (initialized) {
              injectorState = new InjectorState();
              module.$$cleanup();
            } else {
              injectorState.sharedError = null;
            }
          });
        };
        module.$$beforeEach = function() {
          if (injectorState.shared && currentSpec && currentSpec != this) {
            var state = currentSpec;
            currentSpec = this;
            angular.forEach(["$injector", "$modules", "$providerInjector", "$injectorStrict"], function(k) {
              currentSpec[k] = state[k];
              state[k] = null;
            });
          } else {
            currentSpec = this;
            originalRootElement = null;
            annotatedFunctions = [];
          }
        };
        module.$$afterEach = function() {
          if (injectorState.cleanupAfterEach()) {
            module.$$cleanup();
          }
        };
        module.$$cleanup = function() {
          var injector = currentSpec.$injector;
          annotatedFunctions.forEach(function(fn) {
            delete fn.$inject;
          });
          angular.forEach(currentSpec.$modules, function(module) {
            if (module && module.$$hashKey) {
              module.$$hashKey = undefined;
            }
          });
          currentSpec.$injector = null;
          currentSpec.$modules = null;
          currentSpec.$providerInjector = null;
          currentSpec = null;
          if (injector) {
            var $rootElement = injector.get('$rootElement');
            var rootNode = $rootElement && $rootElement[0];
            var cleanUpNodes = !originalRootElement ? [] : [originalRootElement[0]];
            if (rootNode && (!originalRootElement || rootNode !== originalRootElement[0])) {
              cleanUpNodes.push(rootNode);
            }
            angular.element.cleanData(cleanUpNodes);
            var $rootScope = injector.get('$rootScope');
            if ($rootScope && $rootScope.$destroy)
              $rootScope.$destroy();
          }
          angular.forEach(angular.element.fragments, function(val, key) {
            delete angular.element.fragments[key];
          });
          MockXhr.$$lastInstance = null;
          angular.forEach(angular.callbacks, function(val, key) {
            delete angular.callbacks[key];
          });
          angular.callbacks.counter = 0;
        };
        (window.beforeEach || window.setup)(module.$$beforeEach);
        (window.afterEach || window.teardown)(module.$$afterEach);
        var ErrorAddingDeclarationLocationStack = function(e, errorForStack) {
          this.message = e.message;
          this.name = e.name;
          if (e.line)
            this.line = e.line;
          if (e.sourceId)
            this.sourceId = e.sourceId;
          if (e.stack && errorForStack)
            this.stack = e.stack + '\n' + errorForStack.stack;
          if (e.stackArray)
            this.stackArray = e.stackArray;
        };
        ErrorAddingDeclarationLocationStack.prototype.toString = Error.prototype.toString;
        window.inject = angular.mock.inject = function() {
          var blockFns = Array.prototype.slice.call(arguments, 0);
          var errorForStack = new Error('Declaration Location');
          if (!errorForStack.stack) {
            try {
              throw errorForStack;
            } catch (e) {}
          }
          return wasInjectorCreated() ? workFn.call(currentSpec) : workFn;
          function workFn() {
            var modules = currentSpec.$modules || [];
            var strictDi = !!currentSpec.$injectorStrict;
            modules.unshift(['$injector', function($injector) {
              currentSpec.$providerInjector = $injector;
            }]);
            modules.unshift('ngMock');
            modules.unshift('ng');
            var injector = currentSpec.$injector;
            if (!injector) {
              if (strictDi) {
                angular.forEach(modules, function(moduleFn) {
                  if (typeof moduleFn === "function") {
                    angular.injector.$$annotate(moduleFn);
                  }
                });
              }
              injector = currentSpec.$injector = angular.injector(modules, strictDi);
              currentSpec.$injectorStrict = strictDi;
            }
            for (var i = 0,
                ii = blockFns.length; i < ii; i++) {
              if (currentSpec.$injectorStrict) {
                injector.annotate(blockFns[i]);
              }
              try {
                injector.invoke(blockFns[i] || angular.noop, this);
              } catch (e) {
                if (e.stack && errorForStack) {
                  throw new ErrorAddingDeclarationLocationStack(e, errorForStack);
                }
                throw e;
              } finally {
                errorForStack = null;
              }
            }
          }
        };
        angular.mock.inject.strictDi = function(value) {
          value = arguments.length ? !!value : true;
          return wasInjectorCreated() ? workFn() : workFn;
          function workFn() {
            if (value !== currentSpec.$injectorStrict) {
              if (currentSpec.$injector) {
                throw new Error('Injector already created, can not modify strict annotations');
              } else {
                currentSpec.$injectorStrict = value;
              }
            }
          }
        };
        function InjectorState() {
          this.shared = false;
          this.sharedError = null;
          this.cleanupAfterEach = function() {
            return !this.shared || this.sharedError;
          };
        }
      })(window.jasmine || window.mocha);
    })(window, window.angular);
  })();
  return _retrieveGlobal();
});

System.registerDynamic("github:angular/bower-angular-mocks@1.5.7.js", ["github:angular/bower-angular-mocks@1.5.7/angular-mocks.js"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = $__require('github:angular/bower-angular-mocks@1.5.7/angular-mocks.js');
  global.define = __define;
  return module.exports;
});

System.registerDynamic("github:angular/bower-angular-sanitize@1.5.7/angular-sanitize.js", ["github:angular/bower-angular@1.5.7.js"], false, function(__require, __exports, __module) {
  var _retrieveGlobal = System.get("@@global-helpers").prepareGlobal(__module.id, null, null);
  (function() {
    "format global";
    "deps angular";
    (function(window, angular) {
      'use strict';
      var $sanitizeMinErr = angular.$$minErr('$sanitize');
      function $SanitizeProvider() {
        var svgEnabled = false;
        this.$get = ['$$sanitizeUri', function($$sanitizeUri) {
          if (svgEnabled) {
            angular.extend(validElements, svgElements);
          }
          return function(html) {
            var buf = [];
            htmlParser(html, htmlSanitizeWriter(buf, function(uri, isImage) {
              return !/^unsafe:/.test($$sanitizeUri(uri, isImage));
            }));
            return buf.join('');
          };
        }];
        this.enableSvg = function(enableSvg) {
          if (angular.isDefined(enableSvg)) {
            svgEnabled = enableSvg;
            return this;
          } else {
            return svgEnabled;
          }
        };
      }
      function sanitizeText(chars) {
        var buf = [];
        var writer = htmlSanitizeWriter(buf, angular.noop);
        writer.chars(chars);
        return buf.join('');
      }
      var SURROGATE_PAIR_REGEXP = /[\uD800-\uDBFF][\uDC00-\uDFFF]/g,
          NON_ALPHANUMERIC_REGEXP = /([^\#-~ |!])/g;
      var voidElements = toMap("area,br,col,hr,img,wbr");
      var optionalEndTagBlockElements = toMap("colgroup,dd,dt,li,p,tbody,td,tfoot,th,thead,tr"),
          optionalEndTagInlineElements = toMap("rp,rt"),
          optionalEndTagElements = angular.extend({}, optionalEndTagInlineElements, optionalEndTagBlockElements);
      var blockElements = angular.extend({}, optionalEndTagBlockElements, toMap("address,article," + "aside,blockquote,caption,center,del,dir,div,dl,figure,figcaption,footer,h1,h2,h3,h4,h5," + "h6,header,hgroup,hr,ins,map,menu,nav,ol,pre,section,table,ul"));
      var inlineElements = angular.extend({}, optionalEndTagInlineElements, toMap("a,abbr,acronym,b," + "bdi,bdo,big,br,cite,code,del,dfn,em,font,i,img,ins,kbd,label,map,mark,q,ruby,rp,rt,s," + "samp,small,span,strike,strong,sub,sup,time,tt,u,var"));
      var svgElements = toMap("circle,defs,desc,ellipse,font-face,font-face-name,font-face-src,g,glyph," + "hkern,image,linearGradient,line,marker,metadata,missing-glyph,mpath,path,polygon,polyline," + "radialGradient,rect,stop,svg,switch,text,title,tspan");
      var blockedElements = toMap("script,style");
      var validElements = angular.extend({}, voidElements, blockElements, inlineElements, optionalEndTagElements);
      var uriAttrs = toMap("background,cite,href,longdesc,src,xlink:href");
      var htmlAttrs = toMap('abbr,align,alt,axis,bgcolor,border,cellpadding,cellspacing,class,clear,' + 'color,cols,colspan,compact,coords,dir,face,headers,height,hreflang,hspace,' + 'ismap,lang,language,nohref,nowrap,rel,rev,rows,rowspan,rules,' + 'scope,scrolling,shape,size,span,start,summary,tabindex,target,title,type,' + 'valign,value,vspace,width');
      var svgAttrs = toMap('accent-height,accumulate,additive,alphabetic,arabic-form,ascent,' + 'baseProfile,bbox,begin,by,calcMode,cap-height,class,color,color-rendering,content,' + 'cx,cy,d,dx,dy,descent,display,dur,end,fill,fill-rule,font-family,font-size,font-stretch,' + 'font-style,font-variant,font-weight,from,fx,fy,g1,g2,glyph-name,gradientUnits,hanging,' + 'height,horiz-adv-x,horiz-origin-x,ideographic,k,keyPoints,keySplines,keyTimes,lang,' + 'marker-end,marker-mid,marker-start,markerHeight,markerUnits,markerWidth,mathematical,' + 'max,min,offset,opacity,orient,origin,overline-position,overline-thickness,panose-1,' + 'path,pathLength,points,preserveAspectRatio,r,refX,refY,repeatCount,repeatDur,' + 'requiredExtensions,requiredFeatures,restart,rotate,rx,ry,slope,stemh,stemv,stop-color,' + 'stop-opacity,strikethrough-position,strikethrough-thickness,stroke,stroke-dasharray,' + 'stroke-dashoffset,stroke-linecap,stroke-linejoin,stroke-miterlimit,stroke-opacity,' + 'stroke-width,systemLanguage,target,text-anchor,to,transform,type,u1,u2,underline-position,' + 'underline-thickness,unicode,unicode-range,units-per-em,values,version,viewBox,visibility,' + 'width,widths,x,x-height,x1,x2,xlink:actuate,xlink:arcrole,xlink:role,xlink:show,xlink:title,' + 'xlink:type,xml:base,xml:lang,xml:space,xmlns,xmlns:xlink,y,y1,y2,zoomAndPan', true);
      var validAttrs = angular.extend({}, uriAttrs, svgAttrs, htmlAttrs);
      function toMap(str, lowercaseKeys) {
        var obj = {},
            items = str.split(','),
            i;
        for (i = 0; i < items.length; i++) {
          obj[lowercaseKeys ? angular.lowercase(items[i]) : items[i]] = true;
        }
        return obj;
      }
      var inertBodyElement;
      (function(window) {
        var doc;
        if (window.document && window.document.implementation) {
          doc = window.document.implementation.createHTMLDocument("inert");
        } else {
          throw $sanitizeMinErr('noinert', "Can't create an inert html document");
        }
        var docElement = doc.documentElement || doc.getDocumentElement();
        var bodyElements = docElement.getElementsByTagName('body');
        if (bodyElements.length === 1) {
          inertBodyElement = bodyElements[0];
        } else {
          var html = doc.createElement('html');
          inertBodyElement = doc.createElement('body');
          html.appendChild(inertBodyElement);
          doc.appendChild(html);
        }
      })(window);
      function htmlParser(html, handler) {
        if (html === null || html === undefined) {
          html = '';
        } else if (typeof html !== 'string') {
          html = '' + html;
        }
        inertBodyElement.innerHTML = html;
        var mXSSAttempts = 5;
        do {
          if (mXSSAttempts === 0) {
            throw $sanitizeMinErr('uinput', "Failed to sanitize html because the input is unstable");
          }
          mXSSAttempts--;
          if (window.document.documentMode) {
            stripCustomNsAttrs(inertBodyElement);
          }
          html = inertBodyElement.innerHTML;
          inertBodyElement.innerHTML = html;
        } while (html !== inertBodyElement.innerHTML);
        var node = inertBodyElement.firstChild;
        while (node) {
          switch (node.nodeType) {
            case 1:
              handler.start(node.nodeName.toLowerCase(), attrToMap(node.attributes));
              break;
            case 3:
              handler.chars(node.textContent);
              break;
          }
          var nextNode;
          if (!(nextNode = node.firstChild)) {
            if (node.nodeType == 1) {
              handler.end(node.nodeName.toLowerCase());
            }
            nextNode = node.nextSibling;
            if (!nextNode) {
              while (nextNode == null) {
                node = node.parentNode;
                if (node === inertBodyElement)
                  break;
                nextNode = node.nextSibling;
                if (node.nodeType == 1) {
                  handler.end(node.nodeName.toLowerCase());
                }
              }
            }
          }
          node = nextNode;
        }
        while (node = inertBodyElement.firstChild) {
          inertBodyElement.removeChild(node);
        }
      }
      function attrToMap(attrs) {
        var map = {};
        for (var i = 0,
            ii = attrs.length; i < ii; i++) {
          var attr = attrs[i];
          map[attr.name] = attr.value;
        }
        return map;
      }
      function encodeEntities(value) {
        return value.replace(/&/g, '&amp;').replace(SURROGATE_PAIR_REGEXP, function(value) {
          var hi = value.charCodeAt(0);
          var low = value.charCodeAt(1);
          return '&#' + (((hi - 0xD800) * 0x400) + (low - 0xDC00) + 0x10000) + ';';
        }).replace(NON_ALPHANUMERIC_REGEXP, function(value) {
          return '&#' + value.charCodeAt(0) + ';';
        }).replace(/</g, '&lt;').replace(/>/g, '&gt;');
      }
      function htmlSanitizeWriter(buf, uriValidator) {
        var ignoreCurrentElement = false;
        var out = angular.bind(buf, buf.push);
        return {
          start: function(tag, attrs) {
            tag = angular.lowercase(tag);
            if (!ignoreCurrentElement && blockedElements[tag]) {
              ignoreCurrentElement = tag;
            }
            if (!ignoreCurrentElement && validElements[tag] === true) {
              out('<');
              out(tag);
              angular.forEach(attrs, function(value, key) {
                var lkey = angular.lowercase(key);
                var isImage = (tag === 'img' && lkey === 'src') || (lkey === 'background');
                if (validAttrs[lkey] === true && (uriAttrs[lkey] !== true || uriValidator(value, isImage))) {
                  out(' ');
                  out(key);
                  out('="');
                  out(encodeEntities(value));
                  out('"');
                }
              });
              out('>');
            }
          },
          end: function(tag) {
            tag = angular.lowercase(tag);
            if (!ignoreCurrentElement && validElements[tag] === true && voidElements[tag] !== true) {
              out('</');
              out(tag);
              out('>');
            }
            if (tag == ignoreCurrentElement) {
              ignoreCurrentElement = false;
            }
          },
          chars: function(chars) {
            if (!ignoreCurrentElement) {
              out(encodeEntities(chars));
            }
          }
        };
      }
      function stripCustomNsAttrs(node) {
        if (node.nodeType === window.Node.ELEMENT_NODE) {
          var attrs = node.attributes;
          for (var i = 0,
              l = attrs.length; i < l; i++) {
            var attrNode = attrs[i];
            var attrName = attrNode.name.toLowerCase();
            if (attrName === 'xmlns:ns1' || attrName.lastIndexOf('ns1:', 0) === 0) {
              node.removeAttributeNode(attrNode);
              i--;
              l--;
            }
          }
        }
        var nextNode = node.firstChild;
        if (nextNode) {
          stripCustomNsAttrs(nextNode);
        }
        nextNode = node.nextSibling;
        if (nextNode) {
          stripCustomNsAttrs(nextNode);
        }
      }
      angular.module('ngSanitize', []).provider('$sanitize', $SanitizeProvider);
      angular.module('ngSanitize').filter('linky', ['$sanitize', function($sanitize) {
        var LINKY_URL_REGEXP = /((ftp|https?):\/\/|(www\.)|(mailto:)?[A-Za-z0-9._%+-]+@)\S*[^\s.;,(){}<>"\u201d\u2019]/i,
            MAILTO_REGEXP = /^mailto:/i;
        var linkyMinErr = angular.$$minErr('linky');
        var isString = angular.isString;
        return function(text, target, attributes) {
          if (text == null || text === '')
            return text;
          if (!isString(text))
            throw linkyMinErr('notstring', 'Expected string but received: {0}', text);
          var attributesFn = angular.isFunction(attributes) ? attributes : angular.isObject(attributes) ? function getAttributesObject() {
            return attributes;
          } : function getEmptyAttributesObject() {
            return {};
          };
          var match;
          var raw = text;
          var html = [];
          var url;
          var i;
          while ((match = raw.match(LINKY_URL_REGEXP))) {
            url = match[0];
            if (!match[2] && !match[4]) {
              url = (match[3] ? 'http://' : 'mailto:') + url;
            }
            i = match.index;
            addText(raw.substr(0, i));
            addLink(url, match[0].replace(MAILTO_REGEXP, ''));
            raw = raw.substring(i + match[0].length);
          }
          addText(raw);
          return $sanitize(html.join(''));
          function addText(text) {
            if (!text) {
              return;
            }
            html.push(sanitizeText(text));
          }
          function addLink(url, text) {
            var key,
                linkAttributes = attributesFn(url);
            html.push('<a ');
            for (key in linkAttributes) {
              html.push(key + '="' + linkAttributes[key] + '" ');
            }
            if (angular.isDefined(target) && !('target' in linkAttributes)) {
              html.push('target="', target, '" ');
            }
            html.push('href="', url.replace(/"/g, '&quot;'), '">');
            addText(text);
            html.push('</a>');
          }
        };
      }]);
    })(window, window.angular);
  })();
  return _retrieveGlobal();
});

System.registerDynamic("github:angular/bower-angular-sanitize@1.5.7.js", ["github:angular/bower-angular-sanitize@1.5.7/angular-sanitize.js"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = $__require('github:angular/bower-angular-sanitize@1.5.7/angular-sanitize.js');
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:angular-local-storage@0.2.2/dist/angular-local-storage.js", [], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  "format cjs";
  (function(window, angular, undefined) {
    'use strict';
    var isDefined = angular.isDefined,
        isUndefined = angular.isUndefined,
        isNumber = angular.isNumber,
        isObject = angular.isObject,
        isArray = angular.isArray,
        extend = angular.extend,
        toJson = angular.toJson;
    var angularLocalStorage = angular.module('LocalStorageModule', []);
    angularLocalStorage.provider('localStorageService', function() {
      this.prefix = 'ls';
      this.storageType = 'localStorage';
      this.cookie = {
        expiry: 30,
        path: '/'
      };
      this.notify = {
        setItem: true,
        removeItem: false
      };
      this.setPrefix = function(prefix) {
        this.prefix = prefix;
        return this;
      };
      this.setStorageType = function(storageType) {
        this.storageType = storageType;
        return this;
      };
      this.setStorageCookie = function(exp, path) {
        this.cookie.expiry = exp;
        this.cookie.path = path;
        return this;
      };
      this.setStorageCookieDomain = function(domain) {
        this.cookie.domain = domain;
        return this;
      };
      this.setNotify = function(itemSet, itemRemove) {
        this.notify = {
          setItem: itemSet,
          removeItem: itemRemove
        };
        return this;
      };
      this.$get = ['$rootScope', '$window', '$document', '$parse', function($rootScope, $window, $document, $parse) {
        var self = this;
        var prefix = self.prefix;
        var cookie = self.cookie;
        var notify = self.notify;
        var storageType = self.storageType;
        var webStorage;
        if (!$document) {
          $document = document;
        } else if ($document[0]) {
          $document = $document[0];
        }
        if (prefix.substr(-1) !== '.') {
          prefix = !!prefix ? prefix + '.' : '';
        }
        var deriveQualifiedKey = function(key) {
          return prefix + key;
        };
        var browserSupportsLocalStorage = (function() {
          try {
            var supported = (storageType in $window && $window[storageType] !== null);
            var key = deriveQualifiedKey('__' + Math.round(Math.random() * 1e7));
            if (supported) {
              webStorage = $window[storageType];
              webStorage.setItem(key, '');
              webStorage.removeItem(key);
            }
            return supported;
          } catch (e) {
            storageType = 'cookie';
            $rootScope.$broadcast('LocalStorageModule.notification.error', e.message);
            return false;
          }
        }());
        var addToLocalStorage = function(key, value) {
          if (isUndefined(value)) {
            value = null;
          } else {
            value = toJson(value);
          }
          if (!browserSupportsLocalStorage || self.storageType === 'cookie') {
            if (!browserSupportsLocalStorage) {
              $rootScope.$broadcast('LocalStorageModule.notification.warning', 'LOCAL_STORAGE_NOT_SUPPORTED');
            }
            if (notify.setItem) {
              $rootScope.$broadcast('LocalStorageModule.notification.setitem', {
                key: key,
                newvalue: value,
                storageType: 'cookie'
              });
            }
            return addToCookies(key, value);
          }
          try {
            if (webStorage) {
              webStorage.setItem(deriveQualifiedKey(key), value);
            }
            ;
            if (notify.setItem) {
              $rootScope.$broadcast('LocalStorageModule.notification.setitem', {
                key: key,
                newvalue: value,
                storageType: self.storageType
              });
            }
          } catch (e) {
            $rootScope.$broadcast('LocalStorageModule.notification.error', e.message);
            return addToCookies(key, value);
          }
          return true;
        };
        var getFromLocalStorage = function(key) {
          if (!browserSupportsLocalStorage || self.storageType === 'cookie') {
            if (!browserSupportsLocalStorage) {
              $rootScope.$broadcast('LocalStorageModule.notification.warning', 'LOCAL_STORAGE_NOT_SUPPORTED');
            }
            return getFromCookies(key);
          }
          var item = webStorage ? webStorage.getItem(deriveQualifiedKey(key)) : null;
          if (!item || item === 'null') {
            return null;
          }
          try {
            return JSON.parse(item);
          } catch (e) {
            return item;
          }
        };
        var removeFromLocalStorage = function() {
          var i,
              key;
          for (i = 0; i < arguments.length; i++) {
            key = arguments[i];
            if (!browserSupportsLocalStorage || self.storageType === 'cookie') {
              if (!browserSupportsLocalStorage) {
                $rootScope.$broadcast('LocalStorageModule.notification.warning', 'LOCAL_STORAGE_NOT_SUPPORTED');
              }
              if (notify.removeItem) {
                $rootScope.$broadcast('LocalStorageModule.notification.removeitem', {
                  key: key,
                  storageType: 'cookie'
                });
              }
              removeFromCookies(key);
            } else {
              try {
                webStorage.removeItem(deriveQualifiedKey(key));
                if (notify.removeItem) {
                  $rootScope.$broadcast('LocalStorageModule.notification.removeitem', {
                    key: key,
                    storageType: self.storageType
                  });
                }
              } catch (e) {
                $rootScope.$broadcast('LocalStorageModule.notification.error', e.message);
                removeFromCookies(key);
              }
            }
          }
        };
        var getKeysForLocalStorage = function() {
          if (!browserSupportsLocalStorage) {
            $rootScope.$broadcast('LocalStorageModule.notification.warning', 'LOCAL_STORAGE_NOT_SUPPORTED');
            return false;
          }
          var prefixLength = prefix.length;
          var keys = [];
          for (var key in webStorage) {
            if (key.substr(0, prefixLength) === prefix) {
              try {
                keys.push(key.substr(prefixLength));
              } catch (e) {
                $rootScope.$broadcast('LocalStorageModule.notification.error', e.Description);
                return [];
              }
            }
          }
          return keys;
        };
        var clearAllFromLocalStorage = function(regularExpression) {
          var prefixRegex = !!prefix ? new RegExp('^' + prefix) : new RegExp();
          var testRegex = !!regularExpression ? new RegExp(regularExpression) : new RegExp();
          if (!browserSupportsLocalStorage || self.storageType === 'cookie') {
            if (!browserSupportsLocalStorage) {
              $rootScope.$broadcast('LocalStorageModule.notification.warning', 'LOCAL_STORAGE_NOT_SUPPORTED');
            }
            return clearAllFromCookies();
          }
          var prefixLength = prefix.length;
          for (var key in webStorage) {
            if (prefixRegex.test(key) && testRegex.test(key.substr(prefixLength))) {
              try {
                removeFromLocalStorage(key.substr(prefixLength));
              } catch (e) {
                $rootScope.$broadcast('LocalStorageModule.notification.error', e.message);
                return clearAllFromCookies();
              }
            }
          }
          return true;
        };
        var browserSupportsCookies = (function() {
          try {
            return $window.navigator.cookieEnabled || ("cookie" in $document && ($document.cookie.length > 0 || ($document.cookie = "test").indexOf.call($document.cookie, "test") > -1));
          } catch (e) {
            $rootScope.$broadcast('LocalStorageModule.notification.error', e.message);
            return false;
          }
        }());
        var addToCookies = function(key, value, daysToExpiry) {
          if (isUndefined(value)) {
            return false;
          } else if (isArray(value) || isObject(value)) {
            value = toJson(value);
          }
          if (!browserSupportsCookies) {
            $rootScope.$broadcast('LocalStorageModule.notification.error', 'COOKIES_NOT_SUPPORTED');
            return false;
          }
          try {
            var expiry = '',
                expiryDate = new Date(),
                cookieDomain = '';
            if (value === null) {
              expiryDate.setTime(expiryDate.getTime() + (-1 * 24 * 60 * 60 * 1000));
              expiry = "; expires=" + expiryDate.toGMTString();
              value = '';
            } else if (isNumber(daysToExpiry) && daysToExpiry !== 0) {
              expiryDate.setTime(expiryDate.getTime() + (daysToExpiry * 24 * 60 * 60 * 1000));
              expiry = "; expires=" + expiryDate.toGMTString();
            } else if (cookie.expiry !== 0) {
              expiryDate.setTime(expiryDate.getTime() + (cookie.expiry * 24 * 60 * 60 * 1000));
              expiry = "; expires=" + expiryDate.toGMTString();
            }
            if (!!key) {
              var cookiePath = "; path=" + cookie.path;
              if (cookie.domain) {
                cookieDomain = "; domain=" + cookie.domain;
              }
              $document.cookie = deriveQualifiedKey(key) + "=" + encodeURIComponent(value) + expiry + cookiePath + cookieDomain;
            }
          } catch (e) {
            $rootScope.$broadcast('LocalStorageModule.notification.error', e.message);
            return false;
          }
          return true;
        };
        var getFromCookies = function(key) {
          if (!browserSupportsCookies) {
            $rootScope.$broadcast('LocalStorageModule.notification.error', 'COOKIES_NOT_SUPPORTED');
            return false;
          }
          var cookies = $document.cookie && $document.cookie.split(';') || [];
          for (var i = 0; i < cookies.length; i++) {
            var thisCookie = cookies[i];
            while (thisCookie.charAt(0) === ' ') {
              thisCookie = thisCookie.substring(1, thisCookie.length);
            }
            if (thisCookie.indexOf(deriveQualifiedKey(key) + '=') === 0) {
              var storedValues = decodeURIComponent(thisCookie.substring(prefix.length + key.length + 1, thisCookie.length));
              try {
                return JSON.parse(storedValues);
              } catch (e) {
                return storedValues;
              }
            }
          }
          return null;
        };
        var removeFromCookies = function(key) {
          addToCookies(key, null);
        };
        var clearAllFromCookies = function() {
          var thisCookie = null,
              thisKey = null;
          var prefixLength = prefix.length;
          var cookies = $document.cookie.split(';');
          for (var i = 0; i < cookies.length; i++) {
            thisCookie = cookies[i];
            while (thisCookie.charAt(0) === ' ') {
              thisCookie = thisCookie.substring(1, thisCookie.length);
            }
            var key = thisCookie.substring(prefixLength, thisCookie.indexOf('='));
            removeFromCookies(key);
          }
        };
        var getStorageType = function() {
          return storageType;
        };
        var bindToScope = function(scope, key, def, lsKey) {
          lsKey = lsKey || key;
          var value = getFromLocalStorage(lsKey);
          if (value === null && isDefined(def)) {
            value = def;
          } else if (isObject(value) && isObject(def)) {
            value = extend(def, value);
          }
          $parse(key).assign(scope, value);
          return scope.$watch(key, function(newVal) {
            addToLocalStorage(lsKey, newVal);
          }, isObject(scope[key]));
        };
        var lengthOfLocalStorage = function() {
          var count = 0;
          var storage = $window[storageType];
          for (var i = 0; i < storage.length; i++) {
            if (storage.key(i).indexOf(prefix) === 0) {
              count++;
            }
          }
          return count;
        };
        return {
          isSupported: browserSupportsLocalStorage,
          getStorageType: getStorageType,
          set: addToLocalStorage,
          add: addToLocalStorage,
          get: getFromLocalStorage,
          keys: getKeysForLocalStorage,
          remove: removeFromLocalStorage,
          clearAll: clearAllFromLocalStorage,
          bind: bindToScope,
          deriveKey: deriveQualifiedKey,
          length: lengthOfLocalStorage,
          cookie: {
            isSupported: browserSupportsCookies,
            set: addToCookies,
            add: addToCookies,
            get: getFromCookies,
            remove: removeFromCookies,
            clearAll: clearAllFromCookies
          }
        };
      }];
    });
  })(window, window.angular);
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:angular-local-storage@0.2.2.js", ["npm:angular-local-storage@0.2.2/dist/angular-local-storage.js"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = $__require('npm:angular-local-storage@0.2.2/dist/angular-local-storage.js');
  global.define = __define;
  return module.exports;
});

System.registerDynamic("github:angular/bower-angular@1.5.7/angular.js", [], false, function(__require, __exports, __module) {
  var _retrieveGlobal = System.get("@@global-helpers").prepareGlobal(__module.id, "angular", null);
  (function() {
    "format global";
    "exports angular";
    (function(window) {
      'use strict';
      function minErr(module, ErrorConstructor) {
        ErrorConstructor = ErrorConstructor || Error;
        return function() {
          var SKIP_INDEXES = 2;
          var templateArgs = arguments,
              code = templateArgs[0],
              message = '[' + (module ? module + ':' : '') + code + '] ',
              template = templateArgs[1],
              paramPrefix,
              i;
          message += template.replace(/\{\d+\}/g, function(match) {
            var index = +match.slice(1, -1),
                shiftedIndex = index + SKIP_INDEXES;
            if (shiftedIndex < templateArgs.length) {
              return toDebugString(templateArgs[shiftedIndex]);
            }
            return match;
          });
          message += '\nhttp://errors.angularjs.org/1.5.7/' + (module ? module + '/' : '') + code;
          for (i = SKIP_INDEXES, paramPrefix = '?'; i < templateArgs.length; i++, paramPrefix = '&') {
            message += paramPrefix + 'p' + (i - SKIP_INDEXES) + '=' + encodeURIComponent(toDebugString(templateArgs[i]));
          }
          return new ErrorConstructor(message);
        };
      }
      var REGEX_STRING_REGEXP = /^\/(.+)\/([a-z]*)$/;
      var VALIDITY_STATE_PROPERTY = 'validity';
      var hasOwnProperty = Object.prototype.hasOwnProperty;
      var lowercase = function(string) {
        return isString(string) ? string.toLowerCase() : string;
      };
      var uppercase = function(string) {
        return isString(string) ? string.toUpperCase() : string;
      };
      var manualLowercase = function(s) {
        return isString(s) ? s.replace(/[A-Z]/g, function(ch) {
          return String.fromCharCode(ch.charCodeAt(0) | 32);
        }) : s;
      };
      var manualUppercase = function(s) {
        return isString(s) ? s.replace(/[a-z]/g, function(ch) {
          return String.fromCharCode(ch.charCodeAt(0) & ~32);
        }) : s;
      };
      if ('i' !== 'I'.toLowerCase()) {
        lowercase = manualLowercase;
        uppercase = manualUppercase;
      }
      var msie,
          jqLite,
          jQuery,
          slice = [].slice,
          splice = [].splice,
          push = [].push,
          toString = Object.prototype.toString,
          getPrototypeOf = Object.getPrototypeOf,
          ngMinErr = minErr('ng'),
          angular = window.angular || (window.angular = {}),
          angularModule,
          uid = 0;
      msie = window.document.documentMode;
      function isArrayLike(obj) {
        if (obj == null || isWindow(obj))
          return false;
        if (isArray(obj) || isString(obj) || (jqLite && obj instanceof jqLite))
          return true;
        var length = "length" in Object(obj) && obj.length;
        return isNumber(length) && (length >= 0 && ((length - 1) in obj || obj instanceof Array) || typeof obj.item == 'function');
      }
      function forEach(obj, iterator, context) {
        var key,
            length;
        if (obj) {
          if (isFunction(obj)) {
            for (key in obj) {
              if (key != 'prototype' && key != 'length' && key != 'name' && (!obj.hasOwnProperty || obj.hasOwnProperty(key))) {
                iterator.call(context, obj[key], key, obj);
              }
            }
          } else if (isArray(obj) || isArrayLike(obj)) {
            var isPrimitive = typeof obj !== 'object';
            for (key = 0, length = obj.length; key < length; key++) {
              if (isPrimitive || key in obj) {
                iterator.call(context, obj[key], key, obj);
              }
            }
          } else if (obj.forEach && obj.forEach !== forEach) {
            obj.forEach(iterator, context, obj);
          } else if (isBlankObject(obj)) {
            for (key in obj) {
              iterator.call(context, obj[key], key, obj);
            }
          } else if (typeof obj.hasOwnProperty === 'function') {
            for (key in obj) {
              if (obj.hasOwnProperty(key)) {
                iterator.call(context, obj[key], key, obj);
              }
            }
          } else {
            for (key in obj) {
              if (hasOwnProperty.call(obj, key)) {
                iterator.call(context, obj[key], key, obj);
              }
            }
          }
        }
        return obj;
      }
      function forEachSorted(obj, iterator, context) {
        var keys = Object.keys(obj).sort();
        for (var i = 0; i < keys.length; i++) {
          iterator.call(context, obj[keys[i]], keys[i]);
        }
        return keys;
      }
      function reverseParams(iteratorFn) {
        return function(value, key) {
          iteratorFn(key, value);
        };
      }
      function nextUid() {
        return ++uid;
      }
      function setHashKey(obj, h) {
        if (h) {
          obj.$$hashKey = h;
        } else {
          delete obj.$$hashKey;
        }
      }
      function baseExtend(dst, objs, deep) {
        var h = dst.$$hashKey;
        for (var i = 0,
            ii = objs.length; i < ii; ++i) {
          var obj = objs[i];
          if (!isObject(obj) && !isFunction(obj))
            continue;
          var keys = Object.keys(obj);
          for (var j = 0,
              jj = keys.length; j < jj; j++) {
            var key = keys[j];
            var src = obj[key];
            if (deep && isObject(src)) {
              if (isDate(src)) {
                dst[key] = new Date(src.valueOf());
              } else if (isRegExp(src)) {
                dst[key] = new RegExp(src);
              } else if (src.nodeName) {
                dst[key] = src.cloneNode(true);
              } else if (isElement(src)) {
                dst[key] = src.clone();
              } else {
                if (!isObject(dst[key]))
                  dst[key] = isArray(src) ? [] : {};
                baseExtend(dst[key], [src], true);
              }
            } else {
              dst[key] = src;
            }
          }
        }
        setHashKey(dst, h);
        return dst;
      }
      function extend(dst) {
        return baseExtend(dst, slice.call(arguments, 1), false);
      }
      function merge(dst) {
        return baseExtend(dst, slice.call(arguments, 1), true);
      }
      function toInt(str) {
        return parseInt(str, 10);
      }
      function inherit(parent, extra) {
        return extend(Object.create(parent), extra);
      }
      function noop() {}
      noop.$inject = [];
      function identity($) {
        return $;
      }
      identity.$inject = [];
      function valueFn(value) {
        return function valueRef() {
          return value;
        };
      }
      function hasCustomToString(obj) {
        return isFunction(obj.toString) && obj.toString !== toString;
      }
      function isUndefined(value) {
        return typeof value === 'undefined';
      }
      function isDefined(value) {
        return typeof value !== 'undefined';
      }
      function isObject(value) {
        return value !== null && typeof value === 'object';
      }
      function isBlankObject(value) {
        return value !== null && typeof value === 'object' && !getPrototypeOf(value);
      }
      function isString(value) {
        return typeof value === 'string';
      }
      function isNumber(value) {
        return typeof value === 'number';
      }
      function isDate(value) {
        return toString.call(value) === '[object Date]';
      }
      var isArray = Array.isArray;
      function isFunction(value) {
        return typeof value === 'function';
      }
      function isRegExp(value) {
        return toString.call(value) === '[object RegExp]';
      }
      function isWindow(obj) {
        return obj && obj.window === obj;
      }
      function isScope(obj) {
        return obj && obj.$evalAsync && obj.$watch;
      }
      function isFile(obj) {
        return toString.call(obj) === '[object File]';
      }
      function isFormData(obj) {
        return toString.call(obj) === '[object FormData]';
      }
      function isBlob(obj) {
        return toString.call(obj) === '[object Blob]';
      }
      function isBoolean(value) {
        return typeof value === 'boolean';
      }
      function isPromiseLike(obj) {
        return obj && isFunction(obj.then);
      }
      var TYPED_ARRAY_REGEXP = /^\[object (?:Uint8|Uint8Clamped|Uint16|Uint32|Int8|Int16|Int32|Float32|Float64)Array\]$/;
      function isTypedArray(value) {
        return value && isNumber(value.length) && TYPED_ARRAY_REGEXP.test(toString.call(value));
      }
      function isArrayBuffer(obj) {
        return toString.call(obj) === '[object ArrayBuffer]';
      }
      var trim = function(value) {
        return isString(value) ? value.trim() : value;
      };
      var escapeForRegexp = function(s) {
        return s.replace(/([-()\[\]{}+?*.$\^|,:#<!\\])/g, '\\$1').replace(/\x08/g, '\\x08');
      };
      function isElement(node) {
        return !!(node && (node.nodeName || (node.prop && node.attr && node.find)));
      }
      function makeMap(str) {
        var obj = {},
            items = str.split(','),
            i;
        for (i = 0; i < items.length; i++) {
          obj[items[i]] = true;
        }
        return obj;
      }
      function nodeName_(element) {
        return lowercase(element.nodeName || (element[0] && element[0].nodeName));
      }
      function includes(array, obj) {
        return Array.prototype.indexOf.call(array, obj) != -1;
      }
      function arrayRemove(array, value) {
        var index = array.indexOf(value);
        if (index >= 0) {
          array.splice(index, 1);
        }
        return index;
      }
      function copy(source, destination) {
        var stackSource = [];
        var stackDest = [];
        if (destination) {
          if (isTypedArray(destination) || isArrayBuffer(destination)) {
            throw ngMinErr('cpta', "Can't copy! TypedArray destination cannot be mutated.");
          }
          if (source === destination) {
            throw ngMinErr('cpi', "Can't copy! Source and destination are identical.");
          }
          if (isArray(destination)) {
            destination.length = 0;
          } else {
            forEach(destination, function(value, key) {
              if (key !== '$$hashKey') {
                delete destination[key];
              }
            });
          }
          stackSource.push(source);
          stackDest.push(destination);
          return copyRecurse(source, destination);
        }
        return copyElement(source);
        function copyRecurse(source, destination) {
          var h = destination.$$hashKey;
          var key;
          if (isArray(source)) {
            for (var i = 0,
                ii = source.length; i < ii; i++) {
              destination.push(copyElement(source[i]));
            }
          } else if (isBlankObject(source)) {
            for (key in source) {
              destination[key] = copyElement(source[key]);
            }
          } else if (source && typeof source.hasOwnProperty === 'function') {
            for (key in source) {
              if (source.hasOwnProperty(key)) {
                destination[key] = copyElement(source[key]);
              }
            }
          } else {
            for (key in source) {
              if (hasOwnProperty.call(source, key)) {
                destination[key] = copyElement(source[key]);
              }
            }
          }
          setHashKey(destination, h);
          return destination;
        }
        function copyElement(source) {
          if (!isObject(source)) {
            return source;
          }
          var index = stackSource.indexOf(source);
          if (index !== -1) {
            return stackDest[index];
          }
          if (isWindow(source) || isScope(source)) {
            throw ngMinErr('cpws', "Can't copy! Making copies of Window or Scope instances is not supported.");
          }
          var needsRecurse = false;
          var destination = copyType(source);
          if (destination === undefined) {
            destination = isArray(source) ? [] : Object.create(getPrototypeOf(source));
            needsRecurse = true;
          }
          stackSource.push(source);
          stackDest.push(destination);
          return needsRecurse ? copyRecurse(source, destination) : destination;
        }
        function copyType(source) {
          switch (toString.call(source)) {
            case '[object Int8Array]':
            case '[object Int16Array]':
            case '[object Int32Array]':
            case '[object Float32Array]':
            case '[object Float64Array]':
            case '[object Uint8Array]':
            case '[object Uint8ClampedArray]':
            case '[object Uint16Array]':
            case '[object Uint32Array]':
              return new source.constructor(copyElement(source.buffer));
            case '[object ArrayBuffer]':
              if (!source.slice) {
                var copied = new ArrayBuffer(source.byteLength);
                new Uint8Array(copied).set(new Uint8Array(source));
                return copied;
              }
              return source.slice(0);
            case '[object Boolean]':
            case '[object Number]':
            case '[object String]':
            case '[object Date]':
              return new source.constructor(source.valueOf());
            case '[object RegExp]':
              var re = new RegExp(source.source, source.toString().match(/[^\/]*$/)[0]);
              re.lastIndex = source.lastIndex;
              return re;
            case '[object Blob]':
              return new source.constructor([source], {type: source.type});
          }
          if (isFunction(source.cloneNode)) {
            return source.cloneNode(true);
          }
        }
      }
      function equals(o1, o2) {
        if (o1 === o2)
          return true;
        if (o1 === null || o2 === null)
          return false;
        if (o1 !== o1 && o2 !== o2)
          return true;
        var t1 = typeof o1,
            t2 = typeof o2,
            length,
            key,
            keySet;
        if (t1 == t2 && t1 == 'object') {
          if (isArray(o1)) {
            if (!isArray(o2))
              return false;
            if ((length = o1.length) == o2.length) {
              for (key = 0; key < length; key++) {
                if (!equals(o1[key], o2[key]))
                  return false;
              }
              return true;
            }
          } else if (isDate(o1)) {
            if (!isDate(o2))
              return false;
            return equals(o1.getTime(), o2.getTime());
          } else if (isRegExp(o1)) {
            if (!isRegExp(o2))
              return false;
            return o1.toString() == o2.toString();
          } else {
            if (isScope(o1) || isScope(o2) || isWindow(o1) || isWindow(o2) || isArray(o2) || isDate(o2) || isRegExp(o2))
              return false;
            keySet = createMap();
            for (key in o1) {
              if (key.charAt(0) === '$' || isFunction(o1[key]))
                continue;
              if (!equals(o1[key], o2[key]))
                return false;
              keySet[key] = true;
            }
            for (key in o2) {
              if (!(key in keySet) && key.charAt(0) !== '$' && isDefined(o2[key]) && !isFunction(o2[key]))
                return false;
            }
            return true;
          }
        }
        return false;
      }
      var csp = function() {
        if (!isDefined(csp.rules)) {
          var ngCspElement = (window.document.querySelector('[ng-csp]') || window.document.querySelector('[data-ng-csp]'));
          if (ngCspElement) {
            var ngCspAttribute = ngCspElement.getAttribute('ng-csp') || ngCspElement.getAttribute('data-ng-csp');
            csp.rules = {
              noUnsafeEval: !ngCspAttribute || (ngCspAttribute.indexOf('no-unsafe-eval') !== -1),
              noInlineStyle: !ngCspAttribute || (ngCspAttribute.indexOf('no-inline-style') !== -1)
            };
          } else {
            csp.rules = {
              noUnsafeEval: noUnsafeEval(),
              noInlineStyle: false
            };
          }
        }
        return csp.rules;
        function noUnsafeEval() {
          try {
            new Function('');
            return false;
          } catch (e) {
            return true;
          }
        }
      };
      var jq = function() {
        if (isDefined(jq.name_))
          return jq.name_;
        var el;
        var i,
            ii = ngAttrPrefixes.length,
            prefix,
            name;
        for (i = 0; i < ii; ++i) {
          prefix = ngAttrPrefixes[i];
          if (el = window.document.querySelector('[' + prefix.replace(':', '\\:') + 'jq]')) {
            name = el.getAttribute(prefix + 'jq');
            break;
          }
        }
        return (jq.name_ = name);
      };
      function concat(array1, array2, index) {
        return array1.concat(slice.call(array2, index));
      }
      function sliceArgs(args, startIndex) {
        return slice.call(args, startIndex || 0);
      }
      function bind(self, fn) {
        var curryArgs = arguments.length > 2 ? sliceArgs(arguments, 2) : [];
        if (isFunction(fn) && !(fn instanceof RegExp)) {
          return curryArgs.length ? function() {
            return arguments.length ? fn.apply(self, concat(curryArgs, arguments, 0)) : fn.apply(self, curryArgs);
          } : function() {
            return arguments.length ? fn.apply(self, arguments) : fn.call(self);
          };
        } else {
          return fn;
        }
      }
      function toJsonReplacer(key, value) {
        var val = value;
        if (typeof key === 'string' && key.charAt(0) === '$' && key.charAt(1) === '$') {
          val = undefined;
        } else if (isWindow(value)) {
          val = '$WINDOW';
        } else if (value && window.document === value) {
          val = '$DOCUMENT';
        } else if (isScope(value)) {
          val = '$SCOPE';
        }
        return val;
      }
      function toJson(obj, pretty) {
        if (isUndefined(obj))
          return undefined;
        if (!isNumber(pretty)) {
          pretty = pretty ? 2 : null;
        }
        return JSON.stringify(obj, toJsonReplacer, pretty);
      }
      function fromJson(json) {
        return isString(json) ? JSON.parse(json) : json;
      }
      var ALL_COLONS = /:/g;
      function timezoneToOffset(timezone, fallback) {
        timezone = timezone.replace(ALL_COLONS, '');
        var requestedTimezoneOffset = Date.parse('Jan 01, 1970 00:00:00 ' + timezone) / 60000;
        return isNaN(requestedTimezoneOffset) ? fallback : requestedTimezoneOffset;
      }
      function addDateMinutes(date, minutes) {
        date = new Date(date.getTime());
        date.setMinutes(date.getMinutes() + minutes);
        return date;
      }
      function convertTimezoneToLocal(date, timezone, reverse) {
        reverse = reverse ? -1 : 1;
        var dateTimezoneOffset = date.getTimezoneOffset();
        var timezoneOffset = timezoneToOffset(timezone, dateTimezoneOffset);
        return addDateMinutes(date, reverse * (timezoneOffset - dateTimezoneOffset));
      }
      function startingTag(element) {
        element = jqLite(element).clone();
        try {
          element.empty();
        } catch (e) {}
        var elemHtml = jqLite('<div>').append(element).html();
        try {
          return element[0].nodeType === NODE_TYPE_TEXT ? lowercase(elemHtml) : elemHtml.match(/^(<[^>]+>)/)[1].replace(/^<([\w\-]+)/, function(match, nodeName) {
            return '<' + lowercase(nodeName);
          });
        } catch (e) {
          return lowercase(elemHtml);
        }
      }
      function tryDecodeURIComponent(value) {
        try {
          return decodeURIComponent(value);
        } catch (e) {}
      }
      function parseKeyValue(keyValue) {
        var obj = {};
        forEach((keyValue || "").split('&'), function(keyValue) {
          var splitPoint,
              key,
              val;
          if (keyValue) {
            key = keyValue = keyValue.replace(/\+/g, '%20');
            splitPoint = keyValue.indexOf('=');
            if (splitPoint !== -1) {
              key = keyValue.substring(0, splitPoint);
              val = keyValue.substring(splitPoint + 1);
            }
            key = tryDecodeURIComponent(key);
            if (isDefined(key)) {
              val = isDefined(val) ? tryDecodeURIComponent(val) : true;
              if (!hasOwnProperty.call(obj, key)) {
                obj[key] = val;
              } else if (isArray(obj[key])) {
                obj[key].push(val);
              } else {
                obj[key] = [obj[key], val];
              }
            }
          }
        });
        return obj;
      }
      function toKeyValue(obj) {
        var parts = [];
        forEach(obj, function(value, key) {
          if (isArray(value)) {
            forEach(value, function(arrayValue) {
              parts.push(encodeUriQuery(key, true) + (arrayValue === true ? '' : '=' + encodeUriQuery(arrayValue, true)));
            });
          } else {
            parts.push(encodeUriQuery(key, true) + (value === true ? '' : '=' + encodeUriQuery(value, true)));
          }
        });
        return parts.length ? parts.join('&') : '';
      }
      function encodeUriSegment(val) {
        return encodeUriQuery(val, true).replace(/%26/gi, '&').replace(/%3D/gi, '=').replace(/%2B/gi, '+');
      }
      function encodeUriQuery(val, pctEncodeSpaces) {
        return encodeURIComponent(val).replace(/%40/gi, '@').replace(/%3A/gi, ':').replace(/%24/g, '$').replace(/%2C/gi, ',').replace(/%3B/gi, ';').replace(/%20/g, (pctEncodeSpaces ? '%20' : '+'));
      }
      var ngAttrPrefixes = ['ng-', 'data-ng-', 'ng:', 'x-ng-'];
      function getNgAttribute(element, ngAttr) {
        var attr,
            i,
            ii = ngAttrPrefixes.length;
        for (i = 0; i < ii; ++i) {
          attr = ngAttrPrefixes[i] + ngAttr;
          if (isString(attr = element.getAttribute(attr))) {
            return attr;
          }
        }
        return null;
      }
      function angularInit(element, bootstrap) {
        var appElement,
            module,
            config = {};
        forEach(ngAttrPrefixes, function(prefix) {
          var name = prefix + 'app';
          if (!appElement && element.hasAttribute && element.hasAttribute(name)) {
            appElement = element;
            module = element.getAttribute(name);
          }
        });
        forEach(ngAttrPrefixes, function(prefix) {
          var name = prefix + 'app';
          var candidate;
          if (!appElement && (candidate = element.querySelector('[' + name.replace(':', '\\:') + ']'))) {
            appElement = candidate;
            module = candidate.getAttribute(name);
          }
        });
        if (appElement) {
          config.strictDi = getNgAttribute(appElement, "strict-di") !== null;
          bootstrap(appElement, module ? [module] : [], config);
        }
      }
      function bootstrap(element, modules, config) {
        if (!isObject(config))
          config = {};
        var defaultConfig = {strictDi: false};
        config = extend(defaultConfig, config);
        var doBootstrap = function() {
          element = jqLite(element);
          if (element.injector()) {
            var tag = (element[0] === window.document) ? 'document' : startingTag(element);
            throw ngMinErr('btstrpd', "App already bootstrapped with this element '{0}'", tag.replace(/</, '&lt;').replace(/>/, '&gt;'));
          }
          modules = modules || [];
          modules.unshift(['$provide', function($provide) {
            $provide.value('$rootElement', element);
          }]);
          if (config.debugInfoEnabled) {
            modules.push(['$compileProvider', function($compileProvider) {
              $compileProvider.debugInfoEnabled(true);
            }]);
          }
          modules.unshift('ng');
          var injector = createInjector(modules, config.strictDi);
          injector.invoke(['$rootScope', '$rootElement', '$compile', '$injector', function bootstrapApply(scope, element, compile, injector) {
            scope.$apply(function() {
              element.data('$injector', injector);
              compile(element)(scope);
            });
          }]);
          return injector;
        };
        var NG_ENABLE_DEBUG_INFO = /^NG_ENABLE_DEBUG_INFO!/;
        var NG_DEFER_BOOTSTRAP = /^NG_DEFER_BOOTSTRAP!/;
        if (window && NG_ENABLE_DEBUG_INFO.test(window.name)) {
          config.debugInfoEnabled = true;
          window.name = window.name.replace(NG_ENABLE_DEBUG_INFO, '');
        }
        if (window && !NG_DEFER_BOOTSTRAP.test(window.name)) {
          return doBootstrap();
        }
        window.name = window.name.replace(NG_DEFER_BOOTSTRAP, '');
        angular.resumeBootstrap = function(extraModules) {
          forEach(extraModules, function(module) {
            modules.push(module);
          });
          return doBootstrap();
        };
        if (isFunction(angular.resumeDeferredBootstrap)) {
          angular.resumeDeferredBootstrap();
        }
      }
      function reloadWithDebugInfo() {
        window.name = 'NG_ENABLE_DEBUG_INFO!' + window.name;
        window.location.reload();
      }
      function getTestability(rootElement) {
        var injector = angular.element(rootElement).injector();
        if (!injector) {
          throw ngMinErr('test', 'no injector found for element argument to getTestability');
        }
        return injector.get('$$testability');
      }
      var SNAKE_CASE_REGEXP = /[A-Z]/g;
      function snake_case(name, separator) {
        separator = separator || '_';
        return name.replace(SNAKE_CASE_REGEXP, function(letter, pos) {
          return (pos ? separator : '') + letter.toLowerCase();
        });
      }
      var bindJQueryFired = false;
      function bindJQuery() {
        var originalCleanData;
        if (bindJQueryFired) {
          return;
        }
        var jqName = jq();
        jQuery = isUndefined(jqName) ? window.jQuery : !jqName ? undefined : window[jqName];
        if (jQuery && jQuery.fn.on) {
          jqLite = jQuery;
          extend(jQuery.fn, {
            scope: JQLitePrototype.scope,
            isolateScope: JQLitePrototype.isolateScope,
            controller: JQLitePrototype.controller,
            injector: JQLitePrototype.injector,
            inheritedData: JQLitePrototype.inheritedData
          });
          originalCleanData = jQuery.cleanData;
          jQuery.cleanData = function(elems) {
            var events;
            for (var i = 0,
                elem; (elem = elems[i]) != null; i++) {
              events = jQuery._data(elem, "events");
              if (events && events.$destroy) {
                jQuery(elem).triggerHandler('$destroy');
              }
            }
            originalCleanData(elems);
          };
        } else {
          jqLite = JQLite;
        }
        angular.element = jqLite;
        bindJQueryFired = true;
      }
      function assertArg(arg, name, reason) {
        if (!arg) {
          throw ngMinErr('areq', "Argument '{0}' is {1}", (name || '?'), (reason || "required"));
        }
        return arg;
      }
      function assertArgFn(arg, name, acceptArrayAnnotation) {
        if (acceptArrayAnnotation && isArray(arg)) {
          arg = arg[arg.length - 1];
        }
        assertArg(isFunction(arg), name, 'not a function, got ' + (arg && typeof arg === 'object' ? arg.constructor.name || 'Object' : typeof arg));
        return arg;
      }
      function assertNotHasOwnProperty(name, context) {
        if (name === 'hasOwnProperty') {
          throw ngMinErr('badname', "hasOwnProperty is not a valid {0} name", context);
        }
      }
      function getter(obj, path, bindFnToScope) {
        if (!path)
          return obj;
        var keys = path.split('.');
        var key;
        var lastInstance = obj;
        var len = keys.length;
        for (var i = 0; i < len; i++) {
          key = keys[i];
          if (obj) {
            obj = (lastInstance = obj)[key];
          }
        }
        if (!bindFnToScope && isFunction(obj)) {
          return bind(lastInstance, obj);
        }
        return obj;
      }
      function getBlockNodes(nodes) {
        var node = nodes[0];
        var endNode = nodes[nodes.length - 1];
        var blockNodes;
        for (var i = 1; node !== endNode && (node = node.nextSibling); i++) {
          if (blockNodes || nodes[i] !== node) {
            if (!blockNodes) {
              blockNodes = jqLite(slice.call(nodes, 0, i));
            }
            blockNodes.push(node);
          }
        }
        return blockNodes || nodes;
      }
      function createMap() {
        return Object.create(null);
      }
      var NODE_TYPE_ELEMENT = 1;
      var NODE_TYPE_ATTRIBUTE = 2;
      var NODE_TYPE_TEXT = 3;
      var NODE_TYPE_COMMENT = 8;
      var NODE_TYPE_DOCUMENT = 9;
      var NODE_TYPE_DOCUMENT_FRAGMENT = 11;
      function setupModuleLoader(window) {
        var $injectorMinErr = minErr('$injector');
        var ngMinErr = minErr('ng');
        function ensure(obj, name, factory) {
          return obj[name] || (obj[name] = factory());
        }
        var angular = ensure(window, 'angular', Object);
        angular.$$minErr = angular.$$minErr || minErr;
        return ensure(angular, 'module', function() {
          var modules = {};
          return function module(name, requires, configFn) {
            var assertNotHasOwnProperty = function(name, context) {
              if (name === 'hasOwnProperty') {
                throw ngMinErr('badname', 'hasOwnProperty is not a valid {0} name', context);
              }
            };
            assertNotHasOwnProperty(name, 'module');
            if (requires && modules.hasOwnProperty(name)) {
              modules[name] = null;
            }
            return ensure(modules, name, function() {
              if (!requires) {
                throw $injectorMinErr('nomod', "Module '{0}' is not available! You either misspelled " + "the module name or forgot to load it. If registering a module ensure that you " + "specify the dependencies as the second argument.", name);
              }
              var invokeQueue = [];
              var configBlocks = [];
              var runBlocks = [];
              var config = invokeLater('$injector', 'invoke', 'push', configBlocks);
              var moduleInstance = {
                _invokeQueue: invokeQueue,
                _configBlocks: configBlocks,
                _runBlocks: runBlocks,
                requires: requires,
                name: name,
                provider: invokeLaterAndSetModuleName('$provide', 'provider'),
                factory: invokeLaterAndSetModuleName('$provide', 'factory'),
                service: invokeLaterAndSetModuleName('$provide', 'service'),
                value: invokeLater('$provide', 'value'),
                constant: invokeLater('$provide', 'constant', 'unshift'),
                decorator: invokeLaterAndSetModuleName('$provide', 'decorator'),
                animation: invokeLaterAndSetModuleName('$animateProvider', 'register'),
                filter: invokeLaterAndSetModuleName('$filterProvider', 'register'),
                controller: invokeLaterAndSetModuleName('$controllerProvider', 'register'),
                directive: invokeLaterAndSetModuleName('$compileProvider', 'directive'),
                component: invokeLaterAndSetModuleName('$compileProvider', 'component'),
                config: config,
                run: function(block) {
                  runBlocks.push(block);
                  return this;
                }
              };
              if (configFn) {
                config(configFn);
              }
              return moduleInstance;
              function invokeLater(provider, method, insertMethod, queue) {
                if (!queue)
                  queue = invokeQueue;
                return function() {
                  queue[insertMethod || 'push']([provider, method, arguments]);
                  return moduleInstance;
                };
              }
              function invokeLaterAndSetModuleName(provider, method) {
                return function(recipeName, factoryFunction) {
                  if (factoryFunction && isFunction(factoryFunction))
                    factoryFunction.$$moduleName = name;
                  invokeQueue.push([provider, method, arguments]);
                  return moduleInstance;
                };
              }
            });
          };
        });
      }
      function shallowCopy(src, dst) {
        if (isArray(src)) {
          dst = dst || [];
          for (var i = 0,
              ii = src.length; i < ii; i++) {
            dst[i] = src[i];
          }
        } else if (isObject(src)) {
          dst = dst || {};
          for (var key in src) {
            if (!(key.charAt(0) === '$' && key.charAt(1) === '$')) {
              dst[key] = src[key];
            }
          }
        }
        return dst || src;
      }
      function serializeObject(obj) {
        var seen = [];
        return JSON.stringify(obj, function(key, val) {
          val = toJsonReplacer(key, val);
          if (isObject(val)) {
            if (seen.indexOf(val) >= 0)
              return '...';
            seen.push(val);
          }
          return val;
        });
      }
      function toDebugString(obj) {
        if (typeof obj === 'function') {
          return obj.toString().replace(/ \{[\s\S]*$/, '');
        } else if (isUndefined(obj)) {
          return 'undefined';
        } else if (typeof obj !== 'string') {
          return serializeObject(obj);
        }
        return obj;
      }
      var version = {
        full: '1.5.7',
        major: 1,
        minor: 5,
        dot: 7,
        codeName: 'hexagonal-circumvolution'
      };
      function publishExternalAPI(angular) {
        extend(angular, {
          'bootstrap': bootstrap,
          'copy': copy,
          'extend': extend,
          'merge': merge,
          'equals': equals,
          'element': jqLite,
          'forEach': forEach,
          'injector': createInjector,
          'noop': noop,
          'bind': bind,
          'toJson': toJson,
          'fromJson': fromJson,
          'identity': identity,
          'isUndefined': isUndefined,
          'isDefined': isDefined,
          'isString': isString,
          'isFunction': isFunction,
          'isObject': isObject,
          'isNumber': isNumber,
          'isElement': isElement,
          'isArray': isArray,
          'version': version,
          'isDate': isDate,
          'lowercase': lowercase,
          'uppercase': uppercase,
          'callbacks': {counter: 0},
          'getTestability': getTestability,
          '$$minErr': minErr,
          '$$csp': csp,
          'reloadWithDebugInfo': reloadWithDebugInfo
        });
        angularModule = setupModuleLoader(window);
        angularModule('ng', ['ngLocale'], ['$provide', function ngModule($provide) {
          $provide.provider({$$sanitizeUri: $$SanitizeUriProvider});
          $provide.provider('$compile', $CompileProvider).directive({
            a: htmlAnchorDirective,
            input: inputDirective,
            textarea: inputDirective,
            form: formDirective,
            script: scriptDirective,
            select: selectDirective,
            style: styleDirective,
            option: optionDirective,
            ngBind: ngBindDirective,
            ngBindHtml: ngBindHtmlDirective,
            ngBindTemplate: ngBindTemplateDirective,
            ngClass: ngClassDirective,
            ngClassEven: ngClassEvenDirective,
            ngClassOdd: ngClassOddDirective,
            ngCloak: ngCloakDirective,
            ngController: ngControllerDirective,
            ngForm: ngFormDirective,
            ngHide: ngHideDirective,
            ngIf: ngIfDirective,
            ngInclude: ngIncludeDirective,
            ngInit: ngInitDirective,
            ngNonBindable: ngNonBindableDirective,
            ngPluralize: ngPluralizeDirective,
            ngRepeat: ngRepeatDirective,
            ngShow: ngShowDirective,
            ngStyle: ngStyleDirective,
            ngSwitch: ngSwitchDirective,
            ngSwitchWhen: ngSwitchWhenDirective,
            ngSwitchDefault: ngSwitchDefaultDirective,
            ngOptions: ngOptionsDirective,
            ngTransclude: ngTranscludeDirective,
            ngModel: ngModelDirective,
            ngList: ngListDirective,
            ngChange: ngChangeDirective,
            pattern: patternDirective,
            ngPattern: patternDirective,
            required: requiredDirective,
            ngRequired: requiredDirective,
            minlength: minlengthDirective,
            ngMinlength: minlengthDirective,
            maxlength: maxlengthDirective,
            ngMaxlength: maxlengthDirective,
            ngValue: ngValueDirective,
            ngModelOptions: ngModelOptionsDirective
          }).directive({ngInclude: ngIncludeFillContentDirective}).directive(ngAttributeAliasDirectives).directive(ngEventDirectives);
          $provide.provider({
            $anchorScroll: $AnchorScrollProvider,
            $animate: $AnimateProvider,
            $animateCss: $CoreAnimateCssProvider,
            $$animateJs: $$CoreAnimateJsProvider,
            $$animateQueue: $$CoreAnimateQueueProvider,
            $$AnimateRunner: $$AnimateRunnerFactoryProvider,
            $$animateAsyncRun: $$AnimateAsyncRunFactoryProvider,
            $browser: $BrowserProvider,
            $cacheFactory: $CacheFactoryProvider,
            $controller: $ControllerProvider,
            $document: $DocumentProvider,
            $exceptionHandler: $ExceptionHandlerProvider,
            $filter: $FilterProvider,
            $$forceReflow: $$ForceReflowProvider,
            $interpolate: $InterpolateProvider,
            $interval: $IntervalProvider,
            $http: $HttpProvider,
            $httpParamSerializer: $HttpParamSerializerProvider,
            $httpParamSerializerJQLike: $HttpParamSerializerJQLikeProvider,
            $httpBackend: $HttpBackendProvider,
            $xhrFactory: $xhrFactoryProvider,
            $location: $LocationProvider,
            $log: $LogProvider,
            $parse: $ParseProvider,
            $rootScope: $RootScopeProvider,
            $q: $QProvider,
            $$q: $$QProvider,
            $sce: $SceProvider,
            $sceDelegate: $SceDelegateProvider,
            $sniffer: $SnifferProvider,
            $templateCache: $TemplateCacheProvider,
            $templateRequest: $TemplateRequestProvider,
            $$testability: $$TestabilityProvider,
            $timeout: $TimeoutProvider,
            $window: $WindowProvider,
            $$rAF: $$RAFProvider,
            $$jqLite: $$jqLiteProvider,
            $$HashMap: $$HashMapProvider,
            $$cookieReader: $$CookieReaderProvider
          });
        }]);
      }
      JQLite.expando = 'ng339';
      var jqCache = JQLite.cache = {},
          jqId = 1,
          addEventListenerFn = function(element, type, fn) {
            element.addEventListener(type, fn, false);
          },
          removeEventListenerFn = function(element, type, fn) {
            element.removeEventListener(type, fn, false);
          };
      JQLite._data = function(node) {
        return this.cache[node[this.expando]] || {};
      };
      function jqNextId() {
        return ++jqId;
      }
      var SPECIAL_CHARS_REGEXP = /([\:\-\_]+(.))/g;
      var MOZ_HACK_REGEXP = /^moz([A-Z])/;
      var MOUSE_EVENT_MAP = {
        mouseleave: "mouseout",
        mouseenter: "mouseover"
      };
      var jqLiteMinErr = minErr('jqLite');
      function camelCase(name) {
        return name.replace(SPECIAL_CHARS_REGEXP, function(_, separator, letter, offset) {
          return offset ? letter.toUpperCase() : letter;
        }).replace(MOZ_HACK_REGEXP, 'Moz$1');
      }
      var SINGLE_TAG_REGEXP = /^<([\w-]+)\s*\/?>(?:<\/\1>|)$/;
      var HTML_REGEXP = /<|&#?\w+;/;
      var TAG_NAME_REGEXP = /<([\w:-]+)/;
      var XHTML_TAG_REGEXP = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([\w:-]+)[^>]*)\/>/gi;
      var wrapMap = {
        'option': [1, '<select multiple="multiple">', '</select>'],
        'thead': [1, '<table>', '</table>'],
        'col': [2, '<table><colgroup>', '</colgroup></table>'],
        'tr': [2, '<table><tbody>', '</tbody></table>'],
        'td': [3, '<table><tbody><tr>', '</tr></tbody></table>'],
        '_default': [0, "", ""]
      };
      wrapMap.optgroup = wrapMap.option;
      wrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead;
      wrapMap.th = wrapMap.td;
      function jqLiteIsTextNode(html) {
        return !HTML_REGEXP.test(html);
      }
      function jqLiteAcceptsData(node) {
        var nodeType = node.nodeType;
        return nodeType === NODE_TYPE_ELEMENT || !nodeType || nodeType === NODE_TYPE_DOCUMENT;
      }
      function jqLiteHasData(node) {
        for (var key in jqCache[node.ng339]) {
          return true;
        }
        return false;
      }
      function jqLiteCleanData(nodes) {
        for (var i = 0,
            ii = nodes.length; i < ii; i++) {
          jqLiteRemoveData(nodes[i]);
        }
      }
      function jqLiteBuildFragment(html, context) {
        var tmp,
            tag,
            wrap,
            fragment = context.createDocumentFragment(),
            nodes = [],
            i;
        if (jqLiteIsTextNode(html)) {
          nodes.push(context.createTextNode(html));
        } else {
          tmp = tmp || fragment.appendChild(context.createElement("div"));
          tag = (TAG_NAME_REGEXP.exec(html) || ["", ""])[1].toLowerCase();
          wrap = wrapMap[tag] || wrapMap._default;
          tmp.innerHTML = wrap[1] + html.replace(XHTML_TAG_REGEXP, "<$1></$2>") + wrap[2];
          i = wrap[0];
          while (i--) {
            tmp = tmp.lastChild;
          }
          nodes = concat(nodes, tmp.childNodes);
          tmp = fragment.firstChild;
          tmp.textContent = "";
        }
        fragment.textContent = "";
        fragment.innerHTML = "";
        forEach(nodes, function(node) {
          fragment.appendChild(node);
        });
        return fragment;
      }
      function jqLiteParseHTML(html, context) {
        context = context || window.document;
        var parsed;
        if ((parsed = SINGLE_TAG_REGEXP.exec(html))) {
          return [context.createElement(parsed[1])];
        }
        if ((parsed = jqLiteBuildFragment(html, context))) {
          return parsed.childNodes;
        }
        return [];
      }
      function jqLiteWrapNode(node, wrapper) {
        var parent = node.parentNode;
        if (parent) {
          parent.replaceChild(wrapper, node);
        }
        wrapper.appendChild(node);
      }
      var jqLiteContains = window.Node.prototype.contains || function(arg) {
        return !!(this.compareDocumentPosition(arg) & 16);
      };
      function JQLite(element) {
        if (element instanceof JQLite) {
          return element;
        }
        var argIsString;
        if (isString(element)) {
          element = trim(element);
          argIsString = true;
        }
        if (!(this instanceof JQLite)) {
          if (argIsString && element.charAt(0) != '<') {
            throw jqLiteMinErr('nosel', 'Looking up elements via selectors is not supported by jqLite! See: http://docs.angularjs.org/api/angular.element');
          }
          return new JQLite(element);
        }
        if (argIsString) {
          jqLiteAddNodes(this, jqLiteParseHTML(element));
        } else {
          jqLiteAddNodes(this, element);
        }
      }
      function jqLiteClone(element) {
        return element.cloneNode(true);
      }
      function jqLiteDealoc(element, onlyDescendants) {
        if (!onlyDescendants)
          jqLiteRemoveData(element);
        if (element.querySelectorAll) {
          var descendants = element.querySelectorAll('*');
          for (var i = 0,
              l = descendants.length; i < l; i++) {
            jqLiteRemoveData(descendants[i]);
          }
        }
      }
      function jqLiteOff(element, type, fn, unsupported) {
        if (isDefined(unsupported))
          throw jqLiteMinErr('offargs', 'jqLite#off() does not support the `selector` argument');
        var expandoStore = jqLiteExpandoStore(element);
        var events = expandoStore && expandoStore.events;
        var handle = expandoStore && expandoStore.handle;
        if (!handle)
          return;
        if (!type) {
          for (type in events) {
            if (type !== '$destroy') {
              removeEventListenerFn(element, type, handle);
            }
            delete events[type];
          }
        } else {
          var removeHandler = function(type) {
            var listenerFns = events[type];
            if (isDefined(fn)) {
              arrayRemove(listenerFns || [], fn);
            }
            if (!(isDefined(fn) && listenerFns && listenerFns.length > 0)) {
              removeEventListenerFn(element, type, handle);
              delete events[type];
            }
          };
          forEach(type.split(' '), function(type) {
            removeHandler(type);
            if (MOUSE_EVENT_MAP[type]) {
              removeHandler(MOUSE_EVENT_MAP[type]);
            }
          });
        }
      }
      function jqLiteRemoveData(element, name) {
        var expandoId = element.ng339;
        var expandoStore = expandoId && jqCache[expandoId];
        if (expandoStore) {
          if (name) {
            delete expandoStore.data[name];
            return;
          }
          if (expandoStore.handle) {
            if (expandoStore.events.$destroy) {
              expandoStore.handle({}, '$destroy');
            }
            jqLiteOff(element);
          }
          delete jqCache[expandoId];
          element.ng339 = undefined;
        }
      }
      function jqLiteExpandoStore(element, createIfNecessary) {
        var expandoId = element.ng339,
            expandoStore = expandoId && jqCache[expandoId];
        if (createIfNecessary && !expandoStore) {
          element.ng339 = expandoId = jqNextId();
          expandoStore = jqCache[expandoId] = {
            events: {},
            data: {},
            handle: undefined
          };
        }
        return expandoStore;
      }
      function jqLiteData(element, key, value) {
        if (jqLiteAcceptsData(element)) {
          var isSimpleSetter = isDefined(value);
          var isSimpleGetter = !isSimpleSetter && key && !isObject(key);
          var massGetter = !key;
          var expandoStore = jqLiteExpandoStore(element, !isSimpleGetter);
          var data = expandoStore && expandoStore.data;
          if (isSimpleSetter) {
            data[key] = value;
          } else {
            if (massGetter) {
              return data;
            } else {
              if (isSimpleGetter) {
                return data && data[key];
              } else {
                extend(data, key);
              }
            }
          }
        }
      }
      function jqLiteHasClass(element, selector) {
        if (!element.getAttribute)
          return false;
        return ((" " + (element.getAttribute('class') || '') + " ").replace(/[\n\t]/g, " ").indexOf(" " + selector + " ") > -1);
      }
      function jqLiteRemoveClass(element, cssClasses) {
        if (cssClasses && element.setAttribute) {
          forEach(cssClasses.split(' '), function(cssClass) {
            element.setAttribute('class', trim((" " + (element.getAttribute('class') || '') + " ").replace(/[\n\t]/g, " ").replace(" " + trim(cssClass) + " ", " ")));
          });
        }
      }
      function jqLiteAddClass(element, cssClasses) {
        if (cssClasses && element.setAttribute) {
          var existingClasses = (' ' + (element.getAttribute('class') || '') + ' ').replace(/[\n\t]/g, " ");
          forEach(cssClasses.split(' '), function(cssClass) {
            cssClass = trim(cssClass);
            if (existingClasses.indexOf(' ' + cssClass + ' ') === -1) {
              existingClasses += cssClass + ' ';
            }
          });
          element.setAttribute('class', trim(existingClasses));
        }
      }
      function jqLiteAddNodes(root, elements) {
        if (elements) {
          if (elements.nodeType) {
            root[root.length++] = elements;
          } else {
            var length = elements.length;
            if (typeof length === 'number' && elements.window !== elements) {
              if (length) {
                for (var i = 0; i < length; i++) {
                  root[root.length++] = elements[i];
                }
              }
            } else {
              root[root.length++] = elements;
            }
          }
        }
      }
      function jqLiteController(element, name) {
        return jqLiteInheritedData(element, '$' + (name || 'ngController') + 'Controller');
      }
      function jqLiteInheritedData(element, name, value) {
        if (element.nodeType == NODE_TYPE_DOCUMENT) {
          element = element.documentElement;
        }
        var names = isArray(name) ? name : [name];
        while (element) {
          for (var i = 0,
              ii = names.length; i < ii; i++) {
            if (isDefined(value = jqLite.data(element, names[i])))
              return value;
          }
          element = element.parentNode || (element.nodeType === NODE_TYPE_DOCUMENT_FRAGMENT && element.host);
        }
      }
      function jqLiteEmpty(element) {
        jqLiteDealoc(element, true);
        while (element.firstChild) {
          element.removeChild(element.firstChild);
        }
      }
      function jqLiteRemove(element, keepData) {
        if (!keepData)
          jqLiteDealoc(element);
        var parent = element.parentNode;
        if (parent)
          parent.removeChild(element);
      }
      function jqLiteDocumentLoaded(action, win) {
        win = win || window;
        if (win.document.readyState === 'complete') {
          win.setTimeout(action);
        } else {
          jqLite(win).on('load', action);
        }
      }
      var JQLitePrototype = JQLite.prototype = {
        ready: function(fn) {
          var fired = false;
          function trigger() {
            if (fired)
              return;
            fired = true;
            fn();
          }
          if (window.document.readyState === 'complete') {
            window.setTimeout(trigger);
          } else {
            this.on('DOMContentLoaded', trigger);
            JQLite(window).on('load', trigger);
          }
        },
        toString: function() {
          var value = [];
          forEach(this, function(e) {
            value.push('' + e);
          });
          return '[' + value.join(', ') + ']';
        },
        eq: function(index) {
          return (index >= 0) ? jqLite(this[index]) : jqLite(this[this.length + index]);
        },
        length: 0,
        push: push,
        sort: [].sort,
        splice: [].splice
      };
      var BOOLEAN_ATTR = {};
      forEach('multiple,selected,checked,disabled,readOnly,required,open'.split(','), function(value) {
        BOOLEAN_ATTR[lowercase(value)] = value;
      });
      var BOOLEAN_ELEMENTS = {};
      forEach('input,select,option,textarea,button,form,details'.split(','), function(value) {
        BOOLEAN_ELEMENTS[value] = true;
      });
      var ALIASED_ATTR = {
        'ngMinlength': 'minlength',
        'ngMaxlength': 'maxlength',
        'ngMin': 'min',
        'ngMax': 'max',
        'ngPattern': 'pattern'
      };
      function getBooleanAttrName(element, name) {
        var booleanAttr = BOOLEAN_ATTR[name.toLowerCase()];
        return booleanAttr && BOOLEAN_ELEMENTS[nodeName_(element)] && booleanAttr;
      }
      function getAliasedAttrName(name) {
        return ALIASED_ATTR[name];
      }
      forEach({
        data: jqLiteData,
        removeData: jqLiteRemoveData,
        hasData: jqLiteHasData,
        cleanData: jqLiteCleanData
      }, function(fn, name) {
        JQLite[name] = fn;
      });
      forEach({
        data: jqLiteData,
        inheritedData: jqLiteInheritedData,
        scope: function(element) {
          return jqLite.data(element, '$scope') || jqLiteInheritedData(element.parentNode || element, ['$isolateScope', '$scope']);
        },
        isolateScope: function(element) {
          return jqLite.data(element, '$isolateScope') || jqLite.data(element, '$isolateScopeNoTemplate');
        },
        controller: jqLiteController,
        injector: function(element) {
          return jqLiteInheritedData(element, '$injector');
        },
        removeAttr: function(element, name) {
          element.removeAttribute(name);
        },
        hasClass: jqLiteHasClass,
        css: function(element, name, value) {
          name = camelCase(name);
          if (isDefined(value)) {
            element.style[name] = value;
          } else {
            return element.style[name];
          }
        },
        attr: function(element, name, value) {
          var nodeType = element.nodeType;
          if (nodeType === NODE_TYPE_TEXT || nodeType === NODE_TYPE_ATTRIBUTE || nodeType === NODE_TYPE_COMMENT) {
            return;
          }
          var lowercasedName = lowercase(name);
          if (BOOLEAN_ATTR[lowercasedName]) {
            if (isDefined(value)) {
              if (!!value) {
                element[name] = true;
                element.setAttribute(name, lowercasedName);
              } else {
                element[name] = false;
                element.removeAttribute(lowercasedName);
              }
            } else {
              return (element[name] || (element.attributes.getNamedItem(name) || noop).specified) ? lowercasedName : undefined;
            }
          } else if (isDefined(value)) {
            element.setAttribute(name, value);
          } else if (element.getAttribute) {
            var ret = element.getAttribute(name, 2);
            return ret === null ? undefined : ret;
          }
        },
        prop: function(element, name, value) {
          if (isDefined(value)) {
            element[name] = value;
          } else {
            return element[name];
          }
        },
        text: (function() {
          getText.$dv = '';
          return getText;
          function getText(element, value) {
            if (isUndefined(value)) {
              var nodeType = element.nodeType;
              return (nodeType === NODE_TYPE_ELEMENT || nodeType === NODE_TYPE_TEXT) ? element.textContent : '';
            }
            element.textContent = value;
          }
        })(),
        val: function(element, value) {
          if (isUndefined(value)) {
            if (element.multiple && nodeName_(element) === 'select') {
              var result = [];
              forEach(element.options, function(option) {
                if (option.selected) {
                  result.push(option.value || option.text);
                }
              });
              return result.length === 0 ? null : result;
            }
            return element.value;
          }
          element.value = value;
        },
        html: function(element, value) {
          if (isUndefined(value)) {
            return element.innerHTML;
          }
          jqLiteDealoc(element, true);
          element.innerHTML = value;
        },
        empty: jqLiteEmpty
      }, function(fn, name) {
        JQLite.prototype[name] = function(arg1, arg2) {
          var i,
              key;
          var nodeCount = this.length;
          if (fn !== jqLiteEmpty && (isUndefined((fn.length == 2 && (fn !== jqLiteHasClass && fn !== jqLiteController)) ? arg1 : arg2))) {
            if (isObject(arg1)) {
              for (i = 0; i < nodeCount; i++) {
                if (fn === jqLiteData) {
                  fn(this[i], arg1);
                } else {
                  for (key in arg1) {
                    fn(this[i], key, arg1[key]);
                  }
                }
              }
              return this;
            } else {
              var value = fn.$dv;
              var jj = (isUndefined(value)) ? Math.min(nodeCount, 1) : nodeCount;
              for (var j = 0; j < jj; j++) {
                var nodeValue = fn(this[j], arg1, arg2);
                value = value ? value + nodeValue : nodeValue;
              }
              return value;
            }
          } else {
            for (i = 0; i < nodeCount; i++) {
              fn(this[i], arg1, arg2);
            }
            return this;
          }
        };
      });
      function createEventHandler(element, events) {
        var eventHandler = function(event, type) {
          event.isDefaultPrevented = function() {
            return event.defaultPrevented;
          };
          var eventFns = events[type || event.type];
          var eventFnsLength = eventFns ? eventFns.length : 0;
          if (!eventFnsLength)
            return;
          if (isUndefined(event.immediatePropagationStopped)) {
            var originalStopImmediatePropagation = event.stopImmediatePropagation;
            event.stopImmediatePropagation = function() {
              event.immediatePropagationStopped = true;
              if (event.stopPropagation) {
                event.stopPropagation();
              }
              if (originalStopImmediatePropagation) {
                originalStopImmediatePropagation.call(event);
              }
            };
          }
          event.isImmediatePropagationStopped = function() {
            return event.immediatePropagationStopped === true;
          };
          var handlerWrapper = eventFns.specialHandlerWrapper || defaultHandlerWrapper;
          if ((eventFnsLength > 1)) {
            eventFns = shallowCopy(eventFns);
          }
          for (var i = 0; i < eventFnsLength; i++) {
            if (!event.isImmediatePropagationStopped()) {
              handlerWrapper(element, event, eventFns[i]);
            }
          }
        };
        eventHandler.elem = element;
        return eventHandler;
      }
      function defaultHandlerWrapper(element, event, handler) {
        handler.call(element, event);
      }
      function specialMouseHandlerWrapper(target, event, handler) {
        var related = event.relatedTarget;
        if (!related || (related !== target && !jqLiteContains.call(target, related))) {
          handler.call(target, event);
        }
      }
      forEach({
        removeData: jqLiteRemoveData,
        on: function jqLiteOn(element, type, fn, unsupported) {
          if (isDefined(unsupported))
            throw jqLiteMinErr('onargs', 'jqLite#on() does not support the `selector` or `eventData` parameters');
          if (!jqLiteAcceptsData(element)) {
            return;
          }
          var expandoStore = jqLiteExpandoStore(element, true);
          var events = expandoStore.events;
          var handle = expandoStore.handle;
          if (!handle) {
            handle = expandoStore.handle = createEventHandler(element, events);
          }
          var types = type.indexOf(' ') >= 0 ? type.split(' ') : [type];
          var i = types.length;
          var addHandler = function(type, specialHandlerWrapper, noEventListener) {
            var eventFns = events[type];
            if (!eventFns) {
              eventFns = events[type] = [];
              eventFns.specialHandlerWrapper = specialHandlerWrapper;
              if (type !== '$destroy' && !noEventListener) {
                addEventListenerFn(element, type, handle);
              }
            }
            eventFns.push(fn);
          };
          while (i--) {
            type = types[i];
            if (MOUSE_EVENT_MAP[type]) {
              addHandler(MOUSE_EVENT_MAP[type], specialMouseHandlerWrapper);
              addHandler(type, undefined, true);
            } else {
              addHandler(type);
            }
          }
        },
        off: jqLiteOff,
        one: function(element, type, fn) {
          element = jqLite(element);
          element.on(type, function onFn() {
            element.off(type, fn);
            element.off(type, onFn);
          });
          element.on(type, fn);
        },
        replaceWith: function(element, replaceNode) {
          var index,
              parent = element.parentNode;
          jqLiteDealoc(element);
          forEach(new JQLite(replaceNode), function(node) {
            if (index) {
              parent.insertBefore(node, index.nextSibling);
            } else {
              parent.replaceChild(node, element);
            }
            index = node;
          });
        },
        children: function(element) {
          var children = [];
          forEach(element.childNodes, function(element) {
            if (element.nodeType === NODE_TYPE_ELEMENT) {
              children.push(element);
            }
          });
          return children;
        },
        contents: function(element) {
          return element.contentDocument || element.childNodes || [];
        },
        append: function(element, node) {
          var nodeType = element.nodeType;
          if (nodeType !== NODE_TYPE_ELEMENT && nodeType !== NODE_TYPE_DOCUMENT_FRAGMENT)
            return;
          node = new JQLite(node);
          for (var i = 0,
              ii = node.length; i < ii; i++) {
            var child = node[i];
            element.appendChild(child);
          }
        },
        prepend: function(element, node) {
          if (element.nodeType === NODE_TYPE_ELEMENT) {
            var index = element.firstChild;
            forEach(new JQLite(node), function(child) {
              element.insertBefore(child, index);
            });
          }
        },
        wrap: function(element, wrapNode) {
          jqLiteWrapNode(element, jqLite(wrapNode).eq(0).clone()[0]);
        },
        remove: jqLiteRemove,
        detach: function(element) {
          jqLiteRemove(element, true);
        },
        after: function(element, newElement) {
          var index = element,
              parent = element.parentNode;
          newElement = new JQLite(newElement);
          for (var i = 0,
              ii = newElement.length; i < ii; i++) {
            var node = newElement[i];
            parent.insertBefore(node, index.nextSibling);
            index = node;
          }
        },
        addClass: jqLiteAddClass,
        removeClass: jqLiteRemoveClass,
        toggleClass: function(element, selector, condition) {
          if (selector) {
            forEach(selector.split(' '), function(className) {
              var classCondition = condition;
              if (isUndefined(classCondition)) {
                classCondition = !jqLiteHasClass(element, className);
              }
              (classCondition ? jqLiteAddClass : jqLiteRemoveClass)(element, className);
            });
          }
        },
        parent: function(element) {
          var parent = element.parentNode;
          return parent && parent.nodeType !== NODE_TYPE_DOCUMENT_FRAGMENT ? parent : null;
        },
        next: function(element) {
          return element.nextElementSibling;
        },
        find: function(element, selector) {
          if (element.getElementsByTagName) {
            return element.getElementsByTagName(selector);
          } else {
            return [];
          }
        },
        clone: jqLiteClone,
        triggerHandler: function(element, event, extraParameters) {
          var dummyEvent,
              eventFnsCopy,
              handlerArgs;
          var eventName = event.type || event;
          var expandoStore = jqLiteExpandoStore(element);
          var events = expandoStore && expandoStore.events;
          var eventFns = events && events[eventName];
          if (eventFns) {
            dummyEvent = {
              preventDefault: function() {
                this.defaultPrevented = true;
              },
              isDefaultPrevented: function() {
                return this.defaultPrevented === true;
              },
              stopImmediatePropagation: function() {
                this.immediatePropagationStopped = true;
              },
              isImmediatePropagationStopped: function() {
                return this.immediatePropagationStopped === true;
              },
              stopPropagation: noop,
              type: eventName,
              target: element
            };
            if (event.type) {
              dummyEvent = extend(dummyEvent, event);
            }
            eventFnsCopy = shallowCopy(eventFns);
            handlerArgs = extraParameters ? [dummyEvent].concat(extraParameters) : [dummyEvent];
            forEach(eventFnsCopy, function(fn) {
              if (!dummyEvent.isImmediatePropagationStopped()) {
                fn.apply(element, handlerArgs);
              }
            });
          }
        }
      }, function(fn, name) {
        JQLite.prototype[name] = function(arg1, arg2, arg3) {
          var value;
          for (var i = 0,
              ii = this.length; i < ii; i++) {
            if (isUndefined(value)) {
              value = fn(this[i], arg1, arg2, arg3);
              if (isDefined(value)) {
                value = jqLite(value);
              }
            } else {
              jqLiteAddNodes(value, fn(this[i], arg1, arg2, arg3));
            }
          }
          return isDefined(value) ? value : this;
        };
        JQLite.prototype.bind = JQLite.prototype.on;
        JQLite.prototype.unbind = JQLite.prototype.off;
      });
      function $$jqLiteProvider() {
        this.$get = function $$jqLite() {
          return extend(JQLite, {
            hasClass: function(node, classes) {
              if (node.attr)
                node = node[0];
              return jqLiteHasClass(node, classes);
            },
            addClass: function(node, classes) {
              if (node.attr)
                node = node[0];
              return jqLiteAddClass(node, classes);
            },
            removeClass: function(node, classes) {
              if (node.attr)
                node = node[0];
              return jqLiteRemoveClass(node, classes);
            }
          });
        };
      }
      function hashKey(obj, nextUidFn) {
        var key = obj && obj.$$hashKey;
        if (key) {
          if (typeof key === 'function') {
            key = obj.$$hashKey();
          }
          return key;
        }
        var objType = typeof obj;
        if (objType == 'function' || (objType == 'object' && obj !== null)) {
          key = obj.$$hashKey = objType + ':' + (nextUidFn || nextUid)();
        } else {
          key = objType + ':' + obj;
        }
        return key;
      }
      function HashMap(array, isolatedUid) {
        if (isolatedUid) {
          var uid = 0;
          this.nextUid = function() {
            return ++uid;
          };
        }
        forEach(array, this.put, this);
      }
      HashMap.prototype = {
        put: function(key, value) {
          this[hashKey(key, this.nextUid)] = value;
        },
        get: function(key) {
          return this[hashKey(key, this.nextUid)];
        },
        remove: function(key) {
          var value = this[key = hashKey(key, this.nextUid)];
          delete this[key];
          return value;
        }
      };
      var $$HashMapProvider = [function() {
        this.$get = [function() {
          return HashMap;
        }];
      }];
      var ARROW_ARG = /^([^\(]+?)=>/;
      var FN_ARGS = /^[^\(]*\(\s*([^\)]*)\)/m;
      var FN_ARG_SPLIT = /,/;
      var FN_ARG = /^\s*(_?)(\S+?)\1\s*$/;
      var STRIP_COMMENTS = /((\/\/.*$)|(\/\*[\s\S]*?\*\/))/mg;
      var $injectorMinErr = minErr('$injector');
      function stringifyFn(fn) {
        return Function.prototype.toString.call(fn) + ' ';
      }
      function extractArgs(fn) {
        var fnText = stringifyFn(fn).replace(STRIP_COMMENTS, ''),
            args = fnText.match(ARROW_ARG) || fnText.match(FN_ARGS);
        return args;
      }
      function anonFn(fn) {
        var args = extractArgs(fn);
        if (args) {
          return 'function(' + (args[1] || '').replace(/[\s\r\n]+/, ' ') + ')';
        }
        return 'fn';
      }
      function annotate(fn, strictDi, name) {
        var $inject,
            argDecl,
            last;
        if (typeof fn === 'function') {
          if (!($inject = fn.$inject)) {
            $inject = [];
            if (fn.length) {
              if (strictDi) {
                if (!isString(name) || !name) {
                  name = fn.name || anonFn(fn);
                }
                throw $injectorMinErr('strictdi', '{0} is not using explicit annotation and cannot be invoked in strict mode', name);
              }
              argDecl = extractArgs(fn);
              forEach(argDecl[1].split(FN_ARG_SPLIT), function(arg) {
                arg.replace(FN_ARG, function(all, underscore, name) {
                  $inject.push(name);
                });
              });
            }
            fn.$inject = $inject;
          }
        } else if (isArray(fn)) {
          last = fn.length - 1;
          assertArgFn(fn[last], 'fn');
          $inject = fn.slice(0, last);
        } else {
          assertArgFn(fn, 'fn', true);
        }
        return $inject;
      }
      function createInjector(modulesToLoad, strictDi) {
        strictDi = (strictDi === true);
        var INSTANTIATING = {},
            providerSuffix = 'Provider',
            path = [],
            loadedModules = new HashMap([], true),
            providerCache = {$provide: {
                provider: supportObject(provider),
                factory: supportObject(factory),
                service: supportObject(service),
                value: supportObject(value),
                constant: supportObject(constant),
                decorator: decorator
              }},
            providerInjector = (providerCache.$injector = createInternalInjector(providerCache, function(serviceName, caller) {
              if (angular.isString(caller)) {
                path.push(caller);
              }
              throw $injectorMinErr('unpr', "Unknown provider: {0}", path.join(' <- '));
            })),
            instanceCache = {},
            protoInstanceInjector = createInternalInjector(instanceCache, function(serviceName, caller) {
              var provider = providerInjector.get(serviceName + providerSuffix, caller);
              return instanceInjector.invoke(provider.$get, provider, undefined, serviceName);
            }),
            instanceInjector = protoInstanceInjector;
        providerCache['$injector' + providerSuffix] = {$get: valueFn(protoInstanceInjector)};
        var runBlocks = loadModules(modulesToLoad);
        instanceInjector = protoInstanceInjector.get('$injector');
        instanceInjector.strictDi = strictDi;
        forEach(runBlocks, function(fn) {
          if (fn)
            instanceInjector.invoke(fn);
        });
        return instanceInjector;
        function supportObject(delegate) {
          return function(key, value) {
            if (isObject(key)) {
              forEach(key, reverseParams(delegate));
            } else {
              return delegate(key, value);
            }
          };
        }
        function provider(name, provider_) {
          assertNotHasOwnProperty(name, 'service');
          if (isFunction(provider_) || isArray(provider_)) {
            provider_ = providerInjector.instantiate(provider_);
          }
          if (!provider_.$get) {
            throw $injectorMinErr('pget', "Provider '{0}' must define $get factory method.", name);
          }
          return providerCache[name + providerSuffix] = provider_;
        }
        function enforceReturnValue(name, factory) {
          return function enforcedReturnValue() {
            var result = instanceInjector.invoke(factory, this);
            if (isUndefined(result)) {
              throw $injectorMinErr('undef', "Provider '{0}' must return a value from $get factory method.", name);
            }
            return result;
          };
        }
        function factory(name, factoryFn, enforce) {
          return provider(name, {$get: enforce !== false ? enforceReturnValue(name, factoryFn) : factoryFn});
        }
        function service(name, constructor) {
          return factory(name, ['$injector', function($injector) {
            return $injector.instantiate(constructor);
          }]);
        }
        function value(name, val) {
          return factory(name, valueFn(val), false);
        }
        function constant(name, value) {
          assertNotHasOwnProperty(name, 'constant');
          providerCache[name] = value;
          instanceCache[name] = value;
        }
        function decorator(serviceName, decorFn) {
          var origProvider = providerInjector.get(serviceName + providerSuffix),
              orig$get = origProvider.$get;
          origProvider.$get = function() {
            var origInstance = instanceInjector.invoke(orig$get, origProvider);
            return instanceInjector.invoke(decorFn, null, {$delegate: origInstance});
          };
        }
        function loadModules(modulesToLoad) {
          assertArg(isUndefined(modulesToLoad) || isArray(modulesToLoad), 'modulesToLoad', 'not an array');
          var runBlocks = [],
              moduleFn;
          forEach(modulesToLoad, function(module) {
            if (loadedModules.get(module))
              return;
            loadedModules.put(module, true);
            function runInvokeQueue(queue) {
              var i,
                  ii;
              for (i = 0, ii = queue.length; i < ii; i++) {
                var invokeArgs = queue[i],
                    provider = providerInjector.get(invokeArgs[0]);
                provider[invokeArgs[1]].apply(provider, invokeArgs[2]);
              }
            }
            try {
              if (isString(module)) {
                moduleFn = angularModule(module);
                runBlocks = runBlocks.concat(loadModules(moduleFn.requires)).concat(moduleFn._runBlocks);
                runInvokeQueue(moduleFn._invokeQueue);
                runInvokeQueue(moduleFn._configBlocks);
              } else if (isFunction(module)) {
                runBlocks.push(providerInjector.invoke(module));
              } else if (isArray(module)) {
                runBlocks.push(providerInjector.invoke(module));
              } else {
                assertArgFn(module, 'module');
              }
            } catch (e) {
              if (isArray(module)) {
                module = module[module.length - 1];
              }
              if (e.message && e.stack && e.stack.indexOf(e.message) == -1) {
                e = e.message + '\n' + e.stack;
              }
              throw $injectorMinErr('modulerr', "Failed to instantiate module {0} due to:\n{1}", module, e.stack || e.message || e);
            }
          });
          return runBlocks;
        }
        function createInternalInjector(cache, factory) {
          function getService(serviceName, caller) {
            if (cache.hasOwnProperty(serviceName)) {
              if (cache[serviceName] === INSTANTIATING) {
                throw $injectorMinErr('cdep', 'Circular dependency found: {0}', serviceName + ' <- ' + path.join(' <- '));
              }
              return cache[serviceName];
            } else {
              try {
                path.unshift(serviceName);
                cache[serviceName] = INSTANTIATING;
                return cache[serviceName] = factory(serviceName, caller);
              } catch (err) {
                if (cache[serviceName] === INSTANTIATING) {
                  delete cache[serviceName];
                }
                throw err;
              } finally {
                path.shift();
              }
            }
          }
          function injectionArgs(fn, locals, serviceName) {
            var args = [],
                $inject = createInjector.$$annotate(fn, strictDi, serviceName);
            for (var i = 0,
                length = $inject.length; i < length; i++) {
              var key = $inject[i];
              if (typeof key !== 'string') {
                throw $injectorMinErr('itkn', 'Incorrect injection token! Expected service name as string, got {0}', key);
              }
              args.push(locals && locals.hasOwnProperty(key) ? locals[key] : getService(key, serviceName));
            }
            return args;
          }
          function isClass(func) {
            if (msie <= 11) {
              return false;
            }
            return typeof func === 'function' && /^(?:class\s|constructor\()/.test(stringifyFn(func));
          }
          function invoke(fn, self, locals, serviceName) {
            if (typeof locals === 'string') {
              serviceName = locals;
              locals = null;
            }
            var args = injectionArgs(fn, locals, serviceName);
            if (isArray(fn)) {
              fn = fn[fn.length - 1];
            }
            if (!isClass(fn)) {
              return fn.apply(self, args);
            } else {
              args.unshift(null);
              return new (Function.prototype.bind.apply(fn, args))();
            }
          }
          function instantiate(Type, locals, serviceName) {
            var ctor = (isArray(Type) ? Type[Type.length - 1] : Type);
            var args = injectionArgs(Type, locals, serviceName);
            args.unshift(null);
            return new (Function.prototype.bind.apply(ctor, args))();
          }
          return {
            invoke: invoke,
            instantiate: instantiate,
            get: getService,
            annotate: createInjector.$$annotate,
            has: function(name) {
              return providerCache.hasOwnProperty(name + providerSuffix) || cache.hasOwnProperty(name);
            }
          };
        }
      }
      createInjector.$$annotate = annotate;
      function $AnchorScrollProvider() {
        var autoScrollingEnabled = true;
        this.disableAutoScrolling = function() {
          autoScrollingEnabled = false;
        };
        this.$get = ['$window', '$location', '$rootScope', function($window, $location, $rootScope) {
          var document = $window.document;
          function getFirstAnchor(list) {
            var result = null;
            Array.prototype.some.call(list, function(element) {
              if (nodeName_(element) === 'a') {
                result = element;
                return true;
              }
            });
            return result;
          }
          function getYOffset() {
            var offset = scroll.yOffset;
            if (isFunction(offset)) {
              offset = offset();
            } else if (isElement(offset)) {
              var elem = offset[0];
              var style = $window.getComputedStyle(elem);
              if (style.position !== 'fixed') {
                offset = 0;
              } else {
                offset = elem.getBoundingClientRect().bottom;
              }
            } else if (!isNumber(offset)) {
              offset = 0;
            }
            return offset;
          }
          function scrollTo(elem) {
            if (elem) {
              elem.scrollIntoView();
              var offset = getYOffset();
              if (offset) {
                var elemTop = elem.getBoundingClientRect().top;
                $window.scrollBy(0, elemTop - offset);
              }
            } else {
              $window.scrollTo(0, 0);
            }
          }
          function scroll(hash) {
            hash = isString(hash) ? hash : $location.hash();
            var elm;
            if (!hash)
              scrollTo(null);
            else if ((elm = document.getElementById(hash)))
              scrollTo(elm);
            else if ((elm = getFirstAnchor(document.getElementsByName(hash))))
              scrollTo(elm);
            else if (hash === 'top')
              scrollTo(null);
          }
          if (autoScrollingEnabled) {
            $rootScope.$watch(function autoScrollWatch() {
              return $location.hash();
            }, function autoScrollWatchAction(newVal, oldVal) {
              if (newVal === oldVal && newVal === '')
                return;
              jqLiteDocumentLoaded(function() {
                $rootScope.$evalAsync(scroll);
              });
            });
          }
          return scroll;
        }];
      }
      var $animateMinErr = minErr('$animate');
      var ELEMENT_NODE = 1;
      var NG_ANIMATE_CLASSNAME = 'ng-animate';
      function mergeClasses(a, b) {
        if (!a && !b)
          return '';
        if (!a)
          return b;
        if (!b)
          return a;
        if (isArray(a))
          a = a.join(' ');
        if (isArray(b))
          b = b.join(' ');
        return a + ' ' + b;
      }
      function extractElementNode(element) {
        for (var i = 0; i < element.length; i++) {
          var elm = element[i];
          if (elm.nodeType === ELEMENT_NODE) {
            return elm;
          }
        }
      }
      function splitClasses(classes) {
        if (isString(classes)) {
          classes = classes.split(' ');
        }
        var obj = createMap();
        forEach(classes, function(klass) {
          if (klass.length) {
            obj[klass] = true;
          }
        });
        return obj;
      }
      function prepareAnimateOptions(options) {
        return isObject(options) ? options : {};
      }
      var $$CoreAnimateJsProvider = function() {
        this.$get = noop;
      };
      var $$CoreAnimateQueueProvider = function() {
        var postDigestQueue = new HashMap();
        var postDigestElements = [];
        this.$get = ['$$AnimateRunner', '$rootScope', function($$AnimateRunner, $rootScope) {
          return {
            enabled: noop,
            on: noop,
            off: noop,
            pin: noop,
            push: function(element, event, options, domOperation) {
              domOperation && domOperation();
              options = options || {};
              options.from && element.css(options.from);
              options.to && element.css(options.to);
              if (options.addClass || options.removeClass) {
                addRemoveClassesPostDigest(element, options.addClass, options.removeClass);
              }
              var runner = new $$AnimateRunner();
              runner.complete();
              return runner;
            }
          };
          function updateData(data, classes, value) {
            var changed = false;
            if (classes) {
              classes = isString(classes) ? classes.split(' ') : isArray(classes) ? classes : [];
              forEach(classes, function(className) {
                if (className) {
                  changed = true;
                  data[className] = value;
                }
              });
            }
            return changed;
          }
          function handleCSSClassChanges() {
            forEach(postDigestElements, function(element) {
              var data = postDigestQueue.get(element);
              if (data) {
                var existing = splitClasses(element.attr('class'));
                var toAdd = '';
                var toRemove = '';
                forEach(data, function(status, className) {
                  var hasClass = !!existing[className];
                  if (status !== hasClass) {
                    if (status) {
                      toAdd += (toAdd.length ? ' ' : '') + className;
                    } else {
                      toRemove += (toRemove.length ? ' ' : '') + className;
                    }
                  }
                });
                forEach(element, function(elm) {
                  toAdd && jqLiteAddClass(elm, toAdd);
                  toRemove && jqLiteRemoveClass(elm, toRemove);
                });
                postDigestQueue.remove(element);
              }
            });
            postDigestElements.length = 0;
          }
          function addRemoveClassesPostDigest(element, add, remove) {
            var data = postDigestQueue.get(element) || {};
            var classesAdded = updateData(data, add, true);
            var classesRemoved = updateData(data, remove, false);
            if (classesAdded || classesRemoved) {
              postDigestQueue.put(element, data);
              postDigestElements.push(element);
              if (postDigestElements.length === 1) {
                $rootScope.$$postDigest(handleCSSClassChanges);
              }
            }
          }
        }];
      };
      var $AnimateProvider = ['$provide', function($provide) {
        var provider = this;
        this.$$registeredAnimations = Object.create(null);
        this.register = function(name, factory) {
          if (name && name.charAt(0) !== '.') {
            throw $animateMinErr('notcsel', "Expecting class selector starting with '.' got '{0}'.", name);
          }
          var key = name + '-animation';
          provider.$$registeredAnimations[name.substr(1)] = key;
          $provide.factory(key, factory);
        };
        this.classNameFilter = function(expression) {
          if (arguments.length === 1) {
            this.$$classNameFilter = (expression instanceof RegExp) ? expression : null;
            if (this.$$classNameFilter) {
              var reservedRegex = new RegExp("(\\s+|\\/)" + NG_ANIMATE_CLASSNAME + "(\\s+|\\/)");
              if (reservedRegex.test(this.$$classNameFilter.toString())) {
                throw $animateMinErr('nongcls', '$animateProvider.classNameFilter(regex) prohibits accepting a regex value which matches/contains the "{0}" CSS class.', NG_ANIMATE_CLASSNAME);
              }
            }
          }
          return this.$$classNameFilter;
        };
        this.$get = ['$$animateQueue', function($$animateQueue) {
          function domInsert(element, parentElement, afterElement) {
            if (afterElement) {
              var afterNode = extractElementNode(afterElement);
              if (afterNode && !afterNode.parentNode && !afterNode.previousElementSibling) {
                afterElement = null;
              }
            }
            afterElement ? afterElement.after(element) : parentElement.prepend(element);
          }
          return {
            on: $$animateQueue.on,
            off: $$animateQueue.off,
            pin: $$animateQueue.pin,
            enabled: $$animateQueue.enabled,
            cancel: function(runner) {
              runner.end && runner.end();
            },
            enter: function(element, parent, after, options) {
              parent = parent && jqLite(parent);
              after = after && jqLite(after);
              parent = parent || after.parent();
              domInsert(element, parent, after);
              return $$animateQueue.push(element, 'enter', prepareAnimateOptions(options));
            },
            move: function(element, parent, after, options) {
              parent = parent && jqLite(parent);
              after = after && jqLite(after);
              parent = parent || after.parent();
              domInsert(element, parent, after);
              return $$animateQueue.push(element, 'move', prepareAnimateOptions(options));
            },
            leave: function(element, options) {
              return $$animateQueue.push(element, 'leave', prepareAnimateOptions(options), function() {
                element.remove();
              });
            },
            addClass: function(element, className, options) {
              options = prepareAnimateOptions(options);
              options.addClass = mergeClasses(options.addclass, className);
              return $$animateQueue.push(element, 'addClass', options);
            },
            removeClass: function(element, className, options) {
              options = prepareAnimateOptions(options);
              options.removeClass = mergeClasses(options.removeClass, className);
              return $$animateQueue.push(element, 'removeClass', options);
            },
            setClass: function(element, add, remove, options) {
              options = prepareAnimateOptions(options);
              options.addClass = mergeClasses(options.addClass, add);
              options.removeClass = mergeClasses(options.removeClass, remove);
              return $$animateQueue.push(element, 'setClass', options);
            },
            animate: function(element, from, to, className, options) {
              options = prepareAnimateOptions(options);
              options.from = options.from ? extend(options.from, from) : from;
              options.to = options.to ? extend(options.to, to) : to;
              className = className || 'ng-inline-animate';
              options.tempClasses = mergeClasses(options.tempClasses, className);
              return $$animateQueue.push(element, 'animate', options);
            }
          };
        }];
      }];
      var $$AnimateAsyncRunFactoryProvider = function() {
        this.$get = ['$$rAF', function($$rAF) {
          var waitQueue = [];
          function waitForTick(fn) {
            waitQueue.push(fn);
            if (waitQueue.length > 1)
              return;
            $$rAF(function() {
              for (var i = 0; i < waitQueue.length; i++) {
                waitQueue[i]();
              }
              waitQueue = [];
            });
          }
          return function() {
            var passed = false;
            waitForTick(function() {
              passed = true;
            });
            return function(callback) {
              passed ? callback() : waitForTick(callback);
            };
          };
        }];
      };
      var $$AnimateRunnerFactoryProvider = function() {
        this.$get = ['$q', '$sniffer', '$$animateAsyncRun', '$document', '$timeout', function($q, $sniffer, $$animateAsyncRun, $document, $timeout) {
          var INITIAL_STATE = 0;
          var DONE_PENDING_STATE = 1;
          var DONE_COMPLETE_STATE = 2;
          AnimateRunner.chain = function(chain, callback) {
            var index = 0;
            next();
            function next() {
              if (index === chain.length) {
                callback(true);
                return;
              }
              chain[index](function(response) {
                if (response === false) {
                  callback(false);
                  return;
                }
                index++;
                next();
              });
            }
          };
          AnimateRunner.all = function(runners, callback) {
            var count = 0;
            var status = true;
            forEach(runners, function(runner) {
              runner.done(onProgress);
            });
            function onProgress(response) {
              status = status && response;
              if (++count === runners.length) {
                callback(status);
              }
            }
          };
          function AnimateRunner(host) {
            this.setHost(host);
            var rafTick = $$animateAsyncRun();
            var timeoutTick = function(fn) {
              $timeout(fn, 0, false);
            };
            this._doneCallbacks = [];
            this._tick = function(fn) {
              var doc = $document[0];
              if (doc && doc.hidden) {
                timeoutTick(fn);
              } else {
                rafTick(fn);
              }
            };
            this._state = 0;
          }
          AnimateRunner.prototype = {
            setHost: function(host) {
              this.host = host || {};
            },
            done: function(fn) {
              if (this._state === DONE_COMPLETE_STATE) {
                fn();
              } else {
                this._doneCallbacks.push(fn);
              }
            },
            progress: noop,
            getPromise: function() {
              if (!this.promise) {
                var self = this;
                this.promise = $q(function(resolve, reject) {
                  self.done(function(status) {
                    status === false ? reject() : resolve();
                  });
                });
              }
              return this.promise;
            },
            then: function(resolveHandler, rejectHandler) {
              return this.getPromise().then(resolveHandler, rejectHandler);
            },
            'catch': function(handler) {
              return this.getPromise()['catch'](handler);
            },
            'finally': function(handler) {
              return this.getPromise()['finally'](handler);
            },
            pause: function() {
              if (this.host.pause) {
                this.host.pause();
              }
            },
            resume: function() {
              if (this.host.resume) {
                this.host.resume();
              }
            },
            end: function() {
              if (this.host.end) {
                this.host.end();
              }
              this._resolve(true);
            },
            cancel: function() {
              if (this.host.cancel) {
                this.host.cancel();
              }
              this._resolve(false);
            },
            complete: function(response) {
              var self = this;
              if (self._state === INITIAL_STATE) {
                self._state = DONE_PENDING_STATE;
                self._tick(function() {
                  self._resolve(response);
                });
              }
            },
            _resolve: function(response) {
              if (this._state !== DONE_COMPLETE_STATE) {
                forEach(this._doneCallbacks, function(fn) {
                  fn(response);
                });
                this._doneCallbacks.length = 0;
                this._state = DONE_COMPLETE_STATE;
              }
            }
          };
          return AnimateRunner;
        }];
      };
      var $CoreAnimateCssProvider = function() {
        this.$get = ['$$rAF', '$q', '$$AnimateRunner', function($$rAF, $q, $$AnimateRunner) {
          return function(element, initialOptions) {
            var options = initialOptions || {};
            if (!options.$$prepared) {
              options = copy(options);
            }
            if (options.cleanupStyles) {
              options.from = options.to = null;
            }
            if (options.from) {
              element.css(options.from);
              options.from = null;
            }
            var closed,
                runner = new $$AnimateRunner();
            return {
              start: run,
              end: run
            };
            function run() {
              $$rAF(function() {
                applyAnimationContents();
                if (!closed) {
                  runner.complete();
                }
                closed = true;
              });
              return runner;
            }
            function applyAnimationContents() {
              if (options.addClass) {
                element.addClass(options.addClass);
                options.addClass = null;
              }
              if (options.removeClass) {
                element.removeClass(options.removeClass);
                options.removeClass = null;
              }
              if (options.to) {
                element.css(options.to);
                options.to = null;
              }
            }
          };
        }];
      };
      function Browser(window, document, $log, $sniffer) {
        var self = this,
            location = window.location,
            history = window.history,
            setTimeout = window.setTimeout,
            clearTimeout = window.clearTimeout,
            pendingDeferIds = {};
        self.isMock = false;
        var outstandingRequestCount = 0;
        var outstandingRequestCallbacks = [];
        self.$$completeOutstandingRequest = completeOutstandingRequest;
        self.$$incOutstandingRequestCount = function() {
          outstandingRequestCount++;
        };
        function completeOutstandingRequest(fn) {
          try {
            fn.apply(null, sliceArgs(arguments, 1));
          } finally {
            outstandingRequestCount--;
            if (outstandingRequestCount === 0) {
              while (outstandingRequestCallbacks.length) {
                try {
                  outstandingRequestCallbacks.pop()();
                } catch (e) {
                  $log.error(e);
                }
              }
            }
          }
        }
        function getHash(url) {
          var index = url.indexOf('#');
          return index === -1 ? '' : url.substr(index);
        }
        self.notifyWhenNoOutstandingRequests = function(callback) {
          if (outstandingRequestCount === 0) {
            callback();
          } else {
            outstandingRequestCallbacks.push(callback);
          }
        };
        var cachedState,
            lastHistoryState,
            lastBrowserUrl = location.href,
            baseElement = document.find('base'),
            pendingLocation = null,
            getCurrentState = !$sniffer.history ? noop : function getCurrentState() {
              try {
                return history.state;
              } catch (e) {}
            };
        cacheState();
        lastHistoryState = cachedState;
        self.url = function(url, replace, state) {
          if (isUndefined(state)) {
            state = null;
          }
          if (location !== window.location)
            location = window.location;
          if (history !== window.history)
            history = window.history;
          if (url) {
            var sameState = lastHistoryState === state;
            if (lastBrowserUrl === url && (!$sniffer.history || sameState)) {
              return self;
            }
            var sameBase = lastBrowserUrl && stripHash(lastBrowserUrl) === stripHash(url);
            lastBrowserUrl = url;
            lastHistoryState = state;
            if ($sniffer.history && (!sameBase || !sameState)) {
              history[replace ? 'replaceState' : 'pushState'](state, '', url);
              cacheState();
              lastHistoryState = cachedState;
            } else {
              if (!sameBase) {
                pendingLocation = url;
              }
              if (replace) {
                location.replace(url);
              } else if (!sameBase) {
                location.href = url;
              } else {
                location.hash = getHash(url);
              }
              if (location.href !== url) {
                pendingLocation = url;
              }
            }
            if (pendingLocation) {
              pendingLocation = url;
            }
            return self;
          } else {
            return pendingLocation || location.href.replace(/%27/g, "'");
          }
        };
        self.state = function() {
          return cachedState;
        };
        var urlChangeListeners = [],
            urlChangeInit = false;
        function cacheStateAndFireUrlChange() {
          pendingLocation = null;
          cacheState();
          fireUrlChange();
        }
        var lastCachedState = null;
        function cacheState() {
          cachedState = getCurrentState();
          cachedState = isUndefined(cachedState) ? null : cachedState;
          if (equals(cachedState, lastCachedState)) {
            cachedState = lastCachedState;
          }
          lastCachedState = cachedState;
        }
        function fireUrlChange() {
          if (lastBrowserUrl === self.url() && lastHistoryState === cachedState) {
            return;
          }
          lastBrowserUrl = self.url();
          lastHistoryState = cachedState;
          forEach(urlChangeListeners, function(listener) {
            listener(self.url(), cachedState);
          });
        }
        self.onUrlChange = function(callback) {
          if (!urlChangeInit) {
            if ($sniffer.history)
              jqLite(window).on('popstate', cacheStateAndFireUrlChange);
            jqLite(window).on('hashchange', cacheStateAndFireUrlChange);
            urlChangeInit = true;
          }
          urlChangeListeners.push(callback);
          return callback;
        };
        self.$$applicationDestroyed = function() {
          jqLite(window).off('hashchange popstate', cacheStateAndFireUrlChange);
        };
        self.$$checkUrlChange = fireUrlChange;
        self.baseHref = function() {
          var href = baseElement.attr('href');
          return href ? href.replace(/^(https?\:)?\/\/[^\/]*/, '') : '';
        };
        self.defer = function(fn, delay) {
          var timeoutId;
          outstandingRequestCount++;
          timeoutId = setTimeout(function() {
            delete pendingDeferIds[timeoutId];
            completeOutstandingRequest(fn);
          }, delay || 0);
          pendingDeferIds[timeoutId] = true;
          return timeoutId;
        };
        self.defer.cancel = function(deferId) {
          if (pendingDeferIds[deferId]) {
            delete pendingDeferIds[deferId];
            clearTimeout(deferId);
            completeOutstandingRequest(noop);
            return true;
          }
          return false;
        };
      }
      function $BrowserProvider() {
        this.$get = ['$window', '$log', '$sniffer', '$document', function($window, $log, $sniffer, $document) {
          return new Browser($window, $document, $log, $sniffer);
        }];
      }
      function $CacheFactoryProvider() {
        this.$get = function() {
          var caches = {};
          function cacheFactory(cacheId, options) {
            if (cacheId in caches) {
              throw minErr('$cacheFactory')('iid', "CacheId '{0}' is already taken!", cacheId);
            }
            var size = 0,
                stats = extend({}, options, {id: cacheId}),
                data = createMap(),
                capacity = (options && options.capacity) || Number.MAX_VALUE,
                lruHash = createMap(),
                freshEnd = null,
                staleEnd = null;
            return caches[cacheId] = {
              put: function(key, value) {
                if (isUndefined(value))
                  return;
                if (capacity < Number.MAX_VALUE) {
                  var lruEntry = lruHash[key] || (lruHash[key] = {key: key});
                  refresh(lruEntry);
                }
                if (!(key in data))
                  size++;
                data[key] = value;
                if (size > capacity) {
                  this.remove(staleEnd.key);
                }
                return value;
              },
              get: function(key) {
                if (capacity < Number.MAX_VALUE) {
                  var lruEntry = lruHash[key];
                  if (!lruEntry)
                    return;
                  refresh(lruEntry);
                }
                return data[key];
              },
              remove: function(key) {
                if (capacity < Number.MAX_VALUE) {
                  var lruEntry = lruHash[key];
                  if (!lruEntry)
                    return;
                  if (lruEntry == freshEnd)
                    freshEnd = lruEntry.p;
                  if (lruEntry == staleEnd)
                    staleEnd = lruEntry.n;
                  link(lruEntry.n, lruEntry.p);
                  delete lruHash[key];
                }
                if (!(key in data))
                  return;
                delete data[key];
                size--;
              },
              removeAll: function() {
                data = createMap();
                size = 0;
                lruHash = createMap();
                freshEnd = staleEnd = null;
              },
              destroy: function() {
                data = null;
                stats = null;
                lruHash = null;
                delete caches[cacheId];
              },
              info: function() {
                return extend({}, stats, {size: size});
              }
            };
            function refresh(entry) {
              if (entry != freshEnd) {
                if (!staleEnd) {
                  staleEnd = entry;
                } else if (staleEnd == entry) {
                  staleEnd = entry.n;
                }
                link(entry.n, entry.p);
                link(entry, freshEnd);
                freshEnd = entry;
                freshEnd.n = null;
              }
            }
            function link(nextEntry, prevEntry) {
              if (nextEntry != prevEntry) {
                if (nextEntry)
                  nextEntry.p = prevEntry;
                if (prevEntry)
                  prevEntry.n = nextEntry;
              }
            }
          }
          cacheFactory.info = function() {
            var info = {};
            forEach(caches, function(cache, cacheId) {
              info[cacheId] = cache.info();
            });
            return info;
          };
          cacheFactory.get = function(cacheId) {
            return caches[cacheId];
          };
          return cacheFactory;
        };
      }
      function $TemplateCacheProvider() {
        this.$get = ['$cacheFactory', function($cacheFactory) {
          return $cacheFactory('templates');
        }];
      }
      var $compileMinErr = minErr('$compile');
      function UNINITIALIZED_VALUE() {}
      var _UNINITIALIZED_VALUE = new UNINITIALIZED_VALUE();
      $CompileProvider.$inject = ['$provide', '$$sanitizeUriProvider'];
      function $CompileProvider($provide, $$sanitizeUriProvider) {
        var hasDirectives = {},
            Suffix = 'Directive',
            COMMENT_DIRECTIVE_REGEXP = /^\s*directive\:\s*([\w\-]+)\s+(.*)$/,
            CLASS_DIRECTIVE_REGEXP = /(([\w\-]+)(?:\:([^;]+))?;?)/,
            ALL_OR_NOTHING_ATTRS = makeMap('ngSrc,ngSrcset,src,srcset'),
            REQUIRE_PREFIX_REGEXP = /^(?:(\^\^?)?(\?)?(\^\^?)?)?/;
        var EVENT_HANDLER_ATTR_REGEXP = /^(on[a-z]+|formaction)$/;
        var bindingCache = createMap();
        function parseIsolateBindings(scope, directiveName, isController) {
          var LOCAL_REGEXP = /^\s*([@&<]|=(\*?))(\??)\s*(\w*)\s*$/;
          var bindings = createMap();
          forEach(scope, function(definition, scopeName) {
            if (definition in bindingCache) {
              bindings[scopeName] = bindingCache[definition];
              return;
            }
            var match = definition.match(LOCAL_REGEXP);
            if (!match) {
              throw $compileMinErr('iscp', "Invalid {3} for directive '{0}'." + " Definition: {... {1}: '{2}' ...}", directiveName, scopeName, definition, (isController ? "controller bindings definition" : "isolate scope definition"));
            }
            bindings[scopeName] = {
              mode: match[1][0],
              collection: match[2] === '*',
              optional: match[3] === '?',
              attrName: match[4] || scopeName
            };
            if (match[4]) {
              bindingCache[definition] = bindings[scopeName];
            }
          });
          return bindings;
        }
        function parseDirectiveBindings(directive, directiveName) {
          var bindings = {
            isolateScope: null,
            bindToController: null
          };
          if (isObject(directive.scope)) {
            if (directive.bindToController === true) {
              bindings.bindToController = parseIsolateBindings(directive.scope, directiveName, true);
              bindings.isolateScope = {};
            } else {
              bindings.isolateScope = parseIsolateBindings(directive.scope, directiveName, false);
            }
          }
          if (isObject(directive.bindToController)) {
            bindings.bindToController = parseIsolateBindings(directive.bindToController, directiveName, true);
          }
          if (isObject(bindings.bindToController)) {
            var controller = directive.controller;
            var controllerAs = directive.controllerAs;
            if (!controller) {
              throw $compileMinErr('noctrl', "Cannot bind to controller without directive '{0}'s controller.", directiveName);
            } else if (!identifierForController(controller, controllerAs)) {
              throw $compileMinErr('noident', "Cannot bind to controller without identifier for directive '{0}'.", directiveName);
            }
          }
          return bindings;
        }
        function assertValidDirectiveName(name) {
          var letter = name.charAt(0);
          if (!letter || letter !== lowercase(letter)) {
            throw $compileMinErr('baddir', "Directive/Component name '{0}' is invalid. The first character must be a lowercase letter", name);
          }
          if (name !== name.trim()) {
            throw $compileMinErr('baddir', "Directive/Component name '{0}' is invalid. The name should not contain leading or trailing whitespaces", name);
          }
        }
        function getDirectiveRequire(directive) {
          var require = directive.require || (directive.controller && directive.name);
          if (!isArray(require) && isObject(require)) {
            forEach(require, function(value, key) {
              var match = value.match(REQUIRE_PREFIX_REGEXP);
              var name = value.substring(match[0].length);
              if (!name)
                require[key] = match[0] + key;
            });
          }
          return require;
        }
        this.directive = function registerDirective(name, directiveFactory) {
          assertNotHasOwnProperty(name, 'directive');
          if (isString(name)) {
            assertValidDirectiveName(name);
            assertArg(directiveFactory, 'directiveFactory');
            if (!hasDirectives.hasOwnProperty(name)) {
              hasDirectives[name] = [];
              $provide.factory(name + Suffix, ['$injector', '$exceptionHandler', function($injector, $exceptionHandler) {
                var directives = [];
                forEach(hasDirectives[name], function(directiveFactory, index) {
                  try {
                    var directive = $injector.invoke(directiveFactory);
                    if (isFunction(directive)) {
                      directive = {compile: valueFn(directive)};
                    } else if (!directive.compile && directive.link) {
                      directive.compile = valueFn(directive.link);
                    }
                    directive.priority = directive.priority || 0;
                    directive.index = index;
                    directive.name = directive.name || name;
                    directive.require = getDirectiveRequire(directive);
                    directive.restrict = directive.restrict || 'EA';
                    directive.$$moduleName = directiveFactory.$$moduleName;
                    directives.push(directive);
                  } catch (e) {
                    $exceptionHandler(e);
                  }
                });
                return directives;
              }]);
            }
            hasDirectives[name].push(directiveFactory);
          } else {
            forEach(name, reverseParams(registerDirective));
          }
          return this;
        };
        this.component = function registerComponent(name, options) {
          var controller = options.controller || function() {};
          function factory($injector) {
            function makeInjectable(fn) {
              if (isFunction(fn) || isArray(fn)) {
                return function(tElement, tAttrs) {
                  return $injector.invoke(fn, this, {
                    $element: tElement,
                    $attrs: tAttrs
                  });
                };
              } else {
                return fn;
              }
            }
            var template = (!options.template && !options.templateUrl ? '' : options.template);
            var ddo = {
              controller: controller,
              controllerAs: identifierForController(options.controller) || options.controllerAs || '$ctrl',
              template: makeInjectable(template),
              templateUrl: makeInjectable(options.templateUrl),
              transclude: options.transclude,
              scope: {},
              bindToController: options.bindings || {},
              restrict: 'E',
              require: options.require
            };
            forEach(options, function(val, key) {
              if (key.charAt(0) === '$')
                ddo[key] = val;
            });
            return ddo;
          }
          forEach(options, function(val, key) {
            if (key.charAt(0) === '$') {
              factory[key] = val;
              if (isFunction(controller))
                controller[key] = val;
            }
          });
          factory.$inject = ['$injector'];
          return this.directive(name, factory);
        };
        this.aHrefSanitizationWhitelist = function(regexp) {
          if (isDefined(regexp)) {
            $$sanitizeUriProvider.aHrefSanitizationWhitelist(regexp);
            return this;
          } else {
            return $$sanitizeUriProvider.aHrefSanitizationWhitelist();
          }
        };
        this.imgSrcSanitizationWhitelist = function(regexp) {
          if (isDefined(regexp)) {
            $$sanitizeUriProvider.imgSrcSanitizationWhitelist(regexp);
            return this;
          } else {
            return $$sanitizeUriProvider.imgSrcSanitizationWhitelist();
          }
        };
        var debugInfoEnabled = true;
        this.debugInfoEnabled = function(enabled) {
          if (isDefined(enabled)) {
            debugInfoEnabled = enabled;
            return this;
          }
          return debugInfoEnabled;
        };
        var TTL = 10;
        this.onChangesTtl = function(value) {
          if (arguments.length) {
            TTL = value;
            return this;
          }
          return TTL;
        };
        this.$get = ['$injector', '$interpolate', '$exceptionHandler', '$templateRequest', '$parse', '$controller', '$rootScope', '$sce', '$animate', '$$sanitizeUri', function($injector, $interpolate, $exceptionHandler, $templateRequest, $parse, $controller, $rootScope, $sce, $animate, $$sanitizeUri) {
          var SIMPLE_ATTR_NAME = /^\w/;
          var specialAttrHolder = window.document.createElement('div');
          var onChangesTtl = TTL;
          var onChangesQueue;
          function flushOnChangesQueue() {
            try {
              if (!(--onChangesTtl)) {
                onChangesQueue = undefined;
                throw $compileMinErr('infchng', '{0} $onChanges() iterations reached. Aborting!\n', TTL);
              }
              $rootScope.$apply(function() {
                var errors = [];
                for (var i = 0,
                    ii = onChangesQueue.length; i < ii; ++i) {
                  try {
                    onChangesQueue[i]();
                  } catch (e) {
                    errors.push(e);
                  }
                }
                onChangesQueue = undefined;
                if (errors.length) {
                  throw errors;
                }
              });
            } finally {
              onChangesTtl++;
            }
          }
          function Attributes(element, attributesToCopy) {
            if (attributesToCopy) {
              var keys = Object.keys(attributesToCopy);
              var i,
                  l,
                  key;
              for (i = 0, l = keys.length; i < l; i++) {
                key = keys[i];
                this[key] = attributesToCopy[key];
              }
            } else {
              this.$attr = {};
            }
            this.$$element = element;
          }
          Attributes.prototype = {
            $normalize: directiveNormalize,
            $addClass: function(classVal) {
              if (classVal && classVal.length > 0) {
                $animate.addClass(this.$$element, classVal);
              }
            },
            $removeClass: function(classVal) {
              if (classVal && classVal.length > 0) {
                $animate.removeClass(this.$$element, classVal);
              }
            },
            $updateClass: function(newClasses, oldClasses) {
              var toAdd = tokenDifference(newClasses, oldClasses);
              if (toAdd && toAdd.length) {
                $animate.addClass(this.$$element, toAdd);
              }
              var toRemove = tokenDifference(oldClasses, newClasses);
              if (toRemove && toRemove.length) {
                $animate.removeClass(this.$$element, toRemove);
              }
            },
            $set: function(key, value, writeAttr, attrName) {
              var node = this.$$element[0],
                  booleanKey = getBooleanAttrName(node, key),
                  aliasedKey = getAliasedAttrName(key),
                  observer = key,
                  nodeName;
              if (booleanKey) {
                this.$$element.prop(key, value);
                attrName = booleanKey;
              } else if (aliasedKey) {
                this[aliasedKey] = value;
                observer = aliasedKey;
              }
              this[key] = value;
              if (attrName) {
                this.$attr[key] = attrName;
              } else {
                attrName = this.$attr[key];
                if (!attrName) {
                  this.$attr[key] = attrName = snake_case(key, '-');
                }
              }
              nodeName = nodeName_(this.$$element);
              if ((nodeName === 'a' && (key === 'href' || key === 'xlinkHref')) || (nodeName === 'img' && key === 'src')) {
                this[key] = value = $$sanitizeUri(value, key === 'src');
              } else if (nodeName === 'img' && key === 'srcset' && isDefined(value)) {
                var result = "";
                var trimmedSrcset = trim(value);
                var srcPattern = /(\s+\d+x\s*,|\s+\d+w\s*,|\s+,|,\s+)/;
                var pattern = /\s/.test(trimmedSrcset) ? srcPattern : /(,)/;
                var rawUris = trimmedSrcset.split(pattern);
                var nbrUrisWith2parts = Math.floor(rawUris.length / 2);
                for (var i = 0; i < nbrUrisWith2parts; i++) {
                  var innerIdx = i * 2;
                  result += $$sanitizeUri(trim(rawUris[innerIdx]), true);
                  result += (" " + trim(rawUris[innerIdx + 1]));
                }
                var lastTuple = trim(rawUris[i * 2]).split(/\s/);
                result += $$sanitizeUri(trim(lastTuple[0]), true);
                if (lastTuple.length === 2) {
                  result += (" " + trim(lastTuple[1]));
                }
                this[key] = value = result;
              }
              if (writeAttr !== false) {
                if (value === null || isUndefined(value)) {
                  this.$$element.removeAttr(attrName);
                } else {
                  if (SIMPLE_ATTR_NAME.test(attrName)) {
                    this.$$element.attr(attrName, value);
                  } else {
                    setSpecialAttr(this.$$element[0], attrName, value);
                  }
                }
              }
              var $$observers = this.$$observers;
              $$observers && forEach($$observers[observer], function(fn) {
                try {
                  fn(value);
                } catch (e) {
                  $exceptionHandler(e);
                }
              });
            },
            $observe: function(key, fn) {
              var attrs = this,
                  $$observers = (attrs.$$observers || (attrs.$$observers = createMap())),
                  listeners = ($$observers[key] || ($$observers[key] = []));
              listeners.push(fn);
              $rootScope.$evalAsync(function() {
                if (!listeners.$$inter && attrs.hasOwnProperty(key) && !isUndefined(attrs[key])) {
                  fn(attrs[key]);
                }
              });
              return function() {
                arrayRemove(listeners, fn);
              };
            }
          };
          function setSpecialAttr(element, attrName, value) {
            specialAttrHolder.innerHTML = "<span " + attrName + ">";
            var attributes = specialAttrHolder.firstChild.attributes;
            var attribute = attributes[0];
            attributes.removeNamedItem(attribute.name);
            attribute.value = value;
            element.attributes.setNamedItem(attribute);
          }
          function safeAddClass($element, className) {
            try {
              $element.addClass(className);
            } catch (e) {}
          }
          var startSymbol = $interpolate.startSymbol(),
              endSymbol = $interpolate.endSymbol(),
              denormalizeTemplate = (startSymbol == '{{' && endSymbol == '}}') ? identity : function denormalizeTemplate(template) {
                return template.replace(/\{\{/g, startSymbol).replace(/}}/g, endSymbol);
              },
              NG_ATTR_BINDING = /^ngAttr[A-Z]/;
          var MULTI_ELEMENT_DIR_RE = /^(.+)Start$/;
          compile.$$addBindingInfo = debugInfoEnabled ? function $$addBindingInfo($element, binding) {
            var bindings = $element.data('$binding') || [];
            if (isArray(binding)) {
              bindings = bindings.concat(binding);
            } else {
              bindings.push(binding);
            }
            $element.data('$binding', bindings);
          } : noop;
          compile.$$addBindingClass = debugInfoEnabled ? function $$addBindingClass($element) {
            safeAddClass($element, 'ng-binding');
          } : noop;
          compile.$$addScopeInfo = debugInfoEnabled ? function $$addScopeInfo($element, scope, isolated, noTemplate) {
            var dataName = isolated ? (noTemplate ? '$isolateScopeNoTemplate' : '$isolateScope') : '$scope';
            $element.data(dataName, scope);
          } : noop;
          compile.$$addScopeClass = debugInfoEnabled ? function $$addScopeClass($element, isolated) {
            safeAddClass($element, isolated ? 'ng-isolate-scope' : 'ng-scope');
          } : noop;
          compile.$$createComment = function(directiveName, comment) {
            var content = '';
            if (debugInfoEnabled) {
              content = ' ' + (directiveName || '') + ': ';
              if (comment)
                content += comment + ' ';
            }
            return window.document.createComment(content);
          };
          return compile;
          function compile($compileNodes, transcludeFn, maxPriority, ignoreDirective, previousCompileContext) {
            if (!($compileNodes instanceof jqLite)) {
              $compileNodes = jqLite($compileNodes);
            }
            var NOT_EMPTY = /\S+/;
            for (var i = 0,
                len = $compileNodes.length; i < len; i++) {
              var domNode = $compileNodes[i];
              if (domNode.nodeType === NODE_TYPE_TEXT && domNode.nodeValue.match(NOT_EMPTY)) {
                jqLiteWrapNode(domNode, $compileNodes[i] = window.document.createElement('span'));
              }
            }
            var compositeLinkFn = compileNodes($compileNodes, transcludeFn, $compileNodes, maxPriority, ignoreDirective, previousCompileContext);
            compile.$$addScopeClass($compileNodes);
            var namespace = null;
            return function publicLinkFn(scope, cloneConnectFn, options) {
              assertArg(scope, 'scope');
              if (previousCompileContext && previousCompileContext.needsNewScope) {
                scope = scope.$parent.$new();
              }
              options = options || {};
              var parentBoundTranscludeFn = options.parentBoundTranscludeFn,
                  transcludeControllers = options.transcludeControllers,
                  futureParentElement = options.futureParentElement;
              if (parentBoundTranscludeFn && parentBoundTranscludeFn.$$boundTransclude) {
                parentBoundTranscludeFn = parentBoundTranscludeFn.$$boundTransclude;
              }
              if (!namespace) {
                namespace = detectNamespaceForChildElements(futureParentElement);
              }
              var $linkNode;
              if (namespace !== 'html') {
                $linkNode = jqLite(wrapTemplate(namespace, jqLite('<div>').append($compileNodes).html()));
              } else if (cloneConnectFn) {
                $linkNode = JQLitePrototype.clone.call($compileNodes);
              } else {
                $linkNode = $compileNodes;
              }
              if (transcludeControllers) {
                for (var controllerName in transcludeControllers) {
                  $linkNode.data('$' + controllerName + 'Controller', transcludeControllers[controllerName].instance);
                }
              }
              compile.$$addScopeInfo($linkNode, scope);
              if (cloneConnectFn)
                cloneConnectFn($linkNode, scope);
              if (compositeLinkFn)
                compositeLinkFn(scope, $linkNode, $linkNode, parentBoundTranscludeFn);
              return $linkNode;
            };
          }
          function detectNamespaceForChildElements(parentElement) {
            var node = parentElement && parentElement[0];
            if (!node) {
              return 'html';
            } else {
              return nodeName_(node) !== 'foreignobject' && toString.call(node).match(/SVG/) ? 'svg' : 'html';
            }
          }
          function compileNodes(nodeList, transcludeFn, $rootElement, maxPriority, ignoreDirective, previousCompileContext) {
            var linkFns = [],
                attrs,
                directives,
                nodeLinkFn,
                childNodes,
                childLinkFn,
                linkFnFound,
                nodeLinkFnFound;
            for (var i = 0; i < nodeList.length; i++) {
              attrs = new Attributes();
              directives = collectDirectives(nodeList[i], [], attrs, i === 0 ? maxPriority : undefined, ignoreDirective);
              nodeLinkFn = (directives.length) ? applyDirectivesToNode(directives, nodeList[i], attrs, transcludeFn, $rootElement, null, [], [], previousCompileContext) : null;
              if (nodeLinkFn && nodeLinkFn.scope) {
                compile.$$addScopeClass(attrs.$$element);
              }
              childLinkFn = (nodeLinkFn && nodeLinkFn.terminal || !(childNodes = nodeList[i].childNodes) || !childNodes.length) ? null : compileNodes(childNodes, nodeLinkFn ? ((nodeLinkFn.transcludeOnThisElement || !nodeLinkFn.templateOnThisElement) && nodeLinkFn.transclude) : transcludeFn);
              if (nodeLinkFn || childLinkFn) {
                linkFns.push(i, nodeLinkFn, childLinkFn);
                linkFnFound = true;
                nodeLinkFnFound = nodeLinkFnFound || nodeLinkFn;
              }
              previousCompileContext = null;
            }
            return linkFnFound ? compositeLinkFn : null;
            function compositeLinkFn(scope, nodeList, $rootElement, parentBoundTranscludeFn) {
              var nodeLinkFn,
                  childLinkFn,
                  node,
                  childScope,
                  i,
                  ii,
                  idx,
                  childBoundTranscludeFn;
              var stableNodeList;
              if (nodeLinkFnFound) {
                var nodeListLength = nodeList.length;
                stableNodeList = new Array(nodeListLength);
                for (i = 0; i < linkFns.length; i += 3) {
                  idx = linkFns[i];
                  stableNodeList[idx] = nodeList[idx];
                }
              } else {
                stableNodeList = nodeList;
              }
              for (i = 0, ii = linkFns.length; i < ii; ) {
                node = stableNodeList[linkFns[i++]];
                nodeLinkFn = linkFns[i++];
                childLinkFn = linkFns[i++];
                if (nodeLinkFn) {
                  if (nodeLinkFn.scope) {
                    childScope = scope.$new();
                    compile.$$addScopeInfo(jqLite(node), childScope);
                  } else {
                    childScope = scope;
                  }
                  if (nodeLinkFn.transcludeOnThisElement) {
                    childBoundTranscludeFn = createBoundTranscludeFn(scope, nodeLinkFn.transclude, parentBoundTranscludeFn);
                  } else if (!nodeLinkFn.templateOnThisElement && parentBoundTranscludeFn) {
                    childBoundTranscludeFn = parentBoundTranscludeFn;
                  } else if (!parentBoundTranscludeFn && transcludeFn) {
                    childBoundTranscludeFn = createBoundTranscludeFn(scope, transcludeFn);
                  } else {
                    childBoundTranscludeFn = null;
                  }
                  nodeLinkFn(childLinkFn, childScope, node, $rootElement, childBoundTranscludeFn);
                } else if (childLinkFn) {
                  childLinkFn(scope, node.childNodes, undefined, parentBoundTranscludeFn);
                }
              }
            }
          }
          function createBoundTranscludeFn(scope, transcludeFn, previousBoundTranscludeFn) {
            function boundTranscludeFn(transcludedScope, cloneFn, controllers, futureParentElement, containingScope) {
              if (!transcludedScope) {
                transcludedScope = scope.$new(false, containingScope);
                transcludedScope.$$transcluded = true;
              }
              return transcludeFn(transcludedScope, cloneFn, {
                parentBoundTranscludeFn: previousBoundTranscludeFn,
                transcludeControllers: controllers,
                futureParentElement: futureParentElement
              });
            }
            var boundSlots = boundTranscludeFn.$$slots = createMap();
            for (var slotName in transcludeFn.$$slots) {
              if (transcludeFn.$$slots[slotName]) {
                boundSlots[slotName] = createBoundTranscludeFn(scope, transcludeFn.$$slots[slotName], previousBoundTranscludeFn);
              } else {
                boundSlots[slotName] = null;
              }
            }
            return boundTranscludeFn;
          }
          function collectDirectives(node, directives, attrs, maxPriority, ignoreDirective) {
            var nodeType = node.nodeType,
                attrsMap = attrs.$attr,
                match,
                className;
            switch (nodeType) {
              case NODE_TYPE_ELEMENT:
                addDirective(directives, directiveNormalize(nodeName_(node)), 'E', maxPriority, ignoreDirective);
                for (var attr,
                    name,
                    nName,
                    ngAttrName,
                    value,
                    isNgAttr,
                    nAttrs = node.attributes,
                    j = 0,
                    jj = nAttrs && nAttrs.length; j < jj; j++) {
                  var attrStartName = false;
                  var attrEndName = false;
                  attr = nAttrs[j];
                  name = attr.name;
                  value = trim(attr.value);
                  ngAttrName = directiveNormalize(name);
                  if (isNgAttr = NG_ATTR_BINDING.test(ngAttrName)) {
                    name = name.replace(PREFIX_REGEXP, '').substr(8).replace(/_(.)/g, function(match, letter) {
                      return letter.toUpperCase();
                    });
                  }
                  var multiElementMatch = ngAttrName.match(MULTI_ELEMENT_DIR_RE);
                  if (multiElementMatch && directiveIsMultiElement(multiElementMatch[1])) {
                    attrStartName = name;
                    attrEndName = name.substr(0, name.length - 5) + 'end';
                    name = name.substr(0, name.length - 6);
                  }
                  nName = directiveNormalize(name.toLowerCase());
                  attrsMap[nName] = name;
                  if (isNgAttr || !attrs.hasOwnProperty(nName)) {
                    attrs[nName] = value;
                    if (getBooleanAttrName(node, nName)) {
                      attrs[nName] = true;
                    }
                  }
                  addAttrInterpolateDirective(node, directives, value, nName, isNgAttr);
                  addDirective(directives, nName, 'A', maxPriority, ignoreDirective, attrStartName, attrEndName);
                }
                className = node.className;
                if (isObject(className)) {
                  className = className.animVal;
                }
                if (isString(className) && className !== '') {
                  while (match = CLASS_DIRECTIVE_REGEXP.exec(className)) {
                    nName = directiveNormalize(match[2]);
                    if (addDirective(directives, nName, 'C', maxPriority, ignoreDirective)) {
                      attrs[nName] = trim(match[3]);
                    }
                    className = className.substr(match.index + match[0].length);
                  }
                }
                break;
              case NODE_TYPE_TEXT:
                if (msie === 11) {
                  while (node.parentNode && node.nextSibling && node.nextSibling.nodeType === NODE_TYPE_TEXT) {
                    node.nodeValue = node.nodeValue + node.nextSibling.nodeValue;
                    node.parentNode.removeChild(node.nextSibling);
                  }
                }
                addTextInterpolateDirective(directives, node.nodeValue);
                break;
              case NODE_TYPE_COMMENT:
                try {
                  match = COMMENT_DIRECTIVE_REGEXP.exec(node.nodeValue);
                  if (match) {
                    nName = directiveNormalize(match[1]);
                    if (addDirective(directives, nName, 'M', maxPriority, ignoreDirective)) {
                      attrs[nName] = trim(match[2]);
                    }
                  }
                } catch (e) {}
                break;
            }
            directives.sort(byPriority);
            return directives;
          }
          function groupScan(node, attrStart, attrEnd) {
            var nodes = [];
            var depth = 0;
            if (attrStart && node.hasAttribute && node.hasAttribute(attrStart)) {
              do {
                if (!node) {
                  throw $compileMinErr('uterdir', "Unterminated attribute, found '{0}' but no matching '{1}' found.", attrStart, attrEnd);
                }
                if (node.nodeType == NODE_TYPE_ELEMENT) {
                  if (node.hasAttribute(attrStart))
                    depth++;
                  if (node.hasAttribute(attrEnd))
                    depth--;
                }
                nodes.push(node);
                node = node.nextSibling;
              } while (depth > 0);
            } else {
              nodes.push(node);
            }
            return jqLite(nodes);
          }
          function groupElementsLinkFnWrapper(linkFn, attrStart, attrEnd) {
            return function groupedElementsLink(scope, element, attrs, controllers, transcludeFn) {
              element = groupScan(element[0], attrStart, attrEnd);
              return linkFn(scope, element, attrs, controllers, transcludeFn);
            };
          }
          function compilationGenerator(eager, $compileNodes, transcludeFn, maxPriority, ignoreDirective, previousCompileContext) {
            var compiled;
            if (eager) {
              return compile($compileNodes, transcludeFn, maxPriority, ignoreDirective, previousCompileContext);
            }
            return function lazyCompilation() {
              if (!compiled) {
                compiled = compile($compileNodes, transcludeFn, maxPriority, ignoreDirective, previousCompileContext);
                $compileNodes = transcludeFn = previousCompileContext = null;
              }
              return compiled.apply(this, arguments);
            };
          }
          function applyDirectivesToNode(directives, compileNode, templateAttrs, transcludeFn, jqCollection, originalReplaceDirective, preLinkFns, postLinkFns, previousCompileContext) {
            previousCompileContext = previousCompileContext || {};
            var terminalPriority = -Number.MAX_VALUE,
                newScopeDirective = previousCompileContext.newScopeDirective,
                controllerDirectives = previousCompileContext.controllerDirectives,
                newIsolateScopeDirective = previousCompileContext.newIsolateScopeDirective,
                templateDirective = previousCompileContext.templateDirective,
                nonTlbTranscludeDirective = previousCompileContext.nonTlbTranscludeDirective,
                hasTranscludeDirective = false,
                hasTemplate = false,
                hasElementTranscludeDirective = previousCompileContext.hasElementTranscludeDirective,
                $compileNode = templateAttrs.$$element = jqLite(compileNode),
                directive,
                directiveName,
                $template,
                replaceDirective = originalReplaceDirective,
                childTranscludeFn = transcludeFn,
                linkFn,
                didScanForMultipleTransclusion = false,
                mightHaveMultipleTransclusionError = false,
                directiveValue;
            for (var i = 0,
                ii = directives.length; i < ii; i++) {
              directive = directives[i];
              var attrStart = directive.$$start;
              var attrEnd = directive.$$end;
              if (attrStart) {
                $compileNode = groupScan(compileNode, attrStart, attrEnd);
              }
              $template = undefined;
              if (terminalPriority > directive.priority) {
                break;
              }
              if (directiveValue = directive.scope) {
                if (!directive.templateUrl) {
                  if (isObject(directiveValue)) {
                    assertNoDuplicate('new/isolated scope', newIsolateScopeDirective || newScopeDirective, directive, $compileNode);
                    newIsolateScopeDirective = directive;
                  } else {
                    assertNoDuplicate('new/isolated scope', newIsolateScopeDirective, directive, $compileNode);
                  }
                }
                newScopeDirective = newScopeDirective || directive;
              }
              directiveName = directive.name;
              if (!didScanForMultipleTransclusion && ((directive.replace && (directive.templateUrl || directive.template)) || (directive.transclude && !directive.$$tlb))) {
                var candidateDirective;
                for (var scanningIndex = i + 1; candidateDirective = directives[scanningIndex++]; ) {
                  if ((candidateDirective.transclude && !candidateDirective.$$tlb) || (candidateDirective.replace && (candidateDirective.templateUrl || candidateDirective.template))) {
                    mightHaveMultipleTransclusionError = true;
                    break;
                  }
                }
                didScanForMultipleTransclusion = true;
              }
              if (!directive.templateUrl && directive.controller) {
                directiveValue = directive.controller;
                controllerDirectives = controllerDirectives || createMap();
                assertNoDuplicate("'" + directiveName + "' controller", controllerDirectives[directiveName], directive, $compileNode);
                controllerDirectives[directiveName] = directive;
              }
              if (directiveValue = directive.transclude) {
                hasTranscludeDirective = true;
                if (!directive.$$tlb) {
                  assertNoDuplicate('transclusion', nonTlbTranscludeDirective, directive, $compileNode);
                  nonTlbTranscludeDirective = directive;
                }
                if (directiveValue == 'element') {
                  hasElementTranscludeDirective = true;
                  terminalPriority = directive.priority;
                  $template = $compileNode;
                  $compileNode = templateAttrs.$$element = jqLite(compile.$$createComment(directiveName, templateAttrs[directiveName]));
                  compileNode = $compileNode[0];
                  replaceWith(jqCollection, sliceArgs($template), compileNode);
                  $template[0].$$parentNode = $template[0].parentNode;
                  childTranscludeFn = compilationGenerator(mightHaveMultipleTransclusionError, $template, transcludeFn, terminalPriority, replaceDirective && replaceDirective.name, {nonTlbTranscludeDirective: nonTlbTranscludeDirective});
                } else {
                  var slots = createMap();
                  $template = jqLite(jqLiteClone(compileNode)).contents();
                  if (isObject(directiveValue)) {
                    $template = [];
                    var slotMap = createMap();
                    var filledSlots = createMap();
                    forEach(directiveValue, function(elementSelector, slotName) {
                      var optional = (elementSelector.charAt(0) === '?');
                      elementSelector = optional ? elementSelector.substring(1) : elementSelector;
                      slotMap[elementSelector] = slotName;
                      slots[slotName] = null;
                      filledSlots[slotName] = optional;
                    });
                    forEach($compileNode.contents(), function(node) {
                      var slotName = slotMap[directiveNormalize(nodeName_(node))];
                      if (slotName) {
                        filledSlots[slotName] = true;
                        slots[slotName] = slots[slotName] || [];
                        slots[slotName].push(node);
                      } else {
                        $template.push(node);
                      }
                    });
                    forEach(filledSlots, function(filled, slotName) {
                      if (!filled) {
                        throw $compileMinErr('reqslot', 'Required transclusion slot `{0}` was not filled.', slotName);
                      }
                    });
                    for (var slotName in slots) {
                      if (slots[slotName]) {
                        slots[slotName] = compilationGenerator(mightHaveMultipleTransclusionError, slots[slotName], transcludeFn);
                      }
                    }
                  }
                  $compileNode.empty();
                  childTranscludeFn = compilationGenerator(mightHaveMultipleTransclusionError, $template, transcludeFn, undefined, undefined, {needsNewScope: directive.$$isolateScope || directive.$$newScope});
                  childTranscludeFn.$$slots = slots;
                }
              }
              if (directive.template) {
                hasTemplate = true;
                assertNoDuplicate('template', templateDirective, directive, $compileNode);
                templateDirective = directive;
                directiveValue = (isFunction(directive.template)) ? directive.template($compileNode, templateAttrs) : directive.template;
                directiveValue = denormalizeTemplate(directiveValue);
                if (directive.replace) {
                  replaceDirective = directive;
                  if (jqLiteIsTextNode(directiveValue)) {
                    $template = [];
                  } else {
                    $template = removeComments(wrapTemplate(directive.templateNamespace, trim(directiveValue)));
                  }
                  compileNode = $template[0];
                  if ($template.length != 1 || compileNode.nodeType !== NODE_TYPE_ELEMENT) {
                    throw $compileMinErr('tplrt', "Template for directive '{0}' must have exactly one root element. {1}", directiveName, '');
                  }
                  replaceWith(jqCollection, $compileNode, compileNode);
                  var newTemplateAttrs = {$attr: {}};
                  var templateDirectives = collectDirectives(compileNode, [], newTemplateAttrs);
                  var unprocessedDirectives = directives.splice(i + 1, directives.length - (i + 1));
                  if (newIsolateScopeDirective || newScopeDirective) {
                    markDirectiveScope(templateDirectives, newIsolateScopeDirective, newScopeDirective);
                  }
                  directives = directives.concat(templateDirectives).concat(unprocessedDirectives);
                  mergeTemplateAttributes(templateAttrs, newTemplateAttrs);
                  ii = directives.length;
                } else {
                  $compileNode.html(directiveValue);
                }
              }
              if (directive.templateUrl) {
                hasTemplate = true;
                assertNoDuplicate('template', templateDirective, directive, $compileNode);
                templateDirective = directive;
                if (directive.replace) {
                  replaceDirective = directive;
                }
                nodeLinkFn = compileTemplateUrl(directives.splice(i, directives.length - i), $compileNode, templateAttrs, jqCollection, hasTranscludeDirective && childTranscludeFn, preLinkFns, postLinkFns, {
                  controllerDirectives: controllerDirectives,
                  newScopeDirective: (newScopeDirective !== directive) && newScopeDirective,
                  newIsolateScopeDirective: newIsolateScopeDirective,
                  templateDirective: templateDirective,
                  nonTlbTranscludeDirective: nonTlbTranscludeDirective
                });
                ii = directives.length;
              } else if (directive.compile) {
                try {
                  linkFn = directive.compile($compileNode, templateAttrs, childTranscludeFn);
                  var context = directive.$$originalDirective || directive;
                  if (isFunction(linkFn)) {
                    addLinkFns(null, bind(context, linkFn), attrStart, attrEnd);
                  } else if (linkFn) {
                    addLinkFns(bind(context, linkFn.pre), bind(context, linkFn.post), attrStart, attrEnd);
                  }
                } catch (e) {
                  $exceptionHandler(e, startingTag($compileNode));
                }
              }
              if (directive.terminal) {
                nodeLinkFn.terminal = true;
                terminalPriority = Math.max(terminalPriority, directive.priority);
              }
            }
            nodeLinkFn.scope = newScopeDirective && newScopeDirective.scope === true;
            nodeLinkFn.transcludeOnThisElement = hasTranscludeDirective;
            nodeLinkFn.templateOnThisElement = hasTemplate;
            nodeLinkFn.transclude = childTranscludeFn;
            previousCompileContext.hasElementTranscludeDirective = hasElementTranscludeDirective;
            return nodeLinkFn;
            function addLinkFns(pre, post, attrStart, attrEnd) {
              if (pre) {
                if (attrStart)
                  pre = groupElementsLinkFnWrapper(pre, attrStart, attrEnd);
                pre.require = directive.require;
                pre.directiveName = directiveName;
                if (newIsolateScopeDirective === directive || directive.$$isolateScope) {
                  pre = cloneAndAnnotateFn(pre, {isolateScope: true});
                }
                preLinkFns.push(pre);
              }
              if (post) {
                if (attrStart)
                  post = groupElementsLinkFnWrapper(post, attrStart, attrEnd);
                post.require = directive.require;
                post.directiveName = directiveName;
                if (newIsolateScopeDirective === directive || directive.$$isolateScope) {
                  post = cloneAndAnnotateFn(post, {isolateScope: true});
                }
                postLinkFns.push(post);
              }
            }
            function nodeLinkFn(childLinkFn, scope, linkNode, $rootElement, boundTranscludeFn) {
              var i,
                  ii,
                  linkFn,
                  isolateScope,
                  controllerScope,
                  elementControllers,
                  transcludeFn,
                  $element,
                  attrs,
                  scopeBindingInfo;
              if (compileNode === linkNode) {
                attrs = templateAttrs;
                $element = templateAttrs.$$element;
              } else {
                $element = jqLite(linkNode);
                attrs = new Attributes($element, templateAttrs);
              }
              controllerScope = scope;
              if (newIsolateScopeDirective) {
                isolateScope = scope.$new(true);
              } else if (newScopeDirective) {
                controllerScope = scope.$parent;
              }
              if (boundTranscludeFn) {
                transcludeFn = controllersBoundTransclude;
                transcludeFn.$$boundTransclude = boundTranscludeFn;
                transcludeFn.isSlotFilled = function(slotName) {
                  return !!boundTranscludeFn.$$slots[slotName];
                };
              }
              if (controllerDirectives) {
                elementControllers = setupControllers($element, attrs, transcludeFn, controllerDirectives, isolateScope, scope, newIsolateScopeDirective);
              }
              if (newIsolateScopeDirective) {
                compile.$$addScopeInfo($element, isolateScope, true, !(templateDirective && (templateDirective === newIsolateScopeDirective || templateDirective === newIsolateScopeDirective.$$originalDirective)));
                compile.$$addScopeClass($element, true);
                isolateScope.$$isolateBindings = newIsolateScopeDirective.$$isolateBindings;
                scopeBindingInfo = initializeDirectiveBindings(scope, attrs, isolateScope, isolateScope.$$isolateBindings, newIsolateScopeDirective);
                if (scopeBindingInfo.removeWatches) {
                  isolateScope.$on('$destroy', scopeBindingInfo.removeWatches);
                }
              }
              for (var name in elementControllers) {
                var controllerDirective = controllerDirectives[name];
                var controller = elementControllers[name];
                var bindings = controllerDirective.$$bindings.bindToController;
                if (controller.identifier && bindings) {
                  controller.bindingInfo = initializeDirectiveBindings(controllerScope, attrs, controller.instance, bindings, controllerDirective);
                } else {
                  controller.bindingInfo = {};
                }
                var controllerResult = controller();
                if (controllerResult !== controller.instance) {
                  controller.instance = controllerResult;
                  $element.data('$' + controllerDirective.name + 'Controller', controllerResult);
                  controller.bindingInfo.removeWatches && controller.bindingInfo.removeWatches();
                  controller.bindingInfo = initializeDirectiveBindings(controllerScope, attrs, controller.instance, bindings, controllerDirective);
                }
              }
              forEach(controllerDirectives, function(controllerDirective, name) {
                var require = controllerDirective.require;
                if (controllerDirective.bindToController && !isArray(require) && isObject(require)) {
                  extend(elementControllers[name].instance, getControllers(name, require, $element, elementControllers));
                }
              });
              forEach(elementControllers, function(controller) {
                var controllerInstance = controller.instance;
                if (isFunction(controllerInstance.$onChanges)) {
                  try {
                    controllerInstance.$onChanges(controller.bindingInfo.initialChanges);
                  } catch (e) {
                    $exceptionHandler(e);
                  }
                }
                if (isFunction(controllerInstance.$onInit)) {
                  try {
                    controllerInstance.$onInit();
                  } catch (e) {
                    $exceptionHandler(e);
                  }
                }
                if (isFunction(controllerInstance.$onDestroy)) {
                  controllerScope.$on('$destroy', function callOnDestroyHook() {
                    controllerInstance.$onDestroy();
                  });
                }
              });
              for (i = 0, ii = preLinkFns.length; i < ii; i++) {
                linkFn = preLinkFns[i];
                invokeLinkFn(linkFn, linkFn.isolateScope ? isolateScope : scope, $element, attrs, linkFn.require && getControllers(linkFn.directiveName, linkFn.require, $element, elementControllers), transcludeFn);
              }
              var scopeToChild = scope;
              if (newIsolateScopeDirective && (newIsolateScopeDirective.template || newIsolateScopeDirective.templateUrl === null)) {
                scopeToChild = isolateScope;
              }
              childLinkFn && childLinkFn(scopeToChild, linkNode.childNodes, undefined, boundTranscludeFn);
              for (i = postLinkFns.length - 1; i >= 0; i--) {
                linkFn = postLinkFns[i];
                invokeLinkFn(linkFn, linkFn.isolateScope ? isolateScope : scope, $element, attrs, linkFn.require && getControllers(linkFn.directiveName, linkFn.require, $element, elementControllers), transcludeFn);
              }
              forEach(elementControllers, function(controller) {
                var controllerInstance = controller.instance;
                if (isFunction(controllerInstance.$postLink)) {
                  controllerInstance.$postLink();
                }
              });
              function controllersBoundTransclude(scope, cloneAttachFn, futureParentElement, slotName) {
                var transcludeControllers;
                if (!isScope(scope)) {
                  slotName = futureParentElement;
                  futureParentElement = cloneAttachFn;
                  cloneAttachFn = scope;
                  scope = undefined;
                }
                if (hasElementTranscludeDirective) {
                  transcludeControllers = elementControllers;
                }
                if (!futureParentElement) {
                  futureParentElement = hasElementTranscludeDirective ? $element.parent() : $element;
                }
                if (slotName) {
                  var slotTranscludeFn = boundTranscludeFn.$$slots[slotName];
                  if (slotTranscludeFn) {
                    return slotTranscludeFn(scope, cloneAttachFn, transcludeControllers, futureParentElement, scopeToChild);
                  } else if (isUndefined(slotTranscludeFn)) {
                    throw $compileMinErr('noslot', 'No parent directive that requires a transclusion with slot name "{0}". ' + 'Element: {1}', slotName, startingTag($element));
                  }
                } else {
                  return boundTranscludeFn(scope, cloneAttachFn, transcludeControllers, futureParentElement, scopeToChild);
                }
              }
            }
          }
          function getControllers(directiveName, require, $element, elementControllers) {
            var value;
            if (isString(require)) {
              var match = require.match(REQUIRE_PREFIX_REGEXP);
              var name = require.substring(match[0].length);
              var inheritType = match[1] || match[3];
              var optional = match[2] === '?';
              if (inheritType === '^^') {
                $element = $element.parent();
              } else {
                value = elementControllers && elementControllers[name];
                value = value && value.instance;
              }
              if (!value) {
                var dataName = '$' + name + 'Controller';
                value = inheritType ? $element.inheritedData(dataName) : $element.data(dataName);
              }
              if (!value && !optional) {
                throw $compileMinErr('ctreq', "Controller '{0}', required by directive '{1}', can't be found!", name, directiveName);
              }
            } else if (isArray(require)) {
              value = [];
              for (var i = 0,
                  ii = require.length; i < ii; i++) {
                value[i] = getControllers(directiveName, require[i], $element, elementControllers);
              }
            } else if (isObject(require)) {
              value = {};
              forEach(require, function(controller, property) {
                value[property] = getControllers(directiveName, controller, $element, elementControllers);
              });
            }
            return value || null;
          }
          function setupControllers($element, attrs, transcludeFn, controllerDirectives, isolateScope, scope, newIsolateScopeDirective) {
            var elementControllers = createMap();
            for (var controllerKey in controllerDirectives) {
              var directive = controllerDirectives[controllerKey];
              var locals = {
                $scope: directive === newIsolateScopeDirective || directive.$$isolateScope ? isolateScope : scope,
                $element: $element,
                $attrs: attrs,
                $transclude: transcludeFn
              };
              var controller = directive.controller;
              if (controller == '@') {
                controller = attrs[directive.name];
              }
              var controllerInstance = $controller(controller, locals, true, directive.controllerAs);
              elementControllers[directive.name] = controllerInstance;
              $element.data('$' + directive.name + 'Controller', controllerInstance.instance);
            }
            return elementControllers;
          }
          function markDirectiveScope(directives, isolateScope, newScope) {
            for (var j = 0,
                jj = directives.length; j < jj; j++) {
              directives[j] = inherit(directives[j], {
                $$isolateScope: isolateScope,
                $$newScope: newScope
              });
            }
          }
          function addDirective(tDirectives, name, location, maxPriority, ignoreDirective, startAttrName, endAttrName) {
            if (name === ignoreDirective)
              return null;
            var match = null;
            if (hasDirectives.hasOwnProperty(name)) {
              for (var directive,
                  directives = $injector.get(name + Suffix),
                  i = 0,
                  ii = directives.length; i < ii; i++) {
                try {
                  directive = directives[i];
                  if ((isUndefined(maxPriority) || maxPriority > directive.priority) && directive.restrict.indexOf(location) != -1) {
                    if (startAttrName) {
                      directive = inherit(directive, {
                        $$start: startAttrName,
                        $$end: endAttrName
                      });
                    }
                    if (!directive.$$bindings) {
                      var bindings = directive.$$bindings = parseDirectiveBindings(directive, directive.name);
                      if (isObject(bindings.isolateScope)) {
                        directive.$$isolateBindings = bindings.isolateScope;
                      }
                    }
                    tDirectives.push(directive);
                    match = directive;
                  }
                } catch (e) {
                  $exceptionHandler(e);
                }
              }
            }
            return match;
          }
          function directiveIsMultiElement(name) {
            if (hasDirectives.hasOwnProperty(name)) {
              for (var directive,
                  directives = $injector.get(name + Suffix),
                  i = 0,
                  ii = directives.length; i < ii; i++) {
                directive = directives[i];
                if (directive.multiElement) {
                  return true;
                }
              }
            }
            return false;
          }
          function mergeTemplateAttributes(dst, src) {
            var srcAttr = src.$attr,
                dstAttr = dst.$attr,
                $element = dst.$$element;
            forEach(dst, function(value, key) {
              if (key.charAt(0) != '$') {
                if (src[key] && src[key] !== value) {
                  value += (key === 'style' ? ';' : ' ') + src[key];
                }
                dst.$set(key, value, true, srcAttr[key]);
              }
            });
            forEach(src, function(value, key) {
              if (!dst.hasOwnProperty(key) && key.charAt(0) !== '$') {
                dst[key] = value;
                if (key !== 'class' && key !== 'style') {
                  dstAttr[key] = srcAttr[key];
                }
              }
            });
          }
          function compileTemplateUrl(directives, $compileNode, tAttrs, $rootElement, childTranscludeFn, preLinkFns, postLinkFns, previousCompileContext) {
            var linkQueue = [],
                afterTemplateNodeLinkFn,
                afterTemplateChildLinkFn,
                beforeTemplateCompileNode = $compileNode[0],
                origAsyncDirective = directives.shift(),
                derivedSyncDirective = inherit(origAsyncDirective, {
                  templateUrl: null,
                  transclude: null,
                  replace: null,
                  $$originalDirective: origAsyncDirective
                }),
                templateUrl = (isFunction(origAsyncDirective.templateUrl)) ? origAsyncDirective.templateUrl($compileNode, tAttrs) : origAsyncDirective.templateUrl,
                templateNamespace = origAsyncDirective.templateNamespace;
            $compileNode.empty();
            $templateRequest(templateUrl).then(function(content) {
              var compileNode,
                  tempTemplateAttrs,
                  $template,
                  childBoundTranscludeFn;
              content = denormalizeTemplate(content);
              if (origAsyncDirective.replace) {
                if (jqLiteIsTextNode(content)) {
                  $template = [];
                } else {
                  $template = removeComments(wrapTemplate(templateNamespace, trim(content)));
                }
                compileNode = $template[0];
                if ($template.length != 1 || compileNode.nodeType !== NODE_TYPE_ELEMENT) {
                  throw $compileMinErr('tplrt', "Template for directive '{0}' must have exactly one root element. {1}", origAsyncDirective.name, templateUrl);
                }
                tempTemplateAttrs = {$attr: {}};
                replaceWith($rootElement, $compileNode, compileNode);
                var templateDirectives = collectDirectives(compileNode, [], tempTemplateAttrs);
                if (isObject(origAsyncDirective.scope)) {
                  markDirectiveScope(templateDirectives, true);
                }
                directives = templateDirectives.concat(directives);
                mergeTemplateAttributes(tAttrs, tempTemplateAttrs);
              } else {
                compileNode = beforeTemplateCompileNode;
                $compileNode.html(content);
              }
              directives.unshift(derivedSyncDirective);
              afterTemplateNodeLinkFn = applyDirectivesToNode(directives, compileNode, tAttrs, childTranscludeFn, $compileNode, origAsyncDirective, preLinkFns, postLinkFns, previousCompileContext);
              forEach($rootElement, function(node, i) {
                if (node == compileNode) {
                  $rootElement[i] = $compileNode[0];
                }
              });
              afterTemplateChildLinkFn = compileNodes($compileNode[0].childNodes, childTranscludeFn);
              while (linkQueue.length) {
                var scope = linkQueue.shift(),
                    beforeTemplateLinkNode = linkQueue.shift(),
                    linkRootElement = linkQueue.shift(),
                    boundTranscludeFn = linkQueue.shift(),
                    linkNode = $compileNode[0];
                if (scope.$$destroyed)
                  continue;
                if (beforeTemplateLinkNode !== beforeTemplateCompileNode) {
                  var oldClasses = beforeTemplateLinkNode.className;
                  if (!(previousCompileContext.hasElementTranscludeDirective && origAsyncDirective.replace)) {
                    linkNode = jqLiteClone(compileNode);
                  }
                  replaceWith(linkRootElement, jqLite(beforeTemplateLinkNode), linkNode);
                  safeAddClass(jqLite(linkNode), oldClasses);
                }
                if (afterTemplateNodeLinkFn.transcludeOnThisElement) {
                  childBoundTranscludeFn = createBoundTranscludeFn(scope, afterTemplateNodeLinkFn.transclude, boundTranscludeFn);
                } else {
                  childBoundTranscludeFn = boundTranscludeFn;
                }
                afterTemplateNodeLinkFn(afterTemplateChildLinkFn, scope, linkNode, $rootElement, childBoundTranscludeFn);
              }
              linkQueue = null;
            });
            return function delayedNodeLinkFn(ignoreChildLinkFn, scope, node, rootElement, boundTranscludeFn) {
              var childBoundTranscludeFn = boundTranscludeFn;
              if (scope.$$destroyed)
                return;
              if (linkQueue) {
                linkQueue.push(scope, node, rootElement, childBoundTranscludeFn);
              } else {
                if (afterTemplateNodeLinkFn.transcludeOnThisElement) {
                  childBoundTranscludeFn = createBoundTranscludeFn(scope, afterTemplateNodeLinkFn.transclude, boundTranscludeFn);
                }
                afterTemplateNodeLinkFn(afterTemplateChildLinkFn, scope, node, rootElement, childBoundTranscludeFn);
              }
            };
          }
          function byPriority(a, b) {
            var diff = b.priority - a.priority;
            if (diff !== 0)
              return diff;
            if (a.name !== b.name)
              return (a.name < b.name) ? -1 : 1;
            return a.index - b.index;
          }
          function assertNoDuplicate(what, previousDirective, directive, element) {
            function wrapModuleNameIfDefined(moduleName) {
              return moduleName ? (' (module: ' + moduleName + ')') : '';
            }
            if (previousDirective) {
              throw $compileMinErr('multidir', 'Multiple directives [{0}{1}, {2}{3}] asking for {4} on: {5}', previousDirective.name, wrapModuleNameIfDefined(previousDirective.$$moduleName), directive.name, wrapModuleNameIfDefined(directive.$$moduleName), what, startingTag(element));
            }
          }
          function addTextInterpolateDirective(directives, text) {
            var interpolateFn = $interpolate(text, true);
            if (interpolateFn) {
              directives.push({
                priority: 0,
                compile: function textInterpolateCompileFn(templateNode) {
                  var templateNodeParent = templateNode.parent(),
                      hasCompileParent = !!templateNodeParent.length;
                  if (hasCompileParent)
                    compile.$$addBindingClass(templateNodeParent);
                  return function textInterpolateLinkFn(scope, node) {
                    var parent = node.parent();
                    if (!hasCompileParent)
                      compile.$$addBindingClass(parent);
                    compile.$$addBindingInfo(parent, interpolateFn.expressions);
                    scope.$watch(interpolateFn, function interpolateFnWatchAction(value) {
                      node[0].nodeValue = value;
                    });
                  };
                }
              });
            }
          }
          function wrapTemplate(type, template) {
            type = lowercase(type || 'html');
            switch (type) {
              case 'svg':
              case 'math':
                var wrapper = window.document.createElement('div');
                wrapper.innerHTML = '<' + type + '>' + template + '</' + type + '>';
                return wrapper.childNodes[0].childNodes;
              default:
                return template;
            }
          }
          function getTrustedContext(node, attrNormalizedName) {
            if (attrNormalizedName == "srcdoc") {
              return $sce.HTML;
            }
            var tag = nodeName_(node);
            if (attrNormalizedName == "xlinkHref" || (tag == "form" && attrNormalizedName == "action") || (tag != "img" && (attrNormalizedName == "src" || attrNormalizedName == "ngSrc"))) {
              return $sce.RESOURCE_URL;
            }
          }
          function addAttrInterpolateDirective(node, directives, value, name, allOrNothing) {
            var trustedContext = getTrustedContext(node, name);
            allOrNothing = ALL_OR_NOTHING_ATTRS[name] || allOrNothing;
            var interpolateFn = $interpolate(value, true, trustedContext, allOrNothing);
            if (!interpolateFn)
              return;
            if (name === "multiple" && nodeName_(node) === "select") {
              throw $compileMinErr("selmulti", "Binding to the 'multiple' attribute is not supported. Element: {0}", startingTag(node));
            }
            directives.push({
              priority: 100,
              compile: function() {
                return {pre: function attrInterpolatePreLinkFn(scope, element, attr) {
                    var $$observers = (attr.$$observers || (attr.$$observers = createMap()));
                    if (EVENT_HANDLER_ATTR_REGEXP.test(name)) {
                      throw $compileMinErr('nodomevents', "Interpolations for HTML DOM event attributes are disallowed.  Please use the " + "ng- versions (such as ng-click instead of onclick) instead.");
                    }
                    var newValue = attr[name];
                    if (newValue !== value) {
                      interpolateFn = newValue && $interpolate(newValue, true, trustedContext, allOrNothing);
                      value = newValue;
                    }
                    if (!interpolateFn)
                      return;
                    attr[name] = interpolateFn(scope);
                    ($$observers[name] || ($$observers[name] = [])).$$inter = true;
                    (attr.$$observers && attr.$$observers[name].$$scope || scope).$watch(interpolateFn, function interpolateFnWatchAction(newValue, oldValue) {
                      if (name === 'class' && newValue != oldValue) {
                        attr.$updateClass(newValue, oldValue);
                      } else {
                        attr.$set(name, newValue);
                      }
                    });
                  }};
              }
            });
          }
          function replaceWith($rootElement, elementsToRemove, newNode) {
            var firstElementToRemove = elementsToRemove[0],
                removeCount = elementsToRemove.length,
                parent = firstElementToRemove.parentNode,
                i,
                ii;
            if ($rootElement) {
              for (i = 0, ii = $rootElement.length; i < ii; i++) {
                if ($rootElement[i] == firstElementToRemove) {
                  $rootElement[i++] = newNode;
                  for (var j = i,
                      j2 = j + removeCount - 1,
                      jj = $rootElement.length; j < jj; j++, j2++) {
                    if (j2 < jj) {
                      $rootElement[j] = $rootElement[j2];
                    } else {
                      delete $rootElement[j];
                    }
                  }
                  $rootElement.length -= removeCount - 1;
                  if ($rootElement.context === firstElementToRemove) {
                    $rootElement.context = newNode;
                  }
                  break;
                }
              }
            }
            if (parent) {
              parent.replaceChild(newNode, firstElementToRemove);
            }
            var fragment = window.document.createDocumentFragment();
            for (i = 0; i < removeCount; i++) {
              fragment.appendChild(elementsToRemove[i]);
            }
            if (jqLite.hasData(firstElementToRemove)) {
              jqLite.data(newNode, jqLite.data(firstElementToRemove));
              jqLite(firstElementToRemove).off('$destroy');
            }
            jqLite.cleanData(fragment.querySelectorAll('*'));
            for (i = 1; i < removeCount; i++) {
              delete elementsToRemove[i];
            }
            elementsToRemove[0] = newNode;
            elementsToRemove.length = 1;
          }
          function cloneAndAnnotateFn(fn, annotation) {
            return extend(function() {
              return fn.apply(null, arguments);
            }, fn, annotation);
          }
          function invokeLinkFn(linkFn, scope, $element, attrs, controllers, transcludeFn) {
            try {
              linkFn(scope, $element, attrs, controllers, transcludeFn);
            } catch (e) {
              $exceptionHandler(e, startingTag($element));
            }
          }
          function initializeDirectiveBindings(scope, attrs, destination, bindings, directive) {
            var removeWatchCollection = [];
            var initialChanges = {};
            var changes;
            forEach(bindings, function initializeBinding(definition, scopeName) {
              var attrName = definition.attrName,
                  optional = definition.optional,
                  mode = definition.mode,
                  lastValue,
                  parentGet,
                  parentSet,
                  compare,
                  removeWatch;
              switch (mode) {
                case '@':
                  if (!optional && !hasOwnProperty.call(attrs, attrName)) {
                    destination[scopeName] = attrs[attrName] = void 0;
                  }
                  attrs.$observe(attrName, function(value) {
                    if (isString(value) || isBoolean(value)) {
                      var oldValue = destination[scopeName];
                      recordChanges(scopeName, value, oldValue);
                      destination[scopeName] = value;
                    }
                  });
                  attrs.$$observers[attrName].$$scope = scope;
                  lastValue = attrs[attrName];
                  if (isString(lastValue)) {
                    destination[scopeName] = $interpolate(lastValue)(scope);
                  } else if (isBoolean(lastValue)) {
                    destination[scopeName] = lastValue;
                  }
                  initialChanges[scopeName] = new SimpleChange(_UNINITIALIZED_VALUE, destination[scopeName]);
                  break;
                case '=':
                  if (!hasOwnProperty.call(attrs, attrName)) {
                    if (optional)
                      break;
                    attrs[attrName] = void 0;
                  }
                  if (optional && !attrs[attrName])
                    break;
                  parentGet = $parse(attrs[attrName]);
                  if (parentGet.literal) {
                    compare = equals;
                  } else {
                    compare = function simpleCompare(a, b) {
                      return a === b || (a !== a && b !== b);
                    };
                  }
                  parentSet = parentGet.assign || function() {
                    lastValue = destination[scopeName] = parentGet(scope);
                    throw $compileMinErr('nonassign', "Expression '{0}' in attribute '{1}' used with directive '{2}' is non-assignable!", attrs[attrName], attrName, directive.name);
                  };
                  lastValue = destination[scopeName] = parentGet(scope);
                  var parentValueWatch = function parentValueWatch(parentValue) {
                    if (!compare(parentValue, destination[scopeName])) {
                      if (!compare(parentValue, lastValue)) {
                        destination[scopeName] = parentValue;
                      } else {
                        parentSet(scope, parentValue = destination[scopeName]);
                      }
                    }
                    return lastValue = parentValue;
                  };
                  parentValueWatch.$stateful = true;
                  if (definition.collection) {
                    removeWatch = scope.$watchCollection(attrs[attrName], parentValueWatch);
                  } else {
                    removeWatch = scope.$watch($parse(attrs[attrName], parentValueWatch), null, parentGet.literal);
                  }
                  removeWatchCollection.push(removeWatch);
                  break;
                case '<':
                  if (!hasOwnProperty.call(attrs, attrName)) {
                    if (optional)
                      break;
                    attrs[attrName] = void 0;
                  }
                  if (optional && !attrs[attrName])
                    break;
                  parentGet = $parse(attrs[attrName]);
                  var initialValue = destination[scopeName] = parentGet(scope);
                  initialChanges[scopeName] = new SimpleChange(_UNINITIALIZED_VALUE, destination[scopeName]);
                  removeWatch = scope.$watch(parentGet, function parentValueWatchAction(newValue, oldValue) {
                    if (oldValue === newValue) {
                      if (oldValue === initialValue)
                        return;
                      oldValue = initialValue;
                    }
                    recordChanges(scopeName, newValue, oldValue);
                    destination[scopeName] = newValue;
                  }, parentGet.literal);
                  removeWatchCollection.push(removeWatch);
                  break;
                case '&':
                  parentGet = attrs.hasOwnProperty(attrName) ? $parse(attrs[attrName]) : noop;
                  if (parentGet === noop && optional)
                    break;
                  destination[scopeName] = function(locals) {
                    return parentGet(scope, locals);
                  };
                  break;
              }
            });
            function recordChanges(key, currentValue, previousValue) {
              if (isFunction(destination.$onChanges) && currentValue !== previousValue) {
                if (!onChangesQueue) {
                  scope.$$postDigest(flushOnChangesQueue);
                  onChangesQueue = [];
                }
                if (!changes) {
                  changes = {};
                  onChangesQueue.push(triggerOnChangesHook);
                }
                if (changes[key]) {
                  previousValue = changes[key].previousValue;
                }
                changes[key] = new SimpleChange(previousValue, currentValue);
              }
            }
            function triggerOnChangesHook() {
              destination.$onChanges(changes);
              changes = undefined;
            }
            return {
              initialChanges: initialChanges,
              removeWatches: removeWatchCollection.length && function removeWatches() {
                for (var i = 0,
                    ii = removeWatchCollection.length; i < ii; ++i) {
                  removeWatchCollection[i]();
                }
              }
            };
          }
        }];
      }
      function SimpleChange(previous, current) {
        this.previousValue = previous;
        this.currentValue = current;
      }
      SimpleChange.prototype.isFirstChange = function() {
        return this.previousValue === _UNINITIALIZED_VALUE;
      };
      var PREFIX_REGEXP = /^((?:x|data)[\:\-_])/i;
      function directiveNormalize(name) {
        return camelCase(name.replace(PREFIX_REGEXP, ''));
      }
      function nodesetLinkingFn(scope, nodeList, rootElement, boundTranscludeFn) {}
      function directiveLinkingFn(nodesetLinkingFn, scope, node, rootElement, boundTranscludeFn) {}
      function tokenDifference(str1, str2) {
        var values = '',
            tokens1 = str1.split(/\s+/),
            tokens2 = str2.split(/\s+/);
        outer: for (var i = 0; i < tokens1.length; i++) {
          var token = tokens1[i];
          for (var j = 0; j < tokens2.length; j++) {
            if (token == tokens2[j])
              continue outer;
          }
          values += (values.length > 0 ? ' ' : '') + token;
        }
        return values;
      }
      function removeComments(jqNodes) {
        jqNodes = jqLite(jqNodes);
        var i = jqNodes.length;
        if (i <= 1) {
          return jqNodes;
        }
        while (i--) {
          var node = jqNodes[i];
          if (node.nodeType === NODE_TYPE_COMMENT) {
            splice.call(jqNodes, i, 1);
          }
        }
        return jqNodes;
      }
      var $controllerMinErr = minErr('$controller');
      var CNTRL_REG = /^(\S+)(\s+as\s+([\w$]+))?$/;
      function identifierForController(controller, ident) {
        if (ident && isString(ident))
          return ident;
        if (isString(controller)) {
          var match = CNTRL_REG.exec(controller);
          if (match)
            return match[3];
        }
      }
      function $ControllerProvider() {
        var controllers = {},
            globals = false;
        this.has = function(name) {
          return controllers.hasOwnProperty(name);
        };
        this.register = function(name, constructor) {
          assertNotHasOwnProperty(name, 'controller');
          if (isObject(name)) {
            extend(controllers, name);
          } else {
            controllers[name] = constructor;
          }
        };
        this.allowGlobals = function() {
          globals = true;
        };
        this.$get = ['$injector', '$window', function($injector, $window) {
          return function $controller(expression, locals, later, ident) {
            var instance,
                match,
                constructor,
                identifier;
            later = later === true;
            if (ident && isString(ident)) {
              identifier = ident;
            }
            if (isString(expression)) {
              match = expression.match(CNTRL_REG);
              if (!match) {
                throw $controllerMinErr('ctrlfmt', "Badly formed controller string '{0}'. " + "Must match `__name__ as __id__` or `__name__`.", expression);
              }
              constructor = match[1], identifier = identifier || match[3];
              expression = controllers.hasOwnProperty(constructor) ? controllers[constructor] : getter(locals.$scope, constructor, true) || (globals ? getter($window, constructor, true) : undefined);
              assertArgFn(expression, constructor, true);
            }
            if (later) {
              var controllerPrototype = (isArray(expression) ? expression[expression.length - 1] : expression).prototype;
              instance = Object.create(controllerPrototype || null);
              if (identifier) {
                addIdentifier(locals, identifier, instance, constructor || expression.name);
              }
              var instantiate;
              return instantiate = extend(function $controllerInit() {
                var result = $injector.invoke(expression, instance, locals, constructor);
                if (result !== instance && (isObject(result) || isFunction(result))) {
                  instance = result;
                  if (identifier) {
                    addIdentifier(locals, identifier, instance, constructor || expression.name);
                  }
                }
                return instance;
              }, {
                instance: instance,
                identifier: identifier
              });
            }
            instance = $injector.instantiate(expression, locals, constructor);
            if (identifier) {
              addIdentifier(locals, identifier, instance, constructor || expression.name);
            }
            return instance;
          };
          function addIdentifier(locals, identifier, instance, name) {
            if (!(locals && isObject(locals.$scope))) {
              throw minErr('$controller')('noscp', "Cannot export controller '{0}' as '{1}'! No $scope object provided via `locals`.", name, identifier);
            }
            locals.$scope[identifier] = instance;
          }
        }];
      }
      function $DocumentProvider() {
        this.$get = ['$window', function(window) {
          return jqLite(window.document);
        }];
      }
      function $ExceptionHandlerProvider() {
        this.$get = ['$log', function($log) {
          return function(exception, cause) {
            $log.error.apply($log, arguments);
          };
        }];
      }
      var $$ForceReflowProvider = function() {
        this.$get = ['$document', function($document) {
          return function(domNode) {
            if (domNode) {
              if (!domNode.nodeType && domNode instanceof jqLite) {
                domNode = domNode[0];
              }
            } else {
              domNode = $document[0].body;
            }
            return domNode.offsetWidth + 1;
          };
        }];
      };
      var APPLICATION_JSON = 'application/json';
      var CONTENT_TYPE_APPLICATION_JSON = {'Content-Type': APPLICATION_JSON + ';charset=utf-8'};
      var JSON_START = /^\[|^\{(?!\{)/;
      var JSON_ENDS = {
        '[': /]$/,
        '{': /}$/
      };
      var JSON_PROTECTION_PREFIX = /^\)\]\}',?\n/;
      var $httpMinErr = minErr('$http');
      var $httpMinErrLegacyFn = function(method) {
        return function() {
          throw $httpMinErr('legacy', 'The method `{0}` on the promise returned from `$http` has been disabled.', method);
        };
      };
      function serializeValue(v) {
        if (isObject(v)) {
          return isDate(v) ? v.toISOString() : toJson(v);
        }
        return v;
      }
      function $HttpParamSerializerProvider() {
        this.$get = function() {
          return function ngParamSerializer(params) {
            if (!params)
              return '';
            var parts = [];
            forEachSorted(params, function(value, key) {
              if (value === null || isUndefined(value))
                return;
              if (isArray(value)) {
                forEach(value, function(v) {
                  parts.push(encodeUriQuery(key) + '=' + encodeUriQuery(serializeValue(v)));
                });
              } else {
                parts.push(encodeUriQuery(key) + '=' + encodeUriQuery(serializeValue(value)));
              }
            });
            return parts.join('&');
          };
        };
      }
      function $HttpParamSerializerJQLikeProvider() {
        this.$get = function() {
          return function jQueryLikeParamSerializer(params) {
            if (!params)
              return '';
            var parts = [];
            serialize(params, '', true);
            return parts.join('&');
            function serialize(toSerialize, prefix, topLevel) {
              if (toSerialize === null || isUndefined(toSerialize))
                return;
              if (isArray(toSerialize)) {
                forEach(toSerialize, function(value, index) {
                  serialize(value, prefix + '[' + (isObject(value) ? index : '') + ']');
                });
              } else if (isObject(toSerialize) && !isDate(toSerialize)) {
                forEachSorted(toSerialize, function(value, key) {
                  serialize(value, prefix + (topLevel ? '' : '[') + key + (topLevel ? '' : ']'));
                });
              } else {
                parts.push(encodeUriQuery(prefix) + '=' + encodeUriQuery(serializeValue(toSerialize)));
              }
            }
          };
        };
      }
      function defaultHttpResponseTransform(data, headers) {
        if (isString(data)) {
          var tempData = data.replace(JSON_PROTECTION_PREFIX, '').trim();
          if (tempData) {
            var contentType = headers('Content-Type');
            if ((contentType && (contentType.indexOf(APPLICATION_JSON) === 0)) || isJsonLike(tempData)) {
              data = fromJson(tempData);
            }
          }
        }
        return data;
      }
      function isJsonLike(str) {
        var jsonStart = str.match(JSON_START);
        return jsonStart && JSON_ENDS[jsonStart[0]].test(str);
      }
      function parseHeaders(headers) {
        var parsed = createMap(),
            i;
        function fillInParsed(key, val) {
          if (key) {
            parsed[key] = parsed[key] ? parsed[key] + ', ' + val : val;
          }
        }
        if (isString(headers)) {
          forEach(headers.split('\n'), function(line) {
            i = line.indexOf(':');
            fillInParsed(lowercase(trim(line.substr(0, i))), trim(line.substr(i + 1)));
          });
        } else if (isObject(headers)) {
          forEach(headers, function(headerVal, headerKey) {
            fillInParsed(lowercase(headerKey), trim(headerVal));
          });
        }
        return parsed;
      }
      function headersGetter(headers) {
        var headersObj;
        return function(name) {
          if (!headersObj)
            headersObj = parseHeaders(headers);
          if (name) {
            var value = headersObj[lowercase(name)];
            if (value === void 0) {
              value = null;
            }
            return value;
          }
          return headersObj;
        };
      }
      function transformData(data, headers, status, fns) {
        if (isFunction(fns)) {
          return fns(data, headers, status);
        }
        forEach(fns, function(fn) {
          data = fn(data, headers, status);
        });
        return data;
      }
      function isSuccess(status) {
        return 200 <= status && status < 300;
      }
      function $HttpProvider() {
        var defaults = this.defaults = {
          transformResponse: [defaultHttpResponseTransform],
          transformRequest: [function(d) {
            return isObject(d) && !isFile(d) && !isBlob(d) && !isFormData(d) ? toJson(d) : d;
          }],
          headers: {
            common: {'Accept': 'application/json, text/plain, */*'},
            post: shallowCopy(CONTENT_TYPE_APPLICATION_JSON),
            put: shallowCopy(CONTENT_TYPE_APPLICATION_JSON),
            patch: shallowCopy(CONTENT_TYPE_APPLICATION_JSON)
          },
          xsrfCookieName: 'XSRF-TOKEN',
          xsrfHeaderName: 'X-XSRF-TOKEN',
          paramSerializer: '$httpParamSerializer'
        };
        var useApplyAsync = false;
        this.useApplyAsync = function(value) {
          if (isDefined(value)) {
            useApplyAsync = !!value;
            return this;
          }
          return useApplyAsync;
        };
        var useLegacyPromise = true;
        this.useLegacyPromiseExtensions = function(value) {
          if (isDefined(value)) {
            useLegacyPromise = !!value;
            return this;
          }
          return useLegacyPromise;
        };
        var interceptorFactories = this.interceptors = [];
        this.$get = ['$httpBackend', '$$cookieReader', '$cacheFactory', '$rootScope', '$q', '$injector', function($httpBackend, $$cookieReader, $cacheFactory, $rootScope, $q, $injector) {
          var defaultCache = $cacheFactory('$http');
          defaults.paramSerializer = isString(defaults.paramSerializer) ? $injector.get(defaults.paramSerializer) : defaults.paramSerializer;
          var reversedInterceptors = [];
          forEach(interceptorFactories, function(interceptorFactory) {
            reversedInterceptors.unshift(isString(interceptorFactory) ? $injector.get(interceptorFactory) : $injector.invoke(interceptorFactory));
          });
          function $http(requestConfig) {
            if (!isObject(requestConfig)) {
              throw minErr('$http')('badreq', 'Http request configuration must be an object.  Received: {0}', requestConfig);
            }
            if (!isString(requestConfig.url)) {
              throw minErr('$http')('badreq', 'Http request configuration url must be a string.  Received: {0}', requestConfig.url);
            }
            var config = extend({
              method: 'get',
              transformRequest: defaults.transformRequest,
              transformResponse: defaults.transformResponse,
              paramSerializer: defaults.paramSerializer
            }, requestConfig);
            config.headers = mergeHeaders(requestConfig);
            config.method = uppercase(config.method);
            config.paramSerializer = isString(config.paramSerializer) ? $injector.get(config.paramSerializer) : config.paramSerializer;
            var serverRequest = function(config) {
              var headers = config.headers;
              var reqData = transformData(config.data, headersGetter(headers), undefined, config.transformRequest);
              if (isUndefined(reqData)) {
                forEach(headers, function(value, header) {
                  if (lowercase(header) === 'content-type') {
                    delete headers[header];
                  }
                });
              }
              if (isUndefined(config.withCredentials) && !isUndefined(defaults.withCredentials)) {
                config.withCredentials = defaults.withCredentials;
              }
              return sendReq(config, reqData).then(transformResponse, transformResponse);
            };
            var chain = [serverRequest, undefined];
            var promise = $q.when(config);
            forEach(reversedInterceptors, function(interceptor) {
              if (interceptor.request || interceptor.requestError) {
                chain.unshift(interceptor.request, interceptor.requestError);
              }
              if (interceptor.response || interceptor.responseError) {
                chain.push(interceptor.response, interceptor.responseError);
              }
            });
            while (chain.length) {
              var thenFn = chain.shift();
              var rejectFn = chain.shift();
              promise = promise.then(thenFn, rejectFn);
            }
            if (useLegacyPromise) {
              promise.success = function(fn) {
                assertArgFn(fn, 'fn');
                promise.then(function(response) {
                  fn(response.data, response.status, response.headers, config);
                });
                return promise;
              };
              promise.error = function(fn) {
                assertArgFn(fn, 'fn');
                promise.then(null, function(response) {
                  fn(response.data, response.status, response.headers, config);
                });
                return promise;
              };
            } else {
              promise.success = $httpMinErrLegacyFn('success');
              promise.error = $httpMinErrLegacyFn('error');
            }
            return promise;
            function transformResponse(response) {
              var resp = extend({}, response);
              resp.data = transformData(response.data, response.headers, response.status, config.transformResponse);
              return (isSuccess(response.status)) ? resp : $q.reject(resp);
            }
            function executeHeaderFns(headers, config) {
              var headerContent,
                  processedHeaders = {};
              forEach(headers, function(headerFn, header) {
                if (isFunction(headerFn)) {
                  headerContent = headerFn(config);
                  if (headerContent != null) {
                    processedHeaders[header] = headerContent;
                  }
                } else {
                  processedHeaders[header] = headerFn;
                }
              });
              return processedHeaders;
            }
            function mergeHeaders(config) {
              var defHeaders = defaults.headers,
                  reqHeaders = extend({}, config.headers),
                  defHeaderName,
                  lowercaseDefHeaderName,
                  reqHeaderName;
              defHeaders = extend({}, defHeaders.common, defHeaders[lowercase(config.method)]);
              defaultHeadersIteration: for (defHeaderName in defHeaders) {
                lowercaseDefHeaderName = lowercase(defHeaderName);
                for (reqHeaderName in reqHeaders) {
                  if (lowercase(reqHeaderName) === lowercaseDefHeaderName) {
                    continue defaultHeadersIteration;
                  }
                }
                reqHeaders[defHeaderName] = defHeaders[defHeaderName];
              }
              return executeHeaderFns(reqHeaders, shallowCopy(config));
            }
          }
          $http.pendingRequests = [];
          createShortMethods('get', 'delete', 'head', 'jsonp');
          createShortMethodsWithData('post', 'put', 'patch');
          $http.defaults = defaults;
          return $http;
          function createShortMethods(names) {
            forEach(arguments, function(name) {
              $http[name] = function(url, config) {
                return $http(extend({}, config || {}, {
                  method: name,
                  url: url
                }));
              };
            });
          }
          function createShortMethodsWithData(name) {
            forEach(arguments, function(name) {
              $http[name] = function(url, data, config) {
                return $http(extend({}, config || {}, {
                  method: name,
                  url: url,
                  data: data
                }));
              };
            });
          }
          function sendReq(config, reqData) {
            var deferred = $q.defer(),
                promise = deferred.promise,
                cache,
                cachedResp,
                reqHeaders = config.headers,
                url = buildUrl(config.url, config.paramSerializer(config.params));
            $http.pendingRequests.push(config);
            promise.then(removePendingReq, removePendingReq);
            if ((config.cache || defaults.cache) && config.cache !== false && (config.method === 'GET' || config.method === 'JSONP')) {
              cache = isObject(config.cache) ? config.cache : isObject(defaults.cache) ? defaults.cache : defaultCache;
            }
            if (cache) {
              cachedResp = cache.get(url);
              if (isDefined(cachedResp)) {
                if (isPromiseLike(cachedResp)) {
                  cachedResp.then(resolvePromiseWithResult, resolvePromiseWithResult);
                } else {
                  if (isArray(cachedResp)) {
                    resolvePromise(cachedResp[1], cachedResp[0], shallowCopy(cachedResp[2]), cachedResp[3]);
                  } else {
                    resolvePromise(cachedResp, 200, {}, 'OK');
                  }
                }
              } else {
                cache.put(url, promise);
              }
            }
            if (isUndefined(cachedResp)) {
              var xsrfValue = urlIsSameOrigin(config.url) ? $$cookieReader()[config.xsrfCookieName || defaults.xsrfCookieName] : undefined;
              if (xsrfValue) {
                reqHeaders[(config.xsrfHeaderName || defaults.xsrfHeaderName)] = xsrfValue;
              }
              $httpBackend(config.method, url, reqData, done, reqHeaders, config.timeout, config.withCredentials, config.responseType, createApplyHandlers(config.eventHandlers), createApplyHandlers(config.uploadEventHandlers));
            }
            return promise;
            function createApplyHandlers(eventHandlers) {
              if (eventHandlers) {
                var applyHandlers = {};
                forEach(eventHandlers, function(eventHandler, key) {
                  applyHandlers[key] = function(event) {
                    if (useApplyAsync) {
                      $rootScope.$applyAsync(callEventHandler);
                    } else if ($rootScope.$$phase) {
                      callEventHandler();
                    } else {
                      $rootScope.$apply(callEventHandler);
                    }
                    function callEventHandler() {
                      eventHandler(event);
                    }
                  };
                });
                return applyHandlers;
              }
            }
            function done(status, response, headersString, statusText) {
              if (cache) {
                if (isSuccess(status)) {
                  cache.put(url, [status, response, parseHeaders(headersString), statusText]);
                } else {
                  cache.remove(url);
                }
              }
              function resolveHttpPromise() {
                resolvePromise(response, status, headersString, statusText);
              }
              if (useApplyAsync) {
                $rootScope.$applyAsync(resolveHttpPromise);
              } else {
                resolveHttpPromise();
                if (!$rootScope.$$phase)
                  $rootScope.$apply();
              }
            }
            function resolvePromise(response, status, headers, statusText) {
              status = status >= -1 ? status : 0;
              (isSuccess(status) ? deferred.resolve : deferred.reject)({
                data: response,
                status: status,
                headers: headersGetter(headers),
                config: config,
                statusText: statusText
              });
            }
            function resolvePromiseWithResult(result) {
              resolvePromise(result.data, result.status, shallowCopy(result.headers()), result.statusText);
            }
            function removePendingReq() {
              var idx = $http.pendingRequests.indexOf(config);
              if (idx !== -1)
                $http.pendingRequests.splice(idx, 1);
            }
          }
          function buildUrl(url, serializedParams) {
            if (serializedParams.length > 0) {
              url += ((url.indexOf('?') == -1) ? '?' : '&') + serializedParams;
            }
            return url;
          }
        }];
      }
      function $xhrFactoryProvider() {
        this.$get = function() {
          return function createXhr() {
            return new window.XMLHttpRequest();
          };
        };
      }
      function $HttpBackendProvider() {
        this.$get = ['$browser', '$window', '$document', '$xhrFactory', function($browser, $window, $document, $xhrFactory) {
          return createHttpBackend($browser, $xhrFactory, $browser.defer, $window.angular.callbacks, $document[0]);
        }];
      }
      function createHttpBackend($browser, createXhr, $browserDefer, callbacks, rawDocument) {
        return function(method, url, post, callback, headers, timeout, withCredentials, responseType, eventHandlers, uploadEventHandlers) {
          $browser.$$incOutstandingRequestCount();
          url = url || $browser.url();
          if (lowercase(method) == 'jsonp') {
            var callbackId = '_' + (callbacks.counter++).toString(36);
            callbacks[callbackId] = function(data) {
              callbacks[callbackId].data = data;
              callbacks[callbackId].called = true;
            };
            var jsonpDone = jsonpReq(url.replace('JSON_CALLBACK', 'angular.callbacks.' + callbackId), callbackId, function(status, text) {
              completeRequest(callback, status, callbacks[callbackId].data, "", text);
              callbacks[callbackId] = noop;
            });
          } else {
            var xhr = createXhr(method, url);
            xhr.open(method, url, true);
            forEach(headers, function(value, key) {
              if (isDefined(value)) {
                xhr.setRequestHeader(key, value);
              }
            });
            xhr.onload = function requestLoaded() {
              var statusText = xhr.statusText || '';
              var response = ('response' in xhr) ? xhr.response : xhr.responseText;
              var status = xhr.status === 1223 ? 204 : xhr.status;
              if (status === 0) {
                status = response ? 200 : urlResolve(url).protocol == 'file' ? 404 : 0;
              }
              completeRequest(callback, status, response, xhr.getAllResponseHeaders(), statusText);
            };
            var requestError = function() {
              completeRequest(callback, -1, null, null, '');
            };
            xhr.onerror = requestError;
            xhr.onabort = requestError;
            forEach(eventHandlers, function(value, key) {
              xhr.addEventListener(key, value);
            });
            forEach(uploadEventHandlers, function(value, key) {
              xhr.upload.addEventListener(key, value);
            });
            if (withCredentials) {
              xhr.withCredentials = true;
            }
            if (responseType) {
              try {
                xhr.responseType = responseType;
              } catch (e) {
                if (responseType !== 'json') {
                  throw e;
                }
              }
            }
            xhr.send(isUndefined(post) ? null : post);
          }
          if (timeout > 0) {
            var timeoutId = $browserDefer(timeoutRequest, timeout);
          } else if (isPromiseLike(timeout)) {
            timeout.then(timeoutRequest);
          }
          function timeoutRequest() {
            jsonpDone && jsonpDone();
            xhr && xhr.abort();
          }
          function completeRequest(callback, status, response, headersString, statusText) {
            if (isDefined(timeoutId)) {
              $browserDefer.cancel(timeoutId);
            }
            jsonpDone = xhr = null;
            callback(status, response, headersString, statusText);
            $browser.$$completeOutstandingRequest(noop);
          }
        };
        function jsonpReq(url, callbackId, done) {
          var script = rawDocument.createElement('script'),
              callback = null;
          script.type = "text/javascript";
          script.src = url;
          script.async = true;
          callback = function(event) {
            removeEventListenerFn(script, "load", callback);
            removeEventListenerFn(script, "error", callback);
            rawDocument.body.removeChild(script);
            script = null;
            var status = -1;
            var text = "unknown";
            if (event) {
              if (event.type === "load" && !callbacks[callbackId].called) {
                event = {type: "error"};
              }
              text = event.type;
              status = event.type === "error" ? 404 : 200;
            }
            if (done) {
              done(status, text);
            }
          };
          addEventListenerFn(script, "load", callback);
          addEventListenerFn(script, "error", callback);
          rawDocument.body.appendChild(script);
          return callback;
        }
      }
      var $interpolateMinErr = angular.$interpolateMinErr = minErr('$interpolate');
      $interpolateMinErr.throwNoconcat = function(text) {
        throw $interpolateMinErr('noconcat', "Error while interpolating: {0}\nStrict Contextual Escaping disallows " + "interpolations that concatenate multiple expressions when a trusted value is " + "required.  See http://docs.angularjs.org/api/ng.$sce", text);
      };
      $interpolateMinErr.interr = function(text, err) {
        return $interpolateMinErr('interr', "Can't interpolate: {0}\n{1}", text, err.toString());
      };
      function $InterpolateProvider() {
        var startSymbol = '{{';
        var endSymbol = '}}';
        this.startSymbol = function(value) {
          if (value) {
            startSymbol = value;
            return this;
          } else {
            return startSymbol;
          }
        };
        this.endSymbol = function(value) {
          if (value) {
            endSymbol = value;
            return this;
          } else {
            return endSymbol;
          }
        };
        this.$get = ['$parse', '$exceptionHandler', '$sce', function($parse, $exceptionHandler, $sce) {
          var startSymbolLength = startSymbol.length,
              endSymbolLength = endSymbol.length,
              escapedStartRegexp = new RegExp(startSymbol.replace(/./g, escape), 'g'),
              escapedEndRegexp = new RegExp(endSymbol.replace(/./g, escape), 'g');
          function escape(ch) {
            return '\\\\\\' + ch;
          }
          function unescapeText(text) {
            return text.replace(escapedStartRegexp, startSymbol).replace(escapedEndRegexp, endSymbol);
          }
          function stringify(value) {
            if (value == null) {
              return '';
            }
            switch (typeof value) {
              case 'string':
                break;
              case 'number':
                value = '' + value;
                break;
              default:
                value = toJson(value);
            }
            return value;
          }
          function constantWatchDelegate(scope, listener, objectEquality, constantInterp) {
            var unwatch;
            return unwatch = scope.$watch(function constantInterpolateWatch(scope) {
              unwatch();
              return constantInterp(scope);
            }, listener, objectEquality);
          }
          function $interpolate(text, mustHaveExpression, trustedContext, allOrNothing) {
            if (!text.length || text.indexOf(startSymbol) === -1) {
              var constantInterp;
              if (!mustHaveExpression) {
                var unescapedText = unescapeText(text);
                constantInterp = valueFn(unescapedText);
                constantInterp.exp = text;
                constantInterp.expressions = [];
                constantInterp.$$watchDelegate = constantWatchDelegate;
              }
              return constantInterp;
            }
            allOrNothing = !!allOrNothing;
            var startIndex,
                endIndex,
                index = 0,
                expressions = [],
                parseFns = [],
                textLength = text.length,
                exp,
                concat = [],
                expressionPositions = [];
            while (index < textLength) {
              if (((startIndex = text.indexOf(startSymbol, index)) != -1) && ((endIndex = text.indexOf(endSymbol, startIndex + startSymbolLength)) != -1)) {
                if (index !== startIndex) {
                  concat.push(unescapeText(text.substring(index, startIndex)));
                }
                exp = text.substring(startIndex + startSymbolLength, endIndex);
                expressions.push(exp);
                parseFns.push($parse(exp, parseStringifyInterceptor));
                index = endIndex + endSymbolLength;
                expressionPositions.push(concat.length);
                concat.push('');
              } else {
                if (index !== textLength) {
                  concat.push(unescapeText(text.substring(index)));
                }
                break;
              }
            }
            if (trustedContext && concat.length > 1) {
              $interpolateMinErr.throwNoconcat(text);
            }
            if (!mustHaveExpression || expressions.length) {
              var compute = function(values) {
                for (var i = 0,
                    ii = expressions.length; i < ii; i++) {
                  if (allOrNothing && isUndefined(values[i]))
                    return;
                  concat[expressionPositions[i]] = values[i];
                }
                return concat.join('');
              };
              var getValue = function(value) {
                return trustedContext ? $sce.getTrusted(trustedContext, value) : $sce.valueOf(value);
              };
              return extend(function interpolationFn(context) {
                var i = 0;
                var ii = expressions.length;
                var values = new Array(ii);
                try {
                  for (; i < ii; i++) {
                    values[i] = parseFns[i](context);
                  }
                  return compute(values);
                } catch (err) {
                  $exceptionHandler($interpolateMinErr.interr(text, err));
                }
              }, {
                exp: text,
                expressions: expressions,
                $$watchDelegate: function(scope, listener) {
                  var lastValue;
                  return scope.$watchGroup(parseFns, function interpolateFnWatcher(values, oldValues) {
                    var currValue = compute(values);
                    if (isFunction(listener)) {
                      listener.call(this, currValue, values !== oldValues ? lastValue : currValue, scope);
                    }
                    lastValue = currValue;
                  });
                }
              });
            }
            function parseStringifyInterceptor(value) {
              try {
                value = getValue(value);
                return allOrNothing && !isDefined(value) ? value : stringify(value);
              } catch (err) {
                $exceptionHandler($interpolateMinErr.interr(text, err));
              }
            }
          }
          $interpolate.startSymbol = function() {
            return startSymbol;
          };
          $interpolate.endSymbol = function() {
            return endSymbol;
          };
          return $interpolate;
        }];
      }
      function $IntervalProvider() {
        this.$get = ['$rootScope', '$window', '$q', '$$q', '$browser', function($rootScope, $window, $q, $$q, $browser) {
          var intervals = {};
          function interval(fn, delay, count, invokeApply) {
            var hasParams = arguments.length > 4,
                args = hasParams ? sliceArgs(arguments, 4) : [],
                setInterval = $window.setInterval,
                clearInterval = $window.clearInterval,
                iteration = 0,
                skipApply = (isDefined(invokeApply) && !invokeApply),
                deferred = (skipApply ? $$q : $q).defer(),
                promise = deferred.promise;
            count = isDefined(count) ? count : 0;
            promise.$$intervalId = setInterval(function tick() {
              if (skipApply) {
                $browser.defer(callback);
              } else {
                $rootScope.$evalAsync(callback);
              }
              deferred.notify(iteration++);
              if (count > 0 && iteration >= count) {
                deferred.resolve(iteration);
                clearInterval(promise.$$intervalId);
                delete intervals[promise.$$intervalId];
              }
              if (!skipApply)
                $rootScope.$apply();
            }, delay);
            intervals[promise.$$intervalId] = deferred;
            return promise;
            function callback() {
              if (!hasParams) {
                fn(iteration);
              } else {
                fn.apply(null, args);
              }
            }
          }
          interval.cancel = function(promise) {
            if (promise && promise.$$intervalId in intervals) {
              intervals[promise.$$intervalId].reject('canceled');
              $window.clearInterval(promise.$$intervalId);
              delete intervals[promise.$$intervalId];
              return true;
            }
            return false;
          };
          return interval;
        }];
      }
      var PATH_MATCH = /^([^\?#]*)(\?([^#]*))?(#(.*))?$/,
          DEFAULT_PORTS = {
            'http': 80,
            'https': 443,
            'ftp': 21
          };
      var $locationMinErr = minErr('$location');
      function encodePath(path) {
        var segments = path.split('/'),
            i = segments.length;
        while (i--) {
          segments[i] = encodeUriSegment(segments[i]);
        }
        return segments.join('/');
      }
      function parseAbsoluteUrl(absoluteUrl, locationObj) {
        var parsedUrl = urlResolve(absoluteUrl);
        locationObj.$$protocol = parsedUrl.protocol;
        locationObj.$$host = parsedUrl.hostname;
        locationObj.$$port = toInt(parsedUrl.port) || DEFAULT_PORTS[parsedUrl.protocol] || null;
      }
      function parseAppUrl(relativeUrl, locationObj) {
        var prefixed = (relativeUrl.charAt(0) !== '/');
        if (prefixed) {
          relativeUrl = '/' + relativeUrl;
        }
        var match = urlResolve(relativeUrl);
        locationObj.$$path = decodeURIComponent(prefixed && match.pathname.charAt(0) === '/' ? match.pathname.substring(1) : match.pathname);
        locationObj.$$search = parseKeyValue(match.search);
        locationObj.$$hash = decodeURIComponent(match.hash);
        if (locationObj.$$path && locationObj.$$path.charAt(0) != '/') {
          locationObj.$$path = '/' + locationObj.$$path;
        }
      }
      function startsWith(haystack, needle) {
        return haystack.lastIndexOf(needle, 0) === 0;
      }
      function stripBaseUrl(base, url) {
        if (startsWith(url, base)) {
          return url.substr(base.length);
        }
      }
      function stripHash(url) {
        var index = url.indexOf('#');
        return index == -1 ? url : url.substr(0, index);
      }
      function trimEmptyHash(url) {
        return url.replace(/(#.+)|#$/, '$1');
      }
      function stripFile(url) {
        return url.substr(0, stripHash(url).lastIndexOf('/') + 1);
      }
      function serverBase(url) {
        return url.substring(0, url.indexOf('/', url.indexOf('//') + 2));
      }
      function LocationHtml5Url(appBase, appBaseNoFile, basePrefix) {
        this.$$html5 = true;
        basePrefix = basePrefix || '';
        parseAbsoluteUrl(appBase, this);
        this.$$parse = function(url) {
          var pathUrl = stripBaseUrl(appBaseNoFile, url);
          if (!isString(pathUrl)) {
            throw $locationMinErr('ipthprfx', 'Invalid url "{0}", missing path prefix "{1}".', url, appBaseNoFile);
          }
          parseAppUrl(pathUrl, this);
          if (!this.$$path) {
            this.$$path = '/';
          }
          this.$$compose();
        };
        this.$$compose = function() {
          var search = toKeyValue(this.$$search),
              hash = this.$$hash ? '#' + encodeUriSegment(this.$$hash) : '';
          this.$$url = encodePath(this.$$path) + (search ? '?' + search : '') + hash;
          this.$$absUrl = appBaseNoFile + this.$$url.substr(1);
        };
        this.$$parseLinkUrl = function(url, relHref) {
          if (relHref && relHref[0] === '#') {
            this.hash(relHref.slice(1));
            return true;
          }
          var appUrl,
              prevAppUrl;
          var rewrittenUrl;
          if (isDefined(appUrl = stripBaseUrl(appBase, url))) {
            prevAppUrl = appUrl;
            if (isDefined(appUrl = stripBaseUrl(basePrefix, appUrl))) {
              rewrittenUrl = appBaseNoFile + (stripBaseUrl('/', appUrl) || appUrl);
            } else {
              rewrittenUrl = appBase + prevAppUrl;
            }
          } else if (isDefined(appUrl = stripBaseUrl(appBaseNoFile, url))) {
            rewrittenUrl = appBaseNoFile + appUrl;
          } else if (appBaseNoFile == url + '/') {
            rewrittenUrl = appBaseNoFile;
          }
          if (rewrittenUrl) {
            this.$$parse(rewrittenUrl);
          }
          return !!rewrittenUrl;
        };
      }
      function LocationHashbangUrl(appBase, appBaseNoFile, hashPrefix) {
        parseAbsoluteUrl(appBase, this);
        this.$$parse = function(url) {
          var withoutBaseUrl = stripBaseUrl(appBase, url) || stripBaseUrl(appBaseNoFile, url);
          var withoutHashUrl;
          if (!isUndefined(withoutBaseUrl) && withoutBaseUrl.charAt(0) === '#') {
            withoutHashUrl = stripBaseUrl(hashPrefix, withoutBaseUrl);
            if (isUndefined(withoutHashUrl)) {
              withoutHashUrl = withoutBaseUrl;
            }
          } else {
            if (this.$$html5) {
              withoutHashUrl = withoutBaseUrl;
            } else {
              withoutHashUrl = '';
              if (isUndefined(withoutBaseUrl)) {
                appBase = url;
                this.replace();
              }
            }
          }
          parseAppUrl(withoutHashUrl, this);
          this.$$path = removeWindowsDriveName(this.$$path, withoutHashUrl, appBase);
          this.$$compose();
          function removeWindowsDriveName(path, url, base) {
            var windowsFilePathExp = /^\/[A-Z]:(\/.*)/;
            var firstPathSegmentMatch;
            if (startsWith(url, base)) {
              url = url.replace(base, '');
            }
            if (windowsFilePathExp.exec(url)) {
              return path;
            }
            firstPathSegmentMatch = windowsFilePathExp.exec(path);
            return firstPathSegmentMatch ? firstPathSegmentMatch[1] : path;
          }
        };
        this.$$compose = function() {
          var search = toKeyValue(this.$$search),
              hash = this.$$hash ? '#' + encodeUriSegment(this.$$hash) : '';
          this.$$url = encodePath(this.$$path) + (search ? '?' + search : '') + hash;
          this.$$absUrl = appBase + (this.$$url ? hashPrefix + this.$$url : '');
        };
        this.$$parseLinkUrl = function(url, relHref) {
          if (stripHash(appBase) == stripHash(url)) {
            this.$$parse(url);
            return true;
          }
          return false;
        };
      }
      function LocationHashbangInHtml5Url(appBase, appBaseNoFile, hashPrefix) {
        this.$$html5 = true;
        LocationHashbangUrl.apply(this, arguments);
        this.$$parseLinkUrl = function(url, relHref) {
          if (relHref && relHref[0] === '#') {
            this.hash(relHref.slice(1));
            return true;
          }
          var rewrittenUrl;
          var appUrl;
          if (appBase == stripHash(url)) {
            rewrittenUrl = url;
          } else if ((appUrl = stripBaseUrl(appBaseNoFile, url))) {
            rewrittenUrl = appBase + hashPrefix + appUrl;
          } else if (appBaseNoFile === url + '/') {
            rewrittenUrl = appBaseNoFile;
          }
          if (rewrittenUrl) {
            this.$$parse(rewrittenUrl);
          }
          return !!rewrittenUrl;
        };
        this.$$compose = function() {
          var search = toKeyValue(this.$$search),
              hash = this.$$hash ? '#' + encodeUriSegment(this.$$hash) : '';
          this.$$url = encodePath(this.$$path) + (search ? '?' + search : '') + hash;
          this.$$absUrl = appBase + hashPrefix + this.$$url;
        };
      }
      var locationPrototype = {
        $$absUrl: '',
        $$html5: false,
        $$replace: false,
        absUrl: locationGetter('$$absUrl'),
        url: function(url) {
          if (isUndefined(url)) {
            return this.$$url;
          }
          var match = PATH_MATCH.exec(url);
          if (match[1] || url === '')
            this.path(decodeURIComponent(match[1]));
          if (match[2] || match[1] || url === '')
            this.search(match[3] || '');
          this.hash(match[5] || '');
          return this;
        },
        protocol: locationGetter('$$protocol'),
        host: locationGetter('$$host'),
        port: locationGetter('$$port'),
        path: locationGetterSetter('$$path', function(path) {
          path = path !== null ? path.toString() : '';
          return path.charAt(0) == '/' ? path : '/' + path;
        }),
        search: function(search, paramValue) {
          switch (arguments.length) {
            case 0:
              return this.$$search;
            case 1:
              if (isString(search) || isNumber(search)) {
                search = search.toString();
                this.$$search = parseKeyValue(search);
              } else if (isObject(search)) {
                search = copy(search, {});
                forEach(search, function(value, key) {
                  if (value == null)
                    delete search[key];
                });
                this.$$search = search;
              } else {
                throw $locationMinErr('isrcharg', 'The first argument of the `$location#search()` call must be a string or an object.');
              }
              break;
            default:
              if (isUndefined(paramValue) || paramValue === null) {
                delete this.$$search[search];
              } else {
                this.$$search[search] = paramValue;
              }
          }
          this.$$compose();
          return this;
        },
        hash: locationGetterSetter('$$hash', function(hash) {
          return hash !== null ? hash.toString() : '';
        }),
        replace: function() {
          this.$$replace = true;
          return this;
        }
      };
      forEach([LocationHashbangInHtml5Url, LocationHashbangUrl, LocationHtml5Url], function(Location) {
        Location.prototype = Object.create(locationPrototype);
        Location.prototype.state = function(state) {
          if (!arguments.length) {
            return this.$$state;
          }
          if (Location !== LocationHtml5Url || !this.$$html5) {
            throw $locationMinErr('nostate', 'History API state support is available only ' + 'in HTML5 mode and only in browsers supporting HTML5 History API');
          }
          this.$$state = isUndefined(state) ? null : state;
          return this;
        };
      });
      function locationGetter(property) {
        return function() {
          return this[property];
        };
      }
      function locationGetterSetter(property, preprocess) {
        return function(value) {
          if (isUndefined(value)) {
            return this[property];
          }
          this[property] = preprocess(value);
          this.$$compose();
          return this;
        };
      }
      function $LocationProvider() {
        var hashPrefix = '',
            html5Mode = {
              enabled: false,
              requireBase: true,
              rewriteLinks: true
            };
        this.hashPrefix = function(prefix) {
          if (isDefined(prefix)) {
            hashPrefix = prefix;
            return this;
          } else {
            return hashPrefix;
          }
        };
        this.html5Mode = function(mode) {
          if (isBoolean(mode)) {
            html5Mode.enabled = mode;
            return this;
          } else if (isObject(mode)) {
            if (isBoolean(mode.enabled)) {
              html5Mode.enabled = mode.enabled;
            }
            if (isBoolean(mode.requireBase)) {
              html5Mode.requireBase = mode.requireBase;
            }
            if (isBoolean(mode.rewriteLinks)) {
              html5Mode.rewriteLinks = mode.rewriteLinks;
            }
            return this;
          } else {
            return html5Mode;
          }
        };
        this.$get = ['$rootScope', '$browser', '$sniffer', '$rootElement', '$window', function($rootScope, $browser, $sniffer, $rootElement, $window) {
          var $location,
              LocationMode,
              baseHref = $browser.baseHref(),
              initialUrl = $browser.url(),
              appBase;
          if (html5Mode.enabled) {
            if (!baseHref && html5Mode.requireBase) {
              throw $locationMinErr('nobase', "$location in HTML5 mode requires a <base> tag to be present!");
            }
            appBase = serverBase(initialUrl) + (baseHref || '/');
            LocationMode = $sniffer.history ? LocationHtml5Url : LocationHashbangInHtml5Url;
          } else {
            appBase = stripHash(initialUrl);
            LocationMode = LocationHashbangUrl;
          }
          var appBaseNoFile = stripFile(appBase);
          $location = new LocationMode(appBase, appBaseNoFile, '#' + hashPrefix);
          $location.$$parseLinkUrl(initialUrl, initialUrl);
          $location.$$state = $browser.state();
          var IGNORE_URI_REGEXP = /^\s*(javascript|mailto):/i;
          function setBrowserUrlWithFallback(url, replace, state) {
            var oldUrl = $location.url();
            var oldState = $location.$$state;
            try {
              $browser.url(url, replace, state);
              $location.$$state = $browser.state();
            } catch (e) {
              $location.url(oldUrl);
              $location.$$state = oldState;
              throw e;
            }
          }
          $rootElement.on('click', function(event) {
            if (!html5Mode.rewriteLinks || event.ctrlKey || event.metaKey || event.shiftKey || event.which == 2 || event.button == 2)
              return;
            var elm = jqLite(event.target);
            while (nodeName_(elm[0]) !== 'a') {
              if (elm[0] === $rootElement[0] || !(elm = elm.parent())[0])
                return;
            }
            var absHref = elm.prop('href');
            var relHref = elm.attr('href') || elm.attr('xlink:href');
            if (isObject(absHref) && absHref.toString() === '[object SVGAnimatedString]') {
              absHref = urlResolve(absHref.animVal).href;
            }
            if (IGNORE_URI_REGEXP.test(absHref))
              return;
            if (absHref && !elm.attr('target') && !event.isDefaultPrevented()) {
              if ($location.$$parseLinkUrl(absHref, relHref)) {
                event.preventDefault();
                if ($location.absUrl() != $browser.url()) {
                  $rootScope.$apply();
                  $window.angular['ff-684208-preventDefault'] = true;
                }
              }
            }
          });
          if (trimEmptyHash($location.absUrl()) != trimEmptyHash(initialUrl)) {
            $browser.url($location.absUrl(), true);
          }
          var initializing = true;
          $browser.onUrlChange(function(newUrl, newState) {
            if (isUndefined(stripBaseUrl(appBaseNoFile, newUrl))) {
              $window.location.href = newUrl;
              return;
            }
            $rootScope.$evalAsync(function() {
              var oldUrl = $location.absUrl();
              var oldState = $location.$$state;
              var defaultPrevented;
              newUrl = trimEmptyHash(newUrl);
              $location.$$parse(newUrl);
              $location.$$state = newState;
              defaultPrevented = $rootScope.$broadcast('$locationChangeStart', newUrl, oldUrl, newState, oldState).defaultPrevented;
              if ($location.absUrl() !== newUrl)
                return;
              if (defaultPrevented) {
                $location.$$parse(oldUrl);
                $location.$$state = oldState;
                setBrowserUrlWithFallback(oldUrl, false, oldState);
              } else {
                initializing = false;
                afterLocationChange(oldUrl, oldState);
              }
            });
            if (!$rootScope.$$phase)
              $rootScope.$digest();
          });
          $rootScope.$watch(function $locationWatch() {
            var oldUrl = trimEmptyHash($browser.url());
            var newUrl = trimEmptyHash($location.absUrl());
            var oldState = $browser.state();
            var currentReplace = $location.$$replace;
            var urlOrStateChanged = oldUrl !== newUrl || ($location.$$html5 && $sniffer.history && oldState !== $location.$$state);
            if (initializing || urlOrStateChanged) {
              initializing = false;
              $rootScope.$evalAsync(function() {
                var newUrl = $location.absUrl();
                var defaultPrevented = $rootScope.$broadcast('$locationChangeStart', newUrl, oldUrl, $location.$$state, oldState).defaultPrevented;
                if ($location.absUrl() !== newUrl)
                  return;
                if (defaultPrevented) {
                  $location.$$parse(oldUrl);
                  $location.$$state = oldState;
                } else {
                  if (urlOrStateChanged) {
                    setBrowserUrlWithFallback(newUrl, currentReplace, oldState === $location.$$state ? null : $location.$$state);
                  }
                  afterLocationChange(oldUrl, oldState);
                }
              });
            }
            $location.$$replace = false;
          });
          return $location;
          function afterLocationChange(oldUrl, oldState) {
            $rootScope.$broadcast('$locationChangeSuccess', $location.absUrl(), oldUrl, $location.$$state, oldState);
          }
        }];
      }
      function $LogProvider() {
        var debug = true,
            self = this;
        this.debugEnabled = function(flag) {
          if (isDefined(flag)) {
            debug = flag;
            return this;
          } else {
            return debug;
          }
        };
        this.$get = ['$window', function($window) {
          return {
            log: consoleLog('log'),
            info: consoleLog('info'),
            warn: consoleLog('warn'),
            error: consoleLog('error'),
            debug: (function() {
              var fn = consoleLog('debug');
              return function() {
                if (debug) {
                  fn.apply(self, arguments);
                }
              };
            }())
          };
          function formatError(arg) {
            if (arg instanceof Error) {
              if (arg.stack) {
                arg = (arg.message && arg.stack.indexOf(arg.message) === -1) ? 'Error: ' + arg.message + '\n' + arg.stack : arg.stack;
              } else if (arg.sourceURL) {
                arg = arg.message + '\n' + arg.sourceURL + ':' + arg.line;
              }
            }
            return arg;
          }
          function consoleLog(type) {
            var console = $window.console || {},
                logFn = console[type] || console.log || noop,
                hasApply = false;
            try {
              hasApply = !!logFn.apply;
            } catch (e) {}
            if (hasApply) {
              return function() {
                var args = [];
                forEach(arguments, function(arg) {
                  args.push(formatError(arg));
                });
                return logFn.apply(console, args);
              };
            }
            return function(arg1, arg2) {
              logFn(arg1, arg2 == null ? '' : arg2);
            };
          }
        }];
      }
      var $parseMinErr = minErr('$parse');
      function ensureSafeMemberName(name, fullExpression) {
        if (name === "__defineGetter__" || name === "__defineSetter__" || name === "__lookupGetter__" || name === "__lookupSetter__" || name === "__proto__") {
          throw $parseMinErr('isecfld', 'Attempting to access a disallowed field in Angular expressions! ' + 'Expression: {0}', fullExpression);
        }
        return name;
      }
      function getStringValue(name) {
        return name + '';
      }
      function ensureSafeObject(obj, fullExpression) {
        if (obj) {
          if (obj.constructor === obj) {
            throw $parseMinErr('isecfn', 'Referencing Function in Angular expressions is disallowed! Expression: {0}', fullExpression);
          } else if (obj.window === obj) {
            throw $parseMinErr('isecwindow', 'Referencing the Window in Angular expressions is disallowed! Expression: {0}', fullExpression);
          } else if (obj.children && (obj.nodeName || (obj.prop && obj.attr && obj.find))) {
            throw $parseMinErr('isecdom', 'Referencing DOM nodes in Angular expressions is disallowed! Expression: {0}', fullExpression);
          } else if (obj === Object) {
            throw $parseMinErr('isecobj', 'Referencing Object in Angular expressions is disallowed! Expression: {0}', fullExpression);
          }
        }
        return obj;
      }
      var CALL = Function.prototype.call;
      var APPLY = Function.prototype.apply;
      var BIND = Function.prototype.bind;
      function ensureSafeFunction(obj, fullExpression) {
        if (obj) {
          if (obj.constructor === obj) {
            throw $parseMinErr('isecfn', 'Referencing Function in Angular expressions is disallowed! Expression: {0}', fullExpression);
          } else if (obj === CALL || obj === APPLY || obj === BIND) {
            throw $parseMinErr('isecff', 'Referencing call, apply or bind in Angular expressions is disallowed! Expression: {0}', fullExpression);
          }
        }
      }
      function ensureSafeAssignContext(obj, fullExpression) {
        if (obj) {
          if (obj === (0).constructor || obj === (false).constructor || obj === ''.constructor || obj === {}.constructor || obj === [].constructor || obj === Function.constructor) {
            throw $parseMinErr('isecaf', 'Assigning to a constructor is disallowed! Expression: {0}', fullExpression);
          }
        }
      }
      var OPERATORS = createMap();
      forEach('+ - * / % === !== == != < > <= >= && || ! = |'.split(' '), function(operator) {
        OPERATORS[operator] = true;
      });
      var ESCAPE = {
        "n": "\n",
        "f": "\f",
        "r": "\r",
        "t": "\t",
        "v": "\v",
        "'": "'",
        '"': '"'
      };
      var Lexer = function(options) {
        this.options = options;
      };
      Lexer.prototype = {
        constructor: Lexer,
        lex: function(text) {
          this.text = text;
          this.index = 0;
          this.tokens = [];
          while (this.index < this.text.length) {
            var ch = this.text.charAt(this.index);
            if (ch === '"' || ch === "'") {
              this.readString(ch);
            } else if (this.isNumber(ch) || ch === '.' && this.isNumber(this.peek())) {
              this.readNumber();
            } else if (this.isIdentifierStart(this.peekMultichar())) {
              this.readIdent();
            } else if (this.is(ch, '(){}[].,;:?')) {
              this.tokens.push({
                index: this.index,
                text: ch
              });
              this.index++;
            } else if (this.isWhitespace(ch)) {
              this.index++;
            } else {
              var ch2 = ch + this.peek();
              var ch3 = ch2 + this.peek(2);
              var op1 = OPERATORS[ch];
              var op2 = OPERATORS[ch2];
              var op3 = OPERATORS[ch3];
              if (op1 || op2 || op3) {
                var token = op3 ? ch3 : (op2 ? ch2 : ch);
                this.tokens.push({
                  index: this.index,
                  text: token,
                  operator: true
                });
                this.index += token.length;
              } else {
                this.throwError('Unexpected next character ', this.index, this.index + 1);
              }
            }
          }
          return this.tokens;
        },
        is: function(ch, chars) {
          return chars.indexOf(ch) !== -1;
        },
        peek: function(i) {
          var num = i || 1;
          return (this.index + num < this.text.length) ? this.text.charAt(this.index + num) : false;
        },
        isNumber: function(ch) {
          return ('0' <= ch && ch <= '9') && typeof ch === "string";
        },
        isWhitespace: function(ch) {
          return (ch === ' ' || ch === '\r' || ch === '\t' || ch === '\n' || ch === '\v' || ch === '\u00A0');
        },
        isIdentifierStart: function(ch) {
          return this.options.isIdentifierStart ? this.options.isIdentifierStart(ch, this.codePointAt(ch)) : this.isValidIdentifierStart(ch);
        },
        isValidIdentifierStart: function(ch) {
          return ('a' <= ch && ch <= 'z' || 'A' <= ch && ch <= 'Z' || '_' === ch || ch === '$');
        },
        isIdentifierContinue: function(ch) {
          return this.options.isIdentifierContinue ? this.options.isIdentifierContinue(ch, this.codePointAt(ch)) : this.isValidIdentifierContinue(ch);
        },
        isValidIdentifierContinue: function(ch, cp) {
          return this.isValidIdentifierStart(ch, cp) || this.isNumber(ch);
        },
        codePointAt: function(ch) {
          if (ch.length === 1)
            return ch.charCodeAt(0);
          return (ch.charCodeAt(0) << 10) + ch.charCodeAt(1) - 0x35FDC00;
        },
        peekMultichar: function() {
          var ch = this.text.charAt(this.index);
          var peek = this.peek();
          if (!peek) {
            return ch;
          }
          var cp1 = ch.charCodeAt(0);
          var cp2 = peek.charCodeAt(0);
          if (cp1 >= 0xD800 && cp1 <= 0xDBFF && cp2 >= 0xDC00 && cp2 <= 0xDFFF) {
            return ch + peek;
          }
          return ch;
        },
        isExpOperator: function(ch) {
          return (ch === '-' || ch === '+' || this.isNumber(ch));
        },
        throwError: function(error, start, end) {
          end = end || this.index;
          var colStr = (isDefined(start) ? 's ' + start + '-' + this.index + ' [' + this.text.substring(start, end) + ']' : ' ' + end);
          throw $parseMinErr('lexerr', 'Lexer Error: {0} at column{1} in expression [{2}].', error, colStr, this.text);
        },
        readNumber: function() {
          var number = '';
          var start = this.index;
          while (this.index < this.text.length) {
            var ch = lowercase(this.text.charAt(this.index));
            if (ch == '.' || this.isNumber(ch)) {
              number += ch;
            } else {
              var peekCh = this.peek();
              if (ch == 'e' && this.isExpOperator(peekCh)) {
                number += ch;
              } else if (this.isExpOperator(ch) && peekCh && this.isNumber(peekCh) && number.charAt(number.length - 1) == 'e') {
                number += ch;
              } else if (this.isExpOperator(ch) && (!peekCh || !this.isNumber(peekCh)) && number.charAt(number.length - 1) == 'e') {
                this.throwError('Invalid exponent');
              } else {
                break;
              }
            }
            this.index++;
          }
          this.tokens.push({
            index: start,
            text: number,
            constant: true,
            value: Number(number)
          });
        },
        readIdent: function() {
          var start = this.index;
          this.index += this.peekMultichar().length;
          while (this.index < this.text.length) {
            var ch = this.peekMultichar();
            if (!this.isIdentifierContinue(ch)) {
              break;
            }
            this.index += ch.length;
          }
          this.tokens.push({
            index: start,
            text: this.text.slice(start, this.index),
            identifier: true
          });
        },
        readString: function(quote) {
          var start = this.index;
          this.index++;
          var string = '';
          var rawString = quote;
          var escape = false;
          while (this.index < this.text.length) {
            var ch = this.text.charAt(this.index);
            rawString += ch;
            if (escape) {
              if (ch === 'u') {
                var hex = this.text.substring(this.index + 1, this.index + 5);
                if (!hex.match(/[\da-f]{4}/i)) {
                  this.throwError('Invalid unicode escape [\\u' + hex + ']');
                }
                this.index += 4;
                string += String.fromCharCode(parseInt(hex, 16));
              } else {
                var rep = ESCAPE[ch];
                string = string + (rep || ch);
              }
              escape = false;
            } else if (ch === '\\') {
              escape = true;
            } else if (ch === quote) {
              this.index++;
              this.tokens.push({
                index: start,
                text: rawString,
                constant: true,
                value: string
              });
              return;
            } else {
              string += ch;
            }
            this.index++;
          }
          this.throwError('Unterminated quote', start);
        }
      };
      var AST = function(lexer, options) {
        this.lexer = lexer;
        this.options = options;
      };
      AST.Program = 'Program';
      AST.ExpressionStatement = 'ExpressionStatement';
      AST.AssignmentExpression = 'AssignmentExpression';
      AST.ConditionalExpression = 'ConditionalExpression';
      AST.LogicalExpression = 'LogicalExpression';
      AST.BinaryExpression = 'BinaryExpression';
      AST.UnaryExpression = 'UnaryExpression';
      AST.CallExpression = 'CallExpression';
      AST.MemberExpression = 'MemberExpression';
      AST.Identifier = 'Identifier';
      AST.Literal = 'Literal';
      AST.ArrayExpression = 'ArrayExpression';
      AST.Property = 'Property';
      AST.ObjectExpression = 'ObjectExpression';
      AST.ThisExpression = 'ThisExpression';
      AST.LocalsExpression = 'LocalsExpression';
      AST.NGValueParameter = 'NGValueParameter';
      AST.prototype = {
        ast: function(text) {
          this.text = text;
          this.tokens = this.lexer.lex(text);
          var value = this.program();
          if (this.tokens.length !== 0) {
            this.throwError('is an unexpected token', this.tokens[0]);
          }
          return value;
        },
        program: function() {
          var body = [];
          while (true) {
            if (this.tokens.length > 0 && !this.peek('}', ')', ';', ']'))
              body.push(this.expressionStatement());
            if (!this.expect(';')) {
              return {
                type: AST.Program,
                body: body
              };
            }
          }
        },
        expressionStatement: function() {
          return {
            type: AST.ExpressionStatement,
            expression: this.filterChain()
          };
        },
        filterChain: function() {
          var left = this.expression();
          var token;
          while ((token = this.expect('|'))) {
            left = this.filter(left);
          }
          return left;
        },
        expression: function() {
          return this.assignment();
        },
        assignment: function() {
          var result = this.ternary();
          if (this.expect('=')) {
            result = {
              type: AST.AssignmentExpression,
              left: result,
              right: this.assignment(),
              operator: '='
            };
          }
          return result;
        },
        ternary: function() {
          var test = this.logicalOR();
          var alternate;
          var consequent;
          if (this.expect('?')) {
            alternate = this.expression();
            if (this.consume(':')) {
              consequent = this.expression();
              return {
                type: AST.ConditionalExpression,
                test: test,
                alternate: alternate,
                consequent: consequent
              };
            }
          }
          return test;
        },
        logicalOR: function() {
          var left = this.logicalAND();
          while (this.expect('||')) {
            left = {
              type: AST.LogicalExpression,
              operator: '||',
              left: left,
              right: this.logicalAND()
            };
          }
          return left;
        },
        logicalAND: function() {
          var left = this.equality();
          while (this.expect('&&')) {
            left = {
              type: AST.LogicalExpression,
              operator: '&&',
              left: left,
              right: this.equality()
            };
          }
          return left;
        },
        equality: function() {
          var left = this.relational();
          var token;
          while ((token = this.expect('==', '!=', '===', '!=='))) {
            left = {
              type: AST.BinaryExpression,
              operator: token.text,
              left: left,
              right: this.relational()
            };
          }
          return left;
        },
        relational: function() {
          var left = this.additive();
          var token;
          while ((token = this.expect('<', '>', '<=', '>='))) {
            left = {
              type: AST.BinaryExpression,
              operator: token.text,
              left: left,
              right: this.additive()
            };
          }
          return left;
        },
        additive: function() {
          var left = this.multiplicative();
          var token;
          while ((token = this.expect('+', '-'))) {
            left = {
              type: AST.BinaryExpression,
              operator: token.text,
              left: left,
              right: this.multiplicative()
            };
          }
          return left;
        },
        multiplicative: function() {
          var left = this.unary();
          var token;
          while ((token = this.expect('*', '/', '%'))) {
            left = {
              type: AST.BinaryExpression,
              operator: token.text,
              left: left,
              right: this.unary()
            };
          }
          return left;
        },
        unary: function() {
          var token;
          if ((token = this.expect('+', '-', '!'))) {
            return {
              type: AST.UnaryExpression,
              operator: token.text,
              prefix: true,
              argument: this.unary()
            };
          } else {
            return this.primary();
          }
        },
        primary: function() {
          var primary;
          if (this.expect('(')) {
            primary = this.filterChain();
            this.consume(')');
          } else if (this.expect('[')) {
            primary = this.arrayDeclaration();
          } else if (this.expect('{')) {
            primary = this.object();
          } else if (this.selfReferential.hasOwnProperty(this.peek().text)) {
            primary = copy(this.selfReferential[this.consume().text]);
          } else if (this.options.literals.hasOwnProperty(this.peek().text)) {
            primary = {
              type: AST.Literal,
              value: this.options.literals[this.consume().text]
            };
          } else if (this.peek().identifier) {
            primary = this.identifier();
          } else if (this.peek().constant) {
            primary = this.constant();
          } else {
            this.throwError('not a primary expression', this.peek());
          }
          var next;
          while ((next = this.expect('(', '[', '.'))) {
            if (next.text === '(') {
              primary = {
                type: AST.CallExpression,
                callee: primary,
                arguments: this.parseArguments()
              };
              this.consume(')');
            } else if (next.text === '[') {
              primary = {
                type: AST.MemberExpression,
                object: primary,
                property: this.expression(),
                computed: true
              };
              this.consume(']');
            } else if (next.text === '.') {
              primary = {
                type: AST.MemberExpression,
                object: primary,
                property: this.identifier(),
                computed: false
              };
            } else {
              this.throwError('IMPOSSIBLE');
            }
          }
          return primary;
        },
        filter: function(baseExpression) {
          var args = [baseExpression];
          var result = {
            type: AST.CallExpression,
            callee: this.identifier(),
            arguments: args,
            filter: true
          };
          while (this.expect(':')) {
            args.push(this.expression());
          }
          return result;
        },
        parseArguments: function() {
          var args = [];
          if (this.peekToken().text !== ')') {
            do {
              args.push(this.filterChain());
            } while (this.expect(','));
          }
          return args;
        },
        identifier: function() {
          var token = this.consume();
          if (!token.identifier) {
            this.throwError('is not a valid identifier', token);
          }
          return {
            type: AST.Identifier,
            name: token.text
          };
        },
        constant: function() {
          return {
            type: AST.Literal,
            value: this.consume().value
          };
        },
        arrayDeclaration: function() {
          var elements = [];
          if (this.peekToken().text !== ']') {
            do {
              if (this.peek(']')) {
                break;
              }
              elements.push(this.expression());
            } while (this.expect(','));
          }
          this.consume(']');
          return {
            type: AST.ArrayExpression,
            elements: elements
          };
        },
        object: function() {
          var properties = [],
              property;
          if (this.peekToken().text !== '}') {
            do {
              if (this.peek('}')) {
                break;
              }
              property = {
                type: AST.Property,
                kind: 'init'
              };
              if (this.peek().constant) {
                property.key = this.constant();
                property.computed = false;
                this.consume(':');
                property.value = this.expression();
              } else if (this.peek().identifier) {
                property.key = this.identifier();
                property.computed = false;
                if (this.peek(':')) {
                  this.consume(':');
                  property.value = this.expression();
                } else {
                  property.value = property.key;
                }
              } else if (this.peek('[')) {
                this.consume('[');
                property.key = this.expression();
                this.consume(']');
                property.computed = true;
                this.consume(':');
                property.value = this.expression();
              } else {
                this.throwError("invalid key", this.peek());
              }
              properties.push(property);
            } while (this.expect(','));
          }
          this.consume('}');
          return {
            type: AST.ObjectExpression,
            properties: properties
          };
        },
        throwError: function(msg, token) {
          throw $parseMinErr('syntax', 'Syntax Error: Token \'{0}\' {1} at column {2} of the expression [{3}] starting at [{4}].', token.text, msg, (token.index + 1), this.text, this.text.substring(token.index));
        },
        consume: function(e1) {
          if (this.tokens.length === 0) {
            throw $parseMinErr('ueoe', 'Unexpected end of expression: {0}', this.text);
          }
          var token = this.expect(e1);
          if (!token) {
            this.throwError('is unexpected, expecting [' + e1 + ']', this.peek());
          }
          return token;
        },
        peekToken: function() {
          if (this.tokens.length === 0) {
            throw $parseMinErr('ueoe', 'Unexpected end of expression: {0}', this.text);
          }
          return this.tokens[0];
        },
        peek: function(e1, e2, e3, e4) {
          return this.peekAhead(0, e1, e2, e3, e4);
        },
        peekAhead: function(i, e1, e2, e3, e4) {
          if (this.tokens.length > i) {
            var token = this.tokens[i];
            var t = token.text;
            if (t === e1 || t === e2 || t === e3 || t === e4 || (!e1 && !e2 && !e3 && !e4)) {
              return token;
            }
          }
          return false;
        },
        expect: function(e1, e2, e3, e4) {
          var token = this.peek(e1, e2, e3, e4);
          if (token) {
            this.tokens.shift();
            return token;
          }
          return false;
        },
        selfReferential: {
          'this': {type: AST.ThisExpression},
          '$locals': {type: AST.LocalsExpression}
        }
      };
      function ifDefined(v, d) {
        return typeof v !== 'undefined' ? v : d;
      }
      function plusFn(l, r) {
        if (typeof l === 'undefined')
          return r;
        if (typeof r === 'undefined')
          return l;
        return l + r;
      }
      function isStateless($filter, filterName) {
        var fn = $filter(filterName);
        return !fn.$stateful;
      }
      function findConstantAndWatchExpressions(ast, $filter) {
        var allConstants;
        var argsToWatch;
        switch (ast.type) {
          case AST.Program:
            allConstants = true;
            forEach(ast.body, function(expr) {
              findConstantAndWatchExpressions(expr.expression, $filter);
              allConstants = allConstants && expr.expression.constant;
            });
            ast.constant = allConstants;
            break;
          case AST.Literal:
            ast.constant = true;
            ast.toWatch = [];
            break;
          case AST.UnaryExpression:
            findConstantAndWatchExpressions(ast.argument, $filter);
            ast.constant = ast.argument.constant;
            ast.toWatch = ast.argument.toWatch;
            break;
          case AST.BinaryExpression:
            findConstantAndWatchExpressions(ast.left, $filter);
            findConstantAndWatchExpressions(ast.right, $filter);
            ast.constant = ast.left.constant && ast.right.constant;
            ast.toWatch = ast.left.toWatch.concat(ast.right.toWatch);
            break;
          case AST.LogicalExpression:
            findConstantAndWatchExpressions(ast.left, $filter);
            findConstantAndWatchExpressions(ast.right, $filter);
            ast.constant = ast.left.constant && ast.right.constant;
            ast.toWatch = ast.constant ? [] : [ast];
            break;
          case AST.ConditionalExpression:
            findConstantAndWatchExpressions(ast.test, $filter);
            findConstantAndWatchExpressions(ast.alternate, $filter);
            findConstantAndWatchExpressions(ast.consequent, $filter);
            ast.constant = ast.test.constant && ast.alternate.constant && ast.consequent.constant;
            ast.toWatch = ast.constant ? [] : [ast];
            break;
          case AST.Identifier:
            ast.constant = false;
            ast.toWatch = [ast];
            break;
          case AST.MemberExpression:
            findConstantAndWatchExpressions(ast.object, $filter);
            if (ast.computed) {
              findConstantAndWatchExpressions(ast.property, $filter);
            }
            ast.constant = ast.object.constant && (!ast.computed || ast.property.constant);
            ast.toWatch = [ast];
            break;
          case AST.CallExpression:
            allConstants = ast.filter ? isStateless($filter, ast.callee.name) : false;
            argsToWatch = [];
            forEach(ast.arguments, function(expr) {
              findConstantAndWatchExpressions(expr, $filter);
              allConstants = allConstants && expr.constant;
              if (!expr.constant) {
                argsToWatch.push.apply(argsToWatch, expr.toWatch);
              }
            });
            ast.constant = allConstants;
            ast.toWatch = ast.filter && isStateless($filter, ast.callee.name) ? argsToWatch : [ast];
            break;
          case AST.AssignmentExpression:
            findConstantAndWatchExpressions(ast.left, $filter);
            findConstantAndWatchExpressions(ast.right, $filter);
            ast.constant = ast.left.constant && ast.right.constant;
            ast.toWatch = [ast];
            break;
          case AST.ArrayExpression:
            allConstants = true;
            argsToWatch = [];
            forEach(ast.elements, function(expr) {
              findConstantAndWatchExpressions(expr, $filter);
              allConstants = allConstants && expr.constant;
              if (!expr.constant) {
                argsToWatch.push.apply(argsToWatch, expr.toWatch);
              }
            });
            ast.constant = allConstants;
            ast.toWatch = argsToWatch;
            break;
          case AST.ObjectExpression:
            allConstants = true;
            argsToWatch = [];
            forEach(ast.properties, function(property) {
              findConstantAndWatchExpressions(property.value, $filter);
              allConstants = allConstants && property.value.constant && !property.computed;
              if (!property.value.constant) {
                argsToWatch.push.apply(argsToWatch, property.value.toWatch);
              }
            });
            ast.constant = allConstants;
            ast.toWatch = argsToWatch;
            break;
          case AST.ThisExpression:
            ast.constant = false;
            ast.toWatch = [];
            break;
          case AST.LocalsExpression:
            ast.constant = false;
            ast.toWatch = [];
            break;
        }
      }
      function getInputs(body) {
        if (body.length != 1)
          return;
        var lastExpression = body[0].expression;
        var candidate = lastExpression.toWatch;
        if (candidate.length !== 1)
          return candidate;
        return candidate[0] !== lastExpression ? candidate : undefined;
      }
      function isAssignable(ast) {
        return ast.type === AST.Identifier || ast.type === AST.MemberExpression;
      }
      function assignableAST(ast) {
        if (ast.body.length === 1 && isAssignable(ast.body[0].expression)) {
          return {
            type: AST.AssignmentExpression,
            left: ast.body[0].expression,
            right: {type: AST.NGValueParameter},
            operator: '='
          };
        }
      }
      function isLiteral(ast) {
        return ast.body.length === 0 || ast.body.length === 1 && (ast.body[0].expression.type === AST.Literal || ast.body[0].expression.type === AST.ArrayExpression || ast.body[0].expression.type === AST.ObjectExpression);
      }
      function isConstant(ast) {
        return ast.constant;
      }
      function ASTCompiler(astBuilder, $filter) {
        this.astBuilder = astBuilder;
        this.$filter = $filter;
      }
      ASTCompiler.prototype = {
        compile: function(expression, expensiveChecks) {
          var self = this;
          var ast = this.astBuilder.ast(expression);
          this.state = {
            nextId: 0,
            filters: {},
            expensiveChecks: expensiveChecks,
            fn: {
              vars: [],
              body: [],
              own: {}
            },
            assign: {
              vars: [],
              body: [],
              own: {}
            },
            inputs: []
          };
          findConstantAndWatchExpressions(ast, self.$filter);
          var extra = '';
          var assignable;
          this.stage = 'assign';
          if ((assignable = assignableAST(ast))) {
            this.state.computing = 'assign';
            var result = this.nextId();
            this.recurse(assignable, result);
            this.return_(result);
            extra = 'fn.assign=' + this.generateFunction('assign', 's,v,l');
          }
          var toWatch = getInputs(ast.body);
          self.stage = 'inputs';
          forEach(toWatch, function(watch, key) {
            var fnKey = 'fn' + key;
            self.state[fnKey] = {
              vars: [],
              body: [],
              own: {}
            };
            self.state.computing = fnKey;
            var intoId = self.nextId();
            self.recurse(watch, intoId);
            self.return_(intoId);
            self.state.inputs.push(fnKey);
            watch.watchId = key;
          });
          this.state.computing = 'fn';
          this.stage = 'main';
          this.recurse(ast);
          var fnString = '"' + this.USE + ' ' + this.STRICT + '";\n' + this.filterPrefix() + 'var fn=' + this.generateFunction('fn', 's,l,a,i') + extra + this.watchFns() + 'return fn;';
          var fn = (new Function('$filter', 'ensureSafeMemberName', 'ensureSafeObject', 'ensureSafeFunction', 'getStringValue', 'ensureSafeAssignContext', 'ifDefined', 'plus', 'text', fnString))(this.$filter, ensureSafeMemberName, ensureSafeObject, ensureSafeFunction, getStringValue, ensureSafeAssignContext, ifDefined, plusFn, expression);
          this.state = this.stage = undefined;
          fn.literal = isLiteral(ast);
          fn.constant = isConstant(ast);
          return fn;
        },
        USE: 'use',
        STRICT: 'strict',
        watchFns: function() {
          var result = [];
          var fns = this.state.inputs;
          var self = this;
          forEach(fns, function(name) {
            result.push('var ' + name + '=' + self.generateFunction(name, 's'));
          });
          if (fns.length) {
            result.push('fn.inputs=[' + fns.join(',') + '];');
          }
          return result.join('');
        },
        generateFunction: function(name, params) {
          return 'function(' + params + '){' + this.varsPrefix(name) + this.body(name) + '};';
        },
        filterPrefix: function() {
          var parts = [];
          var self = this;
          forEach(this.state.filters, function(id, filter) {
            parts.push(id + '=$filter(' + self.escape(filter) + ')');
          });
          if (parts.length)
            return 'var ' + parts.join(',') + ';';
          return '';
        },
        varsPrefix: function(section) {
          return this.state[section].vars.length ? 'var ' + this.state[section].vars.join(',') + ';' : '';
        },
        body: function(section) {
          return this.state[section].body.join('');
        },
        recurse: function(ast, intoId, nameId, recursionFn, create, skipWatchIdCheck) {
          var left,
              right,
              self = this,
              args,
              expression,
              computed;
          recursionFn = recursionFn || noop;
          if (!skipWatchIdCheck && isDefined(ast.watchId)) {
            intoId = intoId || this.nextId();
            this.if_('i', this.lazyAssign(intoId, this.computedMember('i', ast.watchId)), this.lazyRecurse(ast, intoId, nameId, recursionFn, create, true));
            return;
          }
          switch (ast.type) {
            case AST.Program:
              forEach(ast.body, function(expression, pos) {
                self.recurse(expression.expression, undefined, undefined, function(expr) {
                  right = expr;
                });
                if (pos !== ast.body.length - 1) {
                  self.current().body.push(right, ';');
                } else {
                  self.return_(right);
                }
              });
              break;
            case AST.Literal:
              expression = this.escape(ast.value);
              this.assign(intoId, expression);
              recursionFn(expression);
              break;
            case AST.UnaryExpression:
              this.recurse(ast.argument, undefined, undefined, function(expr) {
                right = expr;
              });
              expression = ast.operator + '(' + this.ifDefined(right, 0) + ')';
              this.assign(intoId, expression);
              recursionFn(expression);
              break;
            case AST.BinaryExpression:
              this.recurse(ast.left, undefined, undefined, function(expr) {
                left = expr;
              });
              this.recurse(ast.right, undefined, undefined, function(expr) {
                right = expr;
              });
              if (ast.operator === '+') {
                expression = this.plus(left, right);
              } else if (ast.operator === '-') {
                expression = this.ifDefined(left, 0) + ast.operator + this.ifDefined(right, 0);
              } else {
                expression = '(' + left + ')' + ast.operator + '(' + right + ')';
              }
              this.assign(intoId, expression);
              recursionFn(expression);
              break;
            case AST.LogicalExpression:
              intoId = intoId || this.nextId();
              self.recurse(ast.left, intoId);
              self.if_(ast.operator === '&&' ? intoId : self.not(intoId), self.lazyRecurse(ast.right, intoId));
              recursionFn(intoId);
              break;
            case AST.ConditionalExpression:
              intoId = intoId || this.nextId();
              self.recurse(ast.test, intoId);
              self.if_(intoId, self.lazyRecurse(ast.alternate, intoId), self.lazyRecurse(ast.consequent, intoId));
              recursionFn(intoId);
              break;
            case AST.Identifier:
              intoId = intoId || this.nextId();
              if (nameId) {
                nameId.context = self.stage === 'inputs' ? 's' : this.assign(this.nextId(), this.getHasOwnProperty('l', ast.name) + '?l:s');
                nameId.computed = false;
                nameId.name = ast.name;
              }
              ensureSafeMemberName(ast.name);
              self.if_(self.stage === 'inputs' || self.not(self.getHasOwnProperty('l', ast.name)), function() {
                self.if_(self.stage === 'inputs' || 's', function() {
                  if (create && create !== 1) {
                    self.if_(self.not(self.nonComputedMember('s', ast.name)), self.lazyAssign(self.nonComputedMember('s', ast.name), '{}'));
                  }
                  self.assign(intoId, self.nonComputedMember('s', ast.name));
                });
              }, intoId && self.lazyAssign(intoId, self.nonComputedMember('l', ast.name)));
              if (self.state.expensiveChecks || isPossiblyDangerousMemberName(ast.name)) {
                self.addEnsureSafeObject(intoId);
              }
              recursionFn(intoId);
              break;
            case AST.MemberExpression:
              left = nameId && (nameId.context = this.nextId()) || this.nextId();
              intoId = intoId || this.nextId();
              self.recurse(ast.object, left, undefined, function() {
                self.if_(self.notNull(left), function() {
                  if (create && create !== 1) {
                    self.addEnsureSafeAssignContext(left);
                  }
                  if (ast.computed) {
                    right = self.nextId();
                    self.recurse(ast.property, right);
                    self.getStringValue(right);
                    self.addEnsureSafeMemberName(right);
                    if (create && create !== 1) {
                      self.if_(self.not(self.computedMember(left, right)), self.lazyAssign(self.computedMember(left, right), '{}'));
                    }
                    expression = self.ensureSafeObject(self.computedMember(left, right));
                    self.assign(intoId, expression);
                    if (nameId) {
                      nameId.computed = true;
                      nameId.name = right;
                    }
                  } else {
                    ensureSafeMemberName(ast.property.name);
                    if (create && create !== 1) {
                      self.if_(self.not(self.nonComputedMember(left, ast.property.name)), self.lazyAssign(self.nonComputedMember(left, ast.property.name), '{}'));
                    }
                    expression = self.nonComputedMember(left, ast.property.name);
                    if (self.state.expensiveChecks || isPossiblyDangerousMemberName(ast.property.name)) {
                      expression = self.ensureSafeObject(expression);
                    }
                    self.assign(intoId, expression);
                    if (nameId) {
                      nameId.computed = false;
                      nameId.name = ast.property.name;
                    }
                  }
                }, function() {
                  self.assign(intoId, 'undefined');
                });
                recursionFn(intoId);
              }, !!create);
              break;
            case AST.CallExpression:
              intoId = intoId || this.nextId();
              if (ast.filter) {
                right = self.filter(ast.callee.name);
                args = [];
                forEach(ast.arguments, function(expr) {
                  var argument = self.nextId();
                  self.recurse(expr, argument);
                  args.push(argument);
                });
                expression = right + '(' + args.join(',') + ')';
                self.assign(intoId, expression);
                recursionFn(intoId);
              } else {
                right = self.nextId();
                left = {};
                args = [];
                self.recurse(ast.callee, right, left, function() {
                  self.if_(self.notNull(right), function() {
                    self.addEnsureSafeFunction(right);
                    forEach(ast.arguments, function(expr) {
                      self.recurse(expr, self.nextId(), undefined, function(argument) {
                        args.push(self.ensureSafeObject(argument));
                      });
                    });
                    if (left.name) {
                      if (!self.state.expensiveChecks) {
                        self.addEnsureSafeObject(left.context);
                      }
                      expression = self.member(left.context, left.name, left.computed) + '(' + args.join(',') + ')';
                    } else {
                      expression = right + '(' + args.join(',') + ')';
                    }
                    expression = self.ensureSafeObject(expression);
                    self.assign(intoId, expression);
                  }, function() {
                    self.assign(intoId, 'undefined');
                  });
                  recursionFn(intoId);
                });
              }
              break;
            case AST.AssignmentExpression:
              right = this.nextId();
              left = {};
              if (!isAssignable(ast.left)) {
                throw $parseMinErr('lval', 'Trying to assign a value to a non l-value');
              }
              this.recurse(ast.left, undefined, left, function() {
                self.if_(self.notNull(left.context), function() {
                  self.recurse(ast.right, right);
                  self.addEnsureSafeObject(self.member(left.context, left.name, left.computed));
                  self.addEnsureSafeAssignContext(left.context);
                  expression = self.member(left.context, left.name, left.computed) + ast.operator + right;
                  self.assign(intoId, expression);
                  recursionFn(intoId || expression);
                });
              }, 1);
              break;
            case AST.ArrayExpression:
              args = [];
              forEach(ast.elements, function(expr) {
                self.recurse(expr, self.nextId(), undefined, function(argument) {
                  args.push(argument);
                });
              });
              expression = '[' + args.join(',') + ']';
              this.assign(intoId, expression);
              recursionFn(expression);
              break;
            case AST.ObjectExpression:
              args = [];
              computed = false;
              forEach(ast.properties, function(property) {
                if (property.computed) {
                  computed = true;
                }
              });
              if (computed) {
                intoId = intoId || this.nextId();
                this.assign(intoId, '{}');
                forEach(ast.properties, function(property) {
                  if (property.computed) {
                    left = self.nextId();
                    self.recurse(property.key, left);
                  } else {
                    left = property.key.type === AST.Identifier ? property.key.name : ('' + property.key.value);
                  }
                  right = self.nextId();
                  self.recurse(property.value, right);
                  self.assign(self.member(intoId, left, property.computed), right);
                });
              } else {
                forEach(ast.properties, function(property) {
                  self.recurse(property.value, ast.constant ? undefined : self.nextId(), undefined, function(expr) {
                    args.push(self.escape(property.key.type === AST.Identifier ? property.key.name : ('' + property.key.value)) + ':' + expr);
                  });
                });
                expression = '{' + args.join(',') + '}';
                this.assign(intoId, expression);
              }
              recursionFn(intoId || expression);
              break;
            case AST.ThisExpression:
              this.assign(intoId, 's');
              recursionFn('s');
              break;
            case AST.LocalsExpression:
              this.assign(intoId, 'l');
              recursionFn('l');
              break;
            case AST.NGValueParameter:
              this.assign(intoId, 'v');
              recursionFn('v');
              break;
          }
        },
        getHasOwnProperty: function(element, property) {
          var key = element + '.' + property;
          var own = this.current().own;
          if (!own.hasOwnProperty(key)) {
            own[key] = this.nextId(false, element + '&&(' + this.escape(property) + ' in ' + element + ')');
          }
          return own[key];
        },
        assign: function(id, value) {
          if (!id)
            return;
          this.current().body.push(id, '=', value, ';');
          return id;
        },
        filter: function(filterName) {
          if (!this.state.filters.hasOwnProperty(filterName)) {
            this.state.filters[filterName] = this.nextId(true);
          }
          return this.state.filters[filterName];
        },
        ifDefined: function(id, defaultValue) {
          return 'ifDefined(' + id + ',' + this.escape(defaultValue) + ')';
        },
        plus: function(left, right) {
          return 'plus(' + left + ',' + right + ')';
        },
        return_: function(id) {
          this.current().body.push('return ', id, ';');
        },
        if_: function(test, alternate, consequent) {
          if (test === true) {
            alternate();
          } else {
            var body = this.current().body;
            body.push('if(', test, '){');
            alternate();
            body.push('}');
            if (consequent) {
              body.push('else{');
              consequent();
              body.push('}');
            }
          }
        },
        not: function(expression) {
          return '!(' + expression + ')';
        },
        notNull: function(expression) {
          return expression + '!=null';
        },
        nonComputedMember: function(left, right) {
          var SAFE_IDENTIFIER = /[$_a-zA-Z][$_a-zA-Z0-9]*/;
          var UNSAFE_CHARACTERS = /[^$_a-zA-Z0-9]/g;
          if (SAFE_IDENTIFIER.test(right)) {
            return left + '.' + right;
          } else {
            return left + '["' + right.replace(UNSAFE_CHARACTERS, this.stringEscapeFn) + '"]';
          }
        },
        computedMember: function(left, right) {
          return left + '[' + right + ']';
        },
        member: function(left, right, computed) {
          if (computed)
            return this.computedMember(left, right);
          return this.nonComputedMember(left, right);
        },
        addEnsureSafeObject: function(item) {
          this.current().body.push(this.ensureSafeObject(item), ';');
        },
        addEnsureSafeMemberName: function(item) {
          this.current().body.push(this.ensureSafeMemberName(item), ';');
        },
        addEnsureSafeFunction: function(item) {
          this.current().body.push(this.ensureSafeFunction(item), ';');
        },
        addEnsureSafeAssignContext: function(item) {
          this.current().body.push(this.ensureSafeAssignContext(item), ';');
        },
        ensureSafeObject: function(item) {
          return 'ensureSafeObject(' + item + ',text)';
        },
        ensureSafeMemberName: function(item) {
          return 'ensureSafeMemberName(' + item + ',text)';
        },
        ensureSafeFunction: function(item) {
          return 'ensureSafeFunction(' + item + ',text)';
        },
        getStringValue: function(item) {
          this.assign(item, 'getStringValue(' + item + ')');
        },
        ensureSafeAssignContext: function(item) {
          return 'ensureSafeAssignContext(' + item + ',text)';
        },
        lazyRecurse: function(ast, intoId, nameId, recursionFn, create, skipWatchIdCheck) {
          var self = this;
          return function() {
            self.recurse(ast, intoId, nameId, recursionFn, create, skipWatchIdCheck);
          };
        },
        lazyAssign: function(id, value) {
          var self = this;
          return function() {
            self.assign(id, value);
          };
        },
        stringEscapeRegex: /[^ a-zA-Z0-9]/g,
        stringEscapeFn: function(c) {
          return '\\u' + ('0000' + c.charCodeAt(0).toString(16)).slice(-4);
        },
        escape: function(value) {
          if (isString(value))
            return "'" + value.replace(this.stringEscapeRegex, this.stringEscapeFn) + "'";
          if (isNumber(value))
            return value.toString();
          if (value === true)
            return 'true';
          if (value === false)
            return 'false';
          if (value === null)
            return 'null';
          if (typeof value === 'undefined')
            return 'undefined';
          throw $parseMinErr('esc', 'IMPOSSIBLE');
        },
        nextId: function(skip, init) {
          var id = 'v' + (this.state.nextId++);
          if (!skip) {
            this.current().vars.push(id + (init ? '=' + init : ''));
          }
          return id;
        },
        current: function() {
          return this.state[this.state.computing];
        }
      };
      function ASTInterpreter(astBuilder, $filter) {
        this.astBuilder = astBuilder;
        this.$filter = $filter;
      }
      ASTInterpreter.prototype = {
        compile: function(expression, expensiveChecks) {
          var self = this;
          var ast = this.astBuilder.ast(expression);
          this.expression = expression;
          this.expensiveChecks = expensiveChecks;
          findConstantAndWatchExpressions(ast, self.$filter);
          var assignable;
          var assign;
          if ((assignable = assignableAST(ast))) {
            assign = this.recurse(assignable);
          }
          var toWatch = getInputs(ast.body);
          var inputs;
          if (toWatch) {
            inputs = [];
            forEach(toWatch, function(watch, key) {
              var input = self.recurse(watch);
              watch.input = input;
              inputs.push(input);
              watch.watchId = key;
            });
          }
          var expressions = [];
          forEach(ast.body, function(expression) {
            expressions.push(self.recurse(expression.expression));
          });
          var fn = ast.body.length === 0 ? noop : ast.body.length === 1 ? expressions[0] : function(scope, locals) {
            var lastValue;
            forEach(expressions, function(exp) {
              lastValue = exp(scope, locals);
            });
            return lastValue;
          };
          if (assign) {
            fn.assign = function(scope, value, locals) {
              return assign(scope, locals, value);
            };
          }
          if (inputs) {
            fn.inputs = inputs;
          }
          fn.literal = isLiteral(ast);
          fn.constant = isConstant(ast);
          return fn;
        },
        recurse: function(ast, context, create) {
          var left,
              right,
              self = this,
              args,
              expression;
          if (ast.input) {
            return this.inputs(ast.input, ast.watchId);
          }
          switch (ast.type) {
            case AST.Literal:
              return this.value(ast.value, context);
            case AST.UnaryExpression:
              right = this.recurse(ast.argument);
              return this['unary' + ast.operator](right, context);
            case AST.BinaryExpression:
              left = this.recurse(ast.left);
              right = this.recurse(ast.right);
              return this['binary' + ast.operator](left, right, context);
            case AST.LogicalExpression:
              left = this.recurse(ast.left);
              right = this.recurse(ast.right);
              return this['binary' + ast.operator](left, right, context);
            case AST.ConditionalExpression:
              return this['ternary?:'](this.recurse(ast.test), this.recurse(ast.alternate), this.recurse(ast.consequent), context);
            case AST.Identifier:
              ensureSafeMemberName(ast.name, self.expression);
              return self.identifier(ast.name, self.expensiveChecks || isPossiblyDangerousMemberName(ast.name), context, create, self.expression);
            case AST.MemberExpression:
              left = this.recurse(ast.object, false, !!create);
              if (!ast.computed) {
                ensureSafeMemberName(ast.property.name, self.expression);
                right = ast.property.name;
              }
              if (ast.computed)
                right = this.recurse(ast.property);
              return ast.computed ? this.computedMember(left, right, context, create, self.expression) : this.nonComputedMember(left, right, self.expensiveChecks, context, create, self.expression);
            case AST.CallExpression:
              args = [];
              forEach(ast.arguments, function(expr) {
                args.push(self.recurse(expr));
              });
              if (ast.filter)
                right = this.$filter(ast.callee.name);
              if (!ast.filter)
                right = this.recurse(ast.callee, true);
              return ast.filter ? function(scope, locals, assign, inputs) {
                var values = [];
                for (var i = 0; i < args.length; ++i) {
                  values.push(args[i](scope, locals, assign, inputs));
                }
                var value = right.apply(undefined, values, inputs);
                return context ? {
                  context: undefined,
                  name: undefined,
                  value: value
                } : value;
              } : function(scope, locals, assign, inputs) {
                var rhs = right(scope, locals, assign, inputs);
                var value;
                if (rhs.value != null) {
                  ensureSafeObject(rhs.context, self.expression);
                  ensureSafeFunction(rhs.value, self.expression);
                  var values = [];
                  for (var i = 0; i < args.length; ++i) {
                    values.push(ensureSafeObject(args[i](scope, locals, assign, inputs), self.expression));
                  }
                  value = ensureSafeObject(rhs.value.apply(rhs.context, values), self.expression);
                }
                return context ? {value: value} : value;
              };
            case AST.AssignmentExpression:
              left = this.recurse(ast.left, true, 1);
              right = this.recurse(ast.right);
              return function(scope, locals, assign, inputs) {
                var lhs = left(scope, locals, assign, inputs);
                var rhs = right(scope, locals, assign, inputs);
                ensureSafeObject(lhs.value, self.expression);
                ensureSafeAssignContext(lhs.context);
                lhs.context[lhs.name] = rhs;
                return context ? {value: rhs} : rhs;
              };
            case AST.ArrayExpression:
              args = [];
              forEach(ast.elements, function(expr) {
                args.push(self.recurse(expr));
              });
              return function(scope, locals, assign, inputs) {
                var value = [];
                for (var i = 0; i < args.length; ++i) {
                  value.push(args[i](scope, locals, assign, inputs));
                }
                return context ? {value: value} : value;
              };
            case AST.ObjectExpression:
              args = [];
              forEach(ast.properties, function(property) {
                if (property.computed) {
                  args.push({
                    key: self.recurse(property.key),
                    computed: true,
                    value: self.recurse(property.value)
                  });
                } else {
                  args.push({
                    key: property.key.type === AST.Identifier ? property.key.name : ('' + property.key.value),
                    computed: false,
                    value: self.recurse(property.value)
                  });
                }
              });
              return function(scope, locals, assign, inputs) {
                var value = {};
                for (var i = 0; i < args.length; ++i) {
                  if (args[i].computed) {
                    value[args[i].key(scope, locals, assign, inputs)] = args[i].value(scope, locals, assign, inputs);
                  } else {
                    value[args[i].key] = args[i].value(scope, locals, assign, inputs);
                  }
                }
                return context ? {value: value} : value;
              };
            case AST.ThisExpression:
              return function(scope) {
                return context ? {value: scope} : scope;
              };
            case AST.LocalsExpression:
              return function(scope, locals) {
                return context ? {value: locals} : locals;
              };
            case AST.NGValueParameter:
              return function(scope, locals, assign) {
                return context ? {value: assign} : assign;
              };
          }
        },
        'unary+': function(argument, context) {
          return function(scope, locals, assign, inputs) {
            var arg = argument(scope, locals, assign, inputs);
            if (isDefined(arg)) {
              arg = +arg;
            } else {
              arg = 0;
            }
            return context ? {value: arg} : arg;
          };
        },
        'unary-': function(argument, context) {
          return function(scope, locals, assign, inputs) {
            var arg = argument(scope, locals, assign, inputs);
            if (isDefined(arg)) {
              arg = -arg;
            } else {
              arg = 0;
            }
            return context ? {value: arg} : arg;
          };
        },
        'unary!': function(argument, context) {
          return function(scope, locals, assign, inputs) {
            var arg = !argument(scope, locals, assign, inputs);
            return context ? {value: arg} : arg;
          };
        },
        'binary+': function(left, right, context) {
          return function(scope, locals, assign, inputs) {
            var lhs = left(scope, locals, assign, inputs);
            var rhs = right(scope, locals, assign, inputs);
            var arg = plusFn(lhs, rhs);
            return context ? {value: arg} : arg;
          };
        },
        'binary-': function(left, right, context) {
          return function(scope, locals, assign, inputs) {
            var lhs = left(scope, locals, assign, inputs);
            var rhs = right(scope, locals, assign, inputs);
            var arg = (isDefined(lhs) ? lhs : 0) - (isDefined(rhs) ? rhs : 0);
            return context ? {value: arg} : arg;
          };
        },
        'binary*': function(left, right, context) {
          return function(scope, locals, assign, inputs) {
            var arg = left(scope, locals, assign, inputs) * right(scope, locals, assign, inputs);
            return context ? {value: arg} : arg;
          };
        },
        'binary/': function(left, right, context) {
          return function(scope, locals, assign, inputs) {
            var arg = left(scope, locals, assign, inputs) / right(scope, locals, assign, inputs);
            return context ? {value: arg} : arg;
          };
        },
        'binary%': function(left, right, context) {
          return function(scope, locals, assign, inputs) {
            var arg = left(scope, locals, assign, inputs) % right(scope, locals, assign, inputs);
            return context ? {value: arg} : arg;
          };
        },
        'binary===': function(left, right, context) {
          return function(scope, locals, assign, inputs) {
            var arg = left(scope, locals, assign, inputs) === right(scope, locals, assign, inputs);
            return context ? {value: arg} : arg;
          };
        },
        'binary!==': function(left, right, context) {
          return function(scope, locals, assign, inputs) {
            var arg = left(scope, locals, assign, inputs) !== right(scope, locals, assign, inputs);
            return context ? {value: arg} : arg;
          };
        },
        'binary==': function(left, right, context) {
          return function(scope, locals, assign, inputs) {
            var arg = left(scope, locals, assign, inputs) == right(scope, locals, assign, inputs);
            return context ? {value: arg} : arg;
          };
        },
        'binary!=': function(left, right, context) {
          return function(scope, locals, assign, inputs) {
            var arg = left(scope, locals, assign, inputs) != right(scope, locals, assign, inputs);
            return context ? {value: arg} : arg;
          };
        },
        'binary<': function(left, right, context) {
          return function(scope, locals, assign, inputs) {
            var arg = left(scope, locals, assign, inputs) < right(scope, locals, assign, inputs);
            return context ? {value: arg} : arg;
          };
        },
        'binary>': function(left, right, context) {
          return function(scope, locals, assign, inputs) {
            var arg = left(scope, locals, assign, inputs) > right(scope, locals, assign, inputs);
            return context ? {value: arg} : arg;
          };
        },
        'binary<=': function(left, right, context) {
          return function(scope, locals, assign, inputs) {
            var arg = left(scope, locals, assign, inputs) <= right(scope, locals, assign, inputs);
            return context ? {value: arg} : arg;
          };
        },
        'binary>=': function(left, right, context) {
          return function(scope, locals, assign, inputs) {
            var arg = left(scope, locals, assign, inputs) >= right(scope, locals, assign, inputs);
            return context ? {value: arg} : arg;
          };
        },
        'binary&&': function(left, right, context) {
          return function(scope, locals, assign, inputs) {
            var arg = left(scope, locals, assign, inputs) && right(scope, locals, assign, inputs);
            return context ? {value: arg} : arg;
          };
        },
        'binary||': function(left, right, context) {
          return function(scope, locals, assign, inputs) {
            var arg = left(scope, locals, assign, inputs) || right(scope, locals, assign, inputs);
            return context ? {value: arg} : arg;
          };
        },
        'ternary?:': function(test, alternate, consequent, context) {
          return function(scope, locals, assign, inputs) {
            var arg = test(scope, locals, assign, inputs) ? alternate(scope, locals, assign, inputs) : consequent(scope, locals, assign, inputs);
            return context ? {value: arg} : arg;
          };
        },
        value: function(value, context) {
          return function() {
            return context ? {
              context: undefined,
              name: undefined,
              value: value
            } : value;
          };
        },
        identifier: function(name, expensiveChecks, context, create, expression) {
          return function(scope, locals, assign, inputs) {
            var base = locals && (name in locals) ? locals : scope;
            if (create && create !== 1 && base && !(base[name])) {
              base[name] = {};
            }
            var value = base ? base[name] : undefined;
            if (expensiveChecks) {
              ensureSafeObject(value, expression);
            }
            if (context) {
              return {
                context: base,
                name: name,
                value: value
              };
            } else {
              return value;
            }
          };
        },
        computedMember: function(left, right, context, create, expression) {
          return function(scope, locals, assign, inputs) {
            var lhs = left(scope, locals, assign, inputs);
            var rhs;
            var value;
            if (lhs != null) {
              rhs = right(scope, locals, assign, inputs);
              rhs = getStringValue(rhs);
              ensureSafeMemberName(rhs, expression);
              if (create && create !== 1) {
                ensureSafeAssignContext(lhs);
                if (lhs && !(lhs[rhs])) {
                  lhs[rhs] = {};
                }
              }
              value = lhs[rhs];
              ensureSafeObject(value, expression);
            }
            if (context) {
              return {
                context: lhs,
                name: rhs,
                value: value
              };
            } else {
              return value;
            }
          };
        },
        nonComputedMember: function(left, right, expensiveChecks, context, create, expression) {
          return function(scope, locals, assign, inputs) {
            var lhs = left(scope, locals, assign, inputs);
            if (create && create !== 1) {
              ensureSafeAssignContext(lhs);
              if (lhs && !(lhs[right])) {
                lhs[right] = {};
              }
            }
            var value = lhs != null ? lhs[right] : undefined;
            if (expensiveChecks || isPossiblyDangerousMemberName(right)) {
              ensureSafeObject(value, expression);
            }
            if (context) {
              return {
                context: lhs,
                name: right,
                value: value
              };
            } else {
              return value;
            }
          };
        },
        inputs: function(input, watchId) {
          return function(scope, value, locals, inputs) {
            if (inputs)
              return inputs[watchId];
            return input(scope, value, locals);
          };
        }
      };
      var Parser = function(lexer, $filter, options) {
        this.lexer = lexer;
        this.$filter = $filter;
        this.options = options;
        this.ast = new AST(lexer, options);
        this.astCompiler = options.csp ? new ASTInterpreter(this.ast, $filter) : new ASTCompiler(this.ast, $filter);
      };
      Parser.prototype = {
        constructor: Parser,
        parse: function(text) {
          return this.astCompiler.compile(text, this.options.expensiveChecks);
        }
      };
      function isPossiblyDangerousMemberName(name) {
        return name == 'constructor';
      }
      var objectValueOf = Object.prototype.valueOf;
      function getValueOf(value) {
        return isFunction(value.valueOf) ? value.valueOf() : objectValueOf.call(value);
      }
      function $ParseProvider() {
        var cacheDefault = createMap();
        var cacheExpensive = createMap();
        var literals = {
          'true': true,
          'false': false,
          'null': null,
          'undefined': undefined
        };
        var identStart,
            identContinue;
        this.addLiteral = function(literalName, literalValue) {
          literals[literalName] = literalValue;
        };
        this.setIdentifierFns = function(identifierStart, identifierContinue) {
          identStart = identifierStart;
          identContinue = identifierContinue;
          return this;
        };
        this.$get = ['$filter', function($filter) {
          var noUnsafeEval = csp().noUnsafeEval;
          var $parseOptions = {
            csp: noUnsafeEval,
            expensiveChecks: false,
            literals: copy(literals),
            isIdentifierStart: isFunction(identStart) && identStart,
            isIdentifierContinue: isFunction(identContinue) && identContinue
          },
              $parseOptionsExpensive = {
                csp: noUnsafeEval,
                expensiveChecks: true,
                literals: copy(literals),
                isIdentifierStart: isFunction(identStart) && identStart,
                isIdentifierContinue: isFunction(identContinue) && identContinue
              };
          var runningChecksEnabled = false;
          $parse.$$runningExpensiveChecks = function() {
            return runningChecksEnabled;
          };
          return $parse;
          function $parse(exp, interceptorFn, expensiveChecks) {
            var parsedExpression,
                oneTime,
                cacheKey;
            expensiveChecks = expensiveChecks || runningChecksEnabled;
            switch (typeof exp) {
              case 'string':
                exp = exp.trim();
                cacheKey = exp;
                var cache = (expensiveChecks ? cacheExpensive : cacheDefault);
                parsedExpression = cache[cacheKey];
                if (!parsedExpression) {
                  if (exp.charAt(0) === ':' && exp.charAt(1) === ':') {
                    oneTime = true;
                    exp = exp.substring(2);
                  }
                  var parseOptions = expensiveChecks ? $parseOptionsExpensive : $parseOptions;
                  var lexer = new Lexer(parseOptions);
                  var parser = new Parser(lexer, $filter, parseOptions);
                  parsedExpression = parser.parse(exp);
                  if (parsedExpression.constant) {
                    parsedExpression.$$watchDelegate = constantWatchDelegate;
                  } else if (oneTime) {
                    parsedExpression.$$watchDelegate = parsedExpression.literal ? oneTimeLiteralWatchDelegate : oneTimeWatchDelegate;
                  } else if (parsedExpression.inputs) {
                    parsedExpression.$$watchDelegate = inputsWatchDelegate;
                  }
                  if (expensiveChecks) {
                    parsedExpression = expensiveChecksInterceptor(parsedExpression);
                  }
                  cache[cacheKey] = parsedExpression;
                }
                return addInterceptor(parsedExpression, interceptorFn);
              case 'function':
                return addInterceptor(exp, interceptorFn);
              default:
                return addInterceptor(noop, interceptorFn);
            }
          }
          function expensiveChecksInterceptor(fn) {
            if (!fn)
              return fn;
            expensiveCheckFn.$$watchDelegate = fn.$$watchDelegate;
            expensiveCheckFn.assign = expensiveChecksInterceptor(fn.assign);
            expensiveCheckFn.constant = fn.constant;
            expensiveCheckFn.literal = fn.literal;
            for (var i = 0; fn.inputs && i < fn.inputs.length; ++i) {
              fn.inputs[i] = expensiveChecksInterceptor(fn.inputs[i]);
            }
            expensiveCheckFn.inputs = fn.inputs;
            return expensiveCheckFn;
            function expensiveCheckFn(scope, locals, assign, inputs) {
              var expensiveCheckOldValue = runningChecksEnabled;
              runningChecksEnabled = true;
              try {
                return fn(scope, locals, assign, inputs);
              } finally {
                runningChecksEnabled = expensiveCheckOldValue;
              }
            }
          }
          function expressionInputDirtyCheck(newValue, oldValueOfValue) {
            if (newValue == null || oldValueOfValue == null) {
              return newValue === oldValueOfValue;
            }
            if (typeof newValue === 'object') {
              newValue = getValueOf(newValue);
              if (typeof newValue === 'object') {
                return false;
              }
            }
            return newValue === oldValueOfValue || (newValue !== newValue && oldValueOfValue !== oldValueOfValue);
          }
          function inputsWatchDelegate(scope, listener, objectEquality, parsedExpression, prettyPrintExpression) {
            var inputExpressions = parsedExpression.inputs;
            var lastResult;
            if (inputExpressions.length === 1) {
              var oldInputValueOf = expressionInputDirtyCheck;
              inputExpressions = inputExpressions[0];
              return scope.$watch(function expressionInputWatch(scope) {
                var newInputValue = inputExpressions(scope);
                if (!expressionInputDirtyCheck(newInputValue, oldInputValueOf)) {
                  lastResult = parsedExpression(scope, undefined, undefined, [newInputValue]);
                  oldInputValueOf = newInputValue && getValueOf(newInputValue);
                }
                return lastResult;
              }, listener, objectEquality, prettyPrintExpression);
            }
            var oldInputValueOfValues = [];
            var oldInputValues = [];
            for (var i = 0,
                ii = inputExpressions.length; i < ii; i++) {
              oldInputValueOfValues[i] = expressionInputDirtyCheck;
              oldInputValues[i] = null;
            }
            return scope.$watch(function expressionInputsWatch(scope) {
              var changed = false;
              for (var i = 0,
                  ii = inputExpressions.length; i < ii; i++) {
                var newInputValue = inputExpressions[i](scope);
                if (changed || (changed = !expressionInputDirtyCheck(newInputValue, oldInputValueOfValues[i]))) {
                  oldInputValues[i] = newInputValue;
                  oldInputValueOfValues[i] = newInputValue && getValueOf(newInputValue);
                }
              }
              if (changed) {
                lastResult = parsedExpression(scope, undefined, undefined, oldInputValues);
              }
              return lastResult;
            }, listener, objectEquality, prettyPrintExpression);
          }
          function oneTimeWatchDelegate(scope, listener, objectEquality, parsedExpression) {
            var unwatch,
                lastValue;
            return unwatch = scope.$watch(function oneTimeWatch(scope) {
              return parsedExpression(scope);
            }, function oneTimeListener(value, old, scope) {
              lastValue = value;
              if (isFunction(listener)) {
                listener.apply(this, arguments);
              }
              if (isDefined(value)) {
                scope.$$postDigest(function() {
                  if (isDefined(lastValue)) {
                    unwatch();
                  }
                });
              }
            }, objectEquality);
          }
          function oneTimeLiteralWatchDelegate(scope, listener, objectEquality, parsedExpression) {
            var unwatch,
                lastValue;
            return unwatch = scope.$watch(function oneTimeWatch(scope) {
              return parsedExpression(scope);
            }, function oneTimeListener(value, old, scope) {
              lastValue = value;
              if (isFunction(listener)) {
                listener.call(this, value, old, scope);
              }
              if (isAllDefined(value)) {
                scope.$$postDigest(function() {
                  if (isAllDefined(lastValue))
                    unwatch();
                });
              }
            }, objectEquality);
            function isAllDefined(value) {
              var allDefined = true;
              forEach(value, function(val) {
                if (!isDefined(val))
                  allDefined = false;
              });
              return allDefined;
            }
          }
          function constantWatchDelegate(scope, listener, objectEquality, parsedExpression) {
            var unwatch;
            return unwatch = scope.$watch(function constantWatch(scope) {
              unwatch();
              return parsedExpression(scope);
            }, listener, objectEquality);
          }
          function addInterceptor(parsedExpression, interceptorFn) {
            if (!interceptorFn)
              return parsedExpression;
            var watchDelegate = parsedExpression.$$watchDelegate;
            var useInputs = false;
            var regularWatch = watchDelegate !== oneTimeLiteralWatchDelegate && watchDelegate !== oneTimeWatchDelegate;
            var fn = regularWatch ? function regularInterceptedExpression(scope, locals, assign, inputs) {
              var value = useInputs && inputs ? inputs[0] : parsedExpression(scope, locals, assign, inputs);
              return interceptorFn(value, scope, locals);
            } : function oneTimeInterceptedExpression(scope, locals, assign, inputs) {
              var value = parsedExpression(scope, locals, assign, inputs);
              var result = interceptorFn(value, scope, locals);
              return isDefined(value) ? result : value;
            };
            if (parsedExpression.$$watchDelegate && parsedExpression.$$watchDelegate !== inputsWatchDelegate) {
              fn.$$watchDelegate = parsedExpression.$$watchDelegate;
            } else if (!interceptorFn.$stateful) {
              fn.$$watchDelegate = inputsWatchDelegate;
              useInputs = !parsedExpression.inputs;
              fn.inputs = parsedExpression.inputs ? parsedExpression.inputs : [parsedExpression];
            }
            return fn;
          }
        }];
      }
      function $QProvider() {
        this.$get = ['$rootScope', '$exceptionHandler', function($rootScope, $exceptionHandler) {
          return qFactory(function(callback) {
            $rootScope.$evalAsync(callback);
          }, $exceptionHandler);
        }];
      }
      function $$QProvider() {
        this.$get = ['$browser', '$exceptionHandler', function($browser, $exceptionHandler) {
          return qFactory(function(callback) {
            $browser.defer(callback);
          }, $exceptionHandler);
        }];
      }
      function qFactory(nextTick, exceptionHandler) {
        var $qMinErr = minErr('$q', TypeError);
        var defer = function() {
          var d = new Deferred();
          d.resolve = simpleBind(d, d.resolve);
          d.reject = simpleBind(d, d.reject);
          d.notify = simpleBind(d, d.notify);
          return d;
        };
        function Promise() {
          this.$$state = {status: 0};
        }
        extend(Promise.prototype, {
          then: function(onFulfilled, onRejected, progressBack) {
            if (isUndefined(onFulfilled) && isUndefined(onRejected) && isUndefined(progressBack)) {
              return this;
            }
            var result = new Deferred();
            this.$$state.pending = this.$$state.pending || [];
            this.$$state.pending.push([result, onFulfilled, onRejected, progressBack]);
            if (this.$$state.status > 0)
              scheduleProcessQueue(this.$$state);
            return result.promise;
          },
          "catch": function(callback) {
            return this.then(null, callback);
          },
          "finally": function(callback, progressBack) {
            return this.then(function(value) {
              return handleCallback(value, true, callback);
            }, function(error) {
              return handleCallback(error, false, callback);
            }, progressBack);
          }
        });
        function simpleBind(context, fn) {
          return function(value) {
            fn.call(context, value);
          };
        }
        function processQueue(state) {
          var fn,
              deferred,
              pending;
          pending = state.pending;
          state.processScheduled = false;
          state.pending = undefined;
          for (var i = 0,
              ii = pending.length; i < ii; ++i) {
            deferred = pending[i][0];
            fn = pending[i][state.status];
            try {
              if (isFunction(fn)) {
                deferred.resolve(fn(state.value));
              } else if (state.status === 1) {
                deferred.resolve(state.value);
              } else {
                deferred.reject(state.value);
              }
            } catch (e) {
              deferred.reject(e);
              exceptionHandler(e);
            }
          }
        }
        function scheduleProcessQueue(state) {
          if (state.processScheduled || !state.pending)
            return;
          state.processScheduled = true;
          nextTick(function() {
            processQueue(state);
          });
        }
        function Deferred() {
          this.promise = new Promise();
        }
        extend(Deferred.prototype, {
          resolve: function(val) {
            if (this.promise.$$state.status)
              return;
            if (val === this.promise) {
              this.$$reject($qMinErr('qcycle', "Expected promise to be resolved with value other than itself '{0}'", val));
            } else {
              this.$$resolve(val);
            }
          },
          $$resolve: function(val) {
            var then;
            var that = this;
            var done = false;
            try {
              if ((isObject(val) || isFunction(val)))
                then = val && val.then;
              if (isFunction(then)) {
                this.promise.$$state.status = -1;
                then.call(val, resolvePromise, rejectPromise, simpleBind(this, this.notify));
              } else {
                this.promise.$$state.value = val;
                this.promise.$$state.status = 1;
                scheduleProcessQueue(this.promise.$$state);
              }
            } catch (e) {
              rejectPromise(e);
              exceptionHandler(e);
            }
            function resolvePromise(val) {
              if (done)
                return;
              done = true;
              that.$$resolve(val);
            }
            function rejectPromise(val) {
              if (done)
                return;
              done = true;
              that.$$reject(val);
            }
          },
          reject: function(reason) {
            if (this.promise.$$state.status)
              return;
            this.$$reject(reason);
          },
          $$reject: function(reason) {
            this.promise.$$state.value = reason;
            this.promise.$$state.status = 2;
            scheduleProcessQueue(this.promise.$$state);
          },
          notify: function(progress) {
            var callbacks = this.promise.$$state.pending;
            if ((this.promise.$$state.status <= 0) && callbacks && callbacks.length) {
              nextTick(function() {
                var callback,
                    result;
                for (var i = 0,
                    ii = callbacks.length; i < ii; i++) {
                  result = callbacks[i][0];
                  callback = callbacks[i][3];
                  try {
                    result.notify(isFunction(callback) ? callback(progress) : progress);
                  } catch (e) {
                    exceptionHandler(e);
                  }
                }
              });
            }
          }
        });
        var reject = function(reason) {
          var result = new Deferred();
          result.reject(reason);
          return result.promise;
        };
        var makePromise = function makePromise(value, resolved) {
          var result = new Deferred();
          if (resolved) {
            result.resolve(value);
          } else {
            result.reject(value);
          }
          return result.promise;
        };
        var handleCallback = function handleCallback(value, isResolved, callback) {
          var callbackOutput = null;
          try {
            if (isFunction(callback))
              callbackOutput = callback();
          } catch (e) {
            return makePromise(e, false);
          }
          if (isPromiseLike(callbackOutput)) {
            return callbackOutput.then(function() {
              return makePromise(value, isResolved);
            }, function(error) {
              return makePromise(error, false);
            });
          } else {
            return makePromise(value, isResolved);
          }
        };
        var when = function(value, callback, errback, progressBack) {
          var result = new Deferred();
          result.resolve(value);
          return result.promise.then(callback, errback, progressBack);
        };
        var resolve = when;
        function all(promises) {
          var deferred = new Deferred(),
              counter = 0,
              results = isArray(promises) ? [] : {};
          forEach(promises, function(promise, key) {
            counter++;
            when(promise).then(function(value) {
              if (results.hasOwnProperty(key))
                return;
              results[key] = value;
              if (!(--counter))
                deferred.resolve(results);
            }, function(reason) {
              if (results.hasOwnProperty(key))
                return;
              deferred.reject(reason);
            });
          });
          if (counter === 0) {
            deferred.resolve(results);
          }
          return deferred.promise;
        }
        var $Q = function Q(resolver) {
          if (!isFunction(resolver)) {
            throw $qMinErr('norslvr', "Expected resolverFn, got '{0}'", resolver);
          }
          var deferred = new Deferred();
          function resolveFn(value) {
            deferred.resolve(value);
          }
          function rejectFn(reason) {
            deferred.reject(reason);
          }
          resolver(resolveFn, rejectFn);
          return deferred.promise;
        };
        $Q.prototype = Promise.prototype;
        $Q.defer = defer;
        $Q.reject = reject;
        $Q.when = when;
        $Q.resolve = resolve;
        $Q.all = all;
        return $Q;
      }
      function $$RAFProvider() {
        this.$get = ['$window', '$timeout', function($window, $timeout) {
          var requestAnimationFrame = $window.requestAnimationFrame || $window.webkitRequestAnimationFrame;
          var cancelAnimationFrame = $window.cancelAnimationFrame || $window.webkitCancelAnimationFrame || $window.webkitCancelRequestAnimationFrame;
          var rafSupported = !!requestAnimationFrame;
          var raf = rafSupported ? function(fn) {
            var id = requestAnimationFrame(fn);
            return function() {
              cancelAnimationFrame(id);
            };
          } : function(fn) {
            var timer = $timeout(fn, 16.66, false);
            return function() {
              $timeout.cancel(timer);
            };
          };
          raf.supported = rafSupported;
          return raf;
        }];
      }
      function $RootScopeProvider() {
        var TTL = 10;
        var $rootScopeMinErr = minErr('$rootScope');
        var lastDirtyWatch = null;
        var applyAsyncId = null;
        this.digestTtl = function(value) {
          if (arguments.length) {
            TTL = value;
          }
          return TTL;
        };
        function createChildScopeClass(parent) {
          function ChildScope() {
            this.$$watchers = this.$$nextSibling = this.$$childHead = this.$$childTail = null;
            this.$$listeners = {};
            this.$$listenerCount = {};
            this.$$watchersCount = 0;
            this.$id = nextUid();
            this.$$ChildScope = null;
          }
          ChildScope.prototype = parent;
          return ChildScope;
        }
        this.$get = ['$exceptionHandler', '$parse', '$browser', function($exceptionHandler, $parse, $browser) {
          function destroyChildScope($event) {
            $event.currentScope.$$destroyed = true;
          }
          function cleanUpScope($scope) {
            if (msie === 9) {
              $scope.$$childHead && cleanUpScope($scope.$$childHead);
              $scope.$$nextSibling && cleanUpScope($scope.$$nextSibling);
            }
            $scope.$parent = $scope.$$nextSibling = $scope.$$prevSibling = $scope.$$childHead = $scope.$$childTail = $scope.$root = $scope.$$watchers = null;
          }
          function Scope() {
            this.$id = nextUid();
            this.$$phase = this.$parent = this.$$watchers = this.$$nextSibling = this.$$prevSibling = this.$$childHead = this.$$childTail = null;
            this.$root = this;
            this.$$destroyed = false;
            this.$$listeners = {};
            this.$$listenerCount = {};
            this.$$watchersCount = 0;
            this.$$isolateBindings = null;
          }
          Scope.prototype = {
            constructor: Scope,
            $new: function(isolate, parent) {
              var child;
              parent = parent || this;
              if (isolate) {
                child = new Scope();
                child.$root = this.$root;
              } else {
                if (!this.$$ChildScope) {
                  this.$$ChildScope = createChildScopeClass(this);
                }
                child = new this.$$ChildScope();
              }
              child.$parent = parent;
              child.$$prevSibling = parent.$$childTail;
              if (parent.$$childHead) {
                parent.$$childTail.$$nextSibling = child;
                parent.$$childTail = child;
              } else {
                parent.$$childHead = parent.$$childTail = child;
              }
              if (isolate || parent != this)
                child.$on('$destroy', destroyChildScope);
              return child;
            },
            $watch: function(watchExp, listener, objectEquality, prettyPrintExpression) {
              var get = $parse(watchExp);
              if (get.$$watchDelegate) {
                return get.$$watchDelegate(this, listener, objectEquality, get, watchExp);
              }
              var scope = this,
                  array = scope.$$watchers,
                  watcher = {
                    fn: listener,
                    last: initWatchVal,
                    get: get,
                    exp: prettyPrintExpression || watchExp,
                    eq: !!objectEquality
                  };
              lastDirtyWatch = null;
              if (!isFunction(listener)) {
                watcher.fn = noop;
              }
              if (!array) {
                array = scope.$$watchers = [];
              }
              array.unshift(watcher);
              incrementWatchersCount(this, 1);
              return function deregisterWatch() {
                if (arrayRemove(array, watcher) >= 0) {
                  incrementWatchersCount(scope, -1);
                }
                lastDirtyWatch = null;
              };
            },
            $watchGroup: function(watchExpressions, listener) {
              var oldValues = new Array(watchExpressions.length);
              var newValues = new Array(watchExpressions.length);
              var deregisterFns = [];
              var self = this;
              var changeReactionScheduled = false;
              var firstRun = true;
              if (!watchExpressions.length) {
                var shouldCall = true;
                self.$evalAsync(function() {
                  if (shouldCall)
                    listener(newValues, newValues, self);
                });
                return function deregisterWatchGroup() {
                  shouldCall = false;
                };
              }
              if (watchExpressions.length === 1) {
                return this.$watch(watchExpressions[0], function watchGroupAction(value, oldValue, scope) {
                  newValues[0] = value;
                  oldValues[0] = oldValue;
                  listener(newValues, (value === oldValue) ? newValues : oldValues, scope);
                });
              }
              forEach(watchExpressions, function(expr, i) {
                var unwatchFn = self.$watch(expr, function watchGroupSubAction(value, oldValue) {
                  newValues[i] = value;
                  oldValues[i] = oldValue;
                  if (!changeReactionScheduled) {
                    changeReactionScheduled = true;
                    self.$evalAsync(watchGroupAction);
                  }
                });
                deregisterFns.push(unwatchFn);
              });
              function watchGroupAction() {
                changeReactionScheduled = false;
                if (firstRun) {
                  firstRun = false;
                  listener(newValues, newValues, self);
                } else {
                  listener(newValues, oldValues, self);
                }
              }
              return function deregisterWatchGroup() {
                while (deregisterFns.length) {
                  deregisterFns.shift()();
                }
              };
            },
            $watchCollection: function(obj, listener) {
              $watchCollectionInterceptor.$stateful = true;
              var self = this;
              var newValue;
              var oldValue;
              var veryOldValue;
              var trackVeryOldValue = (listener.length > 1);
              var changeDetected = 0;
              var changeDetector = $parse(obj, $watchCollectionInterceptor);
              var internalArray = [];
              var internalObject = {};
              var initRun = true;
              var oldLength = 0;
              function $watchCollectionInterceptor(_value) {
                newValue = _value;
                var newLength,
                    key,
                    bothNaN,
                    newItem,
                    oldItem;
                if (isUndefined(newValue))
                  return;
                if (!isObject(newValue)) {
                  if (oldValue !== newValue) {
                    oldValue = newValue;
                    changeDetected++;
                  }
                } else if (isArrayLike(newValue)) {
                  if (oldValue !== internalArray) {
                    oldValue = internalArray;
                    oldLength = oldValue.length = 0;
                    changeDetected++;
                  }
                  newLength = newValue.length;
                  if (oldLength !== newLength) {
                    changeDetected++;
                    oldValue.length = oldLength = newLength;
                  }
                  for (var i = 0; i < newLength; i++) {
                    oldItem = oldValue[i];
                    newItem = newValue[i];
                    bothNaN = (oldItem !== oldItem) && (newItem !== newItem);
                    if (!bothNaN && (oldItem !== newItem)) {
                      changeDetected++;
                      oldValue[i] = newItem;
                    }
                  }
                } else {
                  if (oldValue !== internalObject) {
                    oldValue = internalObject = {};
                    oldLength = 0;
                    changeDetected++;
                  }
                  newLength = 0;
                  for (key in newValue) {
                    if (hasOwnProperty.call(newValue, key)) {
                      newLength++;
                      newItem = newValue[key];
                      oldItem = oldValue[key];
                      if (key in oldValue) {
                        bothNaN = (oldItem !== oldItem) && (newItem !== newItem);
                        if (!bothNaN && (oldItem !== newItem)) {
                          changeDetected++;
                          oldValue[key] = newItem;
                        }
                      } else {
                        oldLength++;
                        oldValue[key] = newItem;
                        changeDetected++;
                      }
                    }
                  }
                  if (oldLength > newLength) {
                    changeDetected++;
                    for (key in oldValue) {
                      if (!hasOwnProperty.call(newValue, key)) {
                        oldLength--;
                        delete oldValue[key];
                      }
                    }
                  }
                }
                return changeDetected;
              }
              function $watchCollectionAction() {
                if (initRun) {
                  initRun = false;
                  listener(newValue, newValue, self);
                } else {
                  listener(newValue, veryOldValue, self);
                }
                if (trackVeryOldValue) {
                  if (!isObject(newValue)) {
                    veryOldValue = newValue;
                  } else if (isArrayLike(newValue)) {
                    veryOldValue = new Array(newValue.length);
                    for (var i = 0; i < newValue.length; i++) {
                      veryOldValue[i] = newValue[i];
                    }
                  } else {
                    veryOldValue = {};
                    for (var key in newValue) {
                      if (hasOwnProperty.call(newValue, key)) {
                        veryOldValue[key] = newValue[key];
                      }
                    }
                  }
                }
              }
              return this.$watch(changeDetector, $watchCollectionAction);
            },
            $digest: function() {
              var watch,
                  value,
                  last,
                  fn,
                  get,
                  watchers,
                  length,
                  dirty,
                  ttl = TTL,
                  next,
                  current,
                  target = this,
                  watchLog = [],
                  logIdx,
                  asyncTask;
              beginPhase('$digest');
              $browser.$$checkUrlChange();
              if (this === $rootScope && applyAsyncId !== null) {
                $browser.defer.cancel(applyAsyncId);
                flushApplyAsync();
              }
              lastDirtyWatch = null;
              do {
                dirty = false;
                current = target;
                for (var asyncQueuePosition = 0; asyncQueuePosition < asyncQueue.length; asyncQueuePosition++) {
                  try {
                    asyncTask = asyncQueue[asyncQueuePosition];
                    asyncTask.scope.$eval(asyncTask.expression, asyncTask.locals);
                  } catch (e) {
                    $exceptionHandler(e);
                  }
                  lastDirtyWatch = null;
                }
                asyncQueue.length = 0;
                traverseScopesLoop: do {
                  if ((watchers = current.$$watchers)) {
                    length = watchers.length;
                    while (length--) {
                      try {
                        watch = watchers[length];
                        if (watch) {
                          get = watch.get;
                          if ((value = get(current)) !== (last = watch.last) && !(watch.eq ? equals(value, last) : (typeof value === 'number' && typeof last === 'number' && isNaN(value) && isNaN(last)))) {
                            dirty = true;
                            lastDirtyWatch = watch;
                            watch.last = watch.eq ? copy(value, null) : value;
                            fn = watch.fn;
                            fn(value, ((last === initWatchVal) ? value : last), current);
                            if (ttl < 5) {
                              logIdx = 4 - ttl;
                              if (!watchLog[logIdx])
                                watchLog[logIdx] = [];
                              watchLog[logIdx].push({
                                msg: isFunction(watch.exp) ? 'fn: ' + (watch.exp.name || watch.exp.toString()) : watch.exp,
                                newVal: value,
                                oldVal: last
                              });
                            }
                          } else if (watch === lastDirtyWatch) {
                            dirty = false;
                            break traverseScopesLoop;
                          }
                        }
                      } catch (e) {
                        $exceptionHandler(e);
                      }
                    }
                  }
                  if (!(next = ((current.$$watchersCount && current.$$childHead) || (current !== target && current.$$nextSibling)))) {
                    while (current !== target && !(next = current.$$nextSibling)) {
                      current = current.$parent;
                    }
                  }
                } while ((current = next));
                if ((dirty || asyncQueue.length) && !(ttl--)) {
                  clearPhase();
                  throw $rootScopeMinErr('infdig', '{0} $digest() iterations reached. Aborting!\n' + 'Watchers fired in the last 5 iterations: {1}', TTL, watchLog);
                }
              } while (dirty || asyncQueue.length);
              clearPhase();
              while (postDigestQueuePosition < postDigestQueue.length) {
                try {
                  postDigestQueue[postDigestQueuePosition++]();
                } catch (e) {
                  $exceptionHandler(e);
                }
              }
              postDigestQueue.length = postDigestQueuePosition = 0;
            },
            $destroy: function() {
              if (this.$$destroyed)
                return;
              var parent = this.$parent;
              this.$broadcast('$destroy');
              this.$$destroyed = true;
              if (this === $rootScope) {
                $browser.$$applicationDestroyed();
              }
              incrementWatchersCount(this, -this.$$watchersCount);
              for (var eventName in this.$$listenerCount) {
                decrementListenerCount(this, this.$$listenerCount[eventName], eventName);
              }
              if (parent && parent.$$childHead == this)
                parent.$$childHead = this.$$nextSibling;
              if (parent && parent.$$childTail == this)
                parent.$$childTail = this.$$prevSibling;
              if (this.$$prevSibling)
                this.$$prevSibling.$$nextSibling = this.$$nextSibling;
              if (this.$$nextSibling)
                this.$$nextSibling.$$prevSibling = this.$$prevSibling;
              this.$destroy = this.$digest = this.$apply = this.$evalAsync = this.$applyAsync = noop;
              this.$on = this.$watch = this.$watchGroup = function() {
                return noop;
              };
              this.$$listeners = {};
              this.$$nextSibling = null;
              cleanUpScope(this);
            },
            $eval: function(expr, locals) {
              return $parse(expr)(this, locals);
            },
            $evalAsync: function(expr, locals) {
              if (!$rootScope.$$phase && !asyncQueue.length) {
                $browser.defer(function() {
                  if (asyncQueue.length) {
                    $rootScope.$digest();
                  }
                });
              }
              asyncQueue.push({
                scope: this,
                expression: $parse(expr),
                locals: locals
              });
            },
            $$postDigest: function(fn) {
              postDigestQueue.push(fn);
            },
            $apply: function(expr) {
              try {
                beginPhase('$apply');
                try {
                  return this.$eval(expr);
                } finally {
                  clearPhase();
                }
              } catch (e) {
                $exceptionHandler(e);
              } finally {
                try {
                  $rootScope.$digest();
                } catch (e) {
                  $exceptionHandler(e);
                  throw e;
                }
              }
            },
            $applyAsync: function(expr) {
              var scope = this;
              expr && applyAsyncQueue.push($applyAsyncExpression);
              expr = $parse(expr);
              scheduleApplyAsync();
              function $applyAsyncExpression() {
                scope.$eval(expr);
              }
            },
            $on: function(name, listener) {
              var namedListeners = this.$$listeners[name];
              if (!namedListeners) {
                this.$$listeners[name] = namedListeners = [];
              }
              namedListeners.push(listener);
              var current = this;
              do {
                if (!current.$$listenerCount[name]) {
                  current.$$listenerCount[name] = 0;
                }
                current.$$listenerCount[name]++;
              } while ((current = current.$parent));
              var self = this;
              return function() {
                var indexOfListener = namedListeners.indexOf(listener);
                if (indexOfListener !== -1) {
                  namedListeners[indexOfListener] = null;
                  decrementListenerCount(self, 1, name);
                }
              };
            },
            $emit: function(name, args) {
              var empty = [],
                  namedListeners,
                  scope = this,
                  stopPropagation = false,
                  event = {
                    name: name,
                    targetScope: scope,
                    stopPropagation: function() {
                      stopPropagation = true;
                    },
                    preventDefault: function() {
                      event.defaultPrevented = true;
                    },
                    defaultPrevented: false
                  },
                  listenerArgs = concat([event], arguments, 1),
                  i,
                  length;
              do {
                namedListeners = scope.$$listeners[name] || empty;
                event.currentScope = scope;
                for (i = 0, length = namedListeners.length; i < length; i++) {
                  if (!namedListeners[i]) {
                    namedListeners.splice(i, 1);
                    i--;
                    length--;
                    continue;
                  }
                  try {
                    namedListeners[i].apply(null, listenerArgs);
                  } catch (e) {
                    $exceptionHandler(e);
                  }
                }
                if (stopPropagation) {
                  event.currentScope = null;
                  return event;
                }
                scope = scope.$parent;
              } while (scope);
              event.currentScope = null;
              return event;
            },
            $broadcast: function(name, args) {
              var target = this,
                  current = target,
                  next = target,
                  event = {
                    name: name,
                    targetScope: target,
                    preventDefault: function() {
                      event.defaultPrevented = true;
                    },
                    defaultPrevented: false
                  };
              if (!target.$$listenerCount[name])
                return event;
              var listenerArgs = concat([event], arguments, 1),
                  listeners,
                  i,
                  length;
              while ((current = next)) {
                event.currentScope = current;
                listeners = current.$$listeners[name] || [];
                for (i = 0, length = listeners.length; i < length; i++) {
                  if (!listeners[i]) {
                    listeners.splice(i, 1);
                    i--;
                    length--;
                    continue;
                  }
                  try {
                    listeners[i].apply(null, listenerArgs);
                  } catch (e) {
                    $exceptionHandler(e);
                  }
                }
                if (!(next = ((current.$$listenerCount[name] && current.$$childHead) || (current !== target && current.$$nextSibling)))) {
                  while (current !== target && !(next = current.$$nextSibling)) {
                    current = current.$parent;
                  }
                }
              }
              event.currentScope = null;
              return event;
            }
          };
          var $rootScope = new Scope();
          var asyncQueue = $rootScope.$$asyncQueue = [];
          var postDigestQueue = $rootScope.$$postDigestQueue = [];
          var applyAsyncQueue = $rootScope.$$applyAsyncQueue = [];
          var postDigestQueuePosition = 0;
          return $rootScope;
          function beginPhase(phase) {
            if ($rootScope.$$phase) {
              throw $rootScopeMinErr('inprog', '{0} already in progress', $rootScope.$$phase);
            }
            $rootScope.$$phase = phase;
          }
          function clearPhase() {
            $rootScope.$$phase = null;
          }
          function incrementWatchersCount(current, count) {
            do {
              current.$$watchersCount += count;
            } while ((current = current.$parent));
          }
          function decrementListenerCount(current, count, name) {
            do {
              current.$$listenerCount[name] -= count;
              if (current.$$listenerCount[name] === 0) {
                delete current.$$listenerCount[name];
              }
            } while ((current = current.$parent));
          }
          function initWatchVal() {}
          function flushApplyAsync() {
            while (applyAsyncQueue.length) {
              try {
                applyAsyncQueue.shift()();
              } catch (e) {
                $exceptionHandler(e);
              }
            }
            applyAsyncId = null;
          }
          function scheduleApplyAsync() {
            if (applyAsyncId === null) {
              applyAsyncId = $browser.defer(function() {
                $rootScope.$apply(flushApplyAsync);
              });
            }
          }
        }];
      }
      function $$SanitizeUriProvider() {
        var aHrefSanitizationWhitelist = /^\s*(https?|ftp|mailto|tel|file):/,
            imgSrcSanitizationWhitelist = /^\s*((https?|ftp|file|blob):|data:image\/)/;
        this.aHrefSanitizationWhitelist = function(regexp) {
          if (isDefined(regexp)) {
            aHrefSanitizationWhitelist = regexp;
            return this;
          }
          return aHrefSanitizationWhitelist;
        };
        this.imgSrcSanitizationWhitelist = function(regexp) {
          if (isDefined(regexp)) {
            imgSrcSanitizationWhitelist = regexp;
            return this;
          }
          return imgSrcSanitizationWhitelist;
        };
        this.$get = function() {
          return function sanitizeUri(uri, isImage) {
            var regex = isImage ? imgSrcSanitizationWhitelist : aHrefSanitizationWhitelist;
            var normalizedVal;
            normalizedVal = urlResolve(uri).href;
            if (normalizedVal !== '' && !normalizedVal.match(regex)) {
              return 'unsafe:' + normalizedVal;
            }
            return uri;
          };
        };
      }
      var $sceMinErr = minErr('$sce');
      var SCE_CONTEXTS = {
        HTML: 'html',
        CSS: 'css',
        URL: 'url',
        RESOURCE_URL: 'resourceUrl',
        JS: 'js'
      };
      function adjustMatcher(matcher) {
        if (matcher === 'self') {
          return matcher;
        } else if (isString(matcher)) {
          if (matcher.indexOf('***') > -1) {
            throw $sceMinErr('iwcard', 'Illegal sequence *** in string matcher.  String: {0}', matcher);
          }
          matcher = escapeForRegexp(matcher).replace('\\*\\*', '.*').replace('\\*', '[^:/.?&;]*');
          return new RegExp('^' + matcher + '$');
        } else if (isRegExp(matcher)) {
          return new RegExp('^' + matcher.source + '$');
        } else {
          throw $sceMinErr('imatcher', 'Matchers may only be "self", string patterns or RegExp objects');
        }
      }
      function adjustMatchers(matchers) {
        var adjustedMatchers = [];
        if (isDefined(matchers)) {
          forEach(matchers, function(matcher) {
            adjustedMatchers.push(adjustMatcher(matcher));
          });
        }
        return adjustedMatchers;
      }
      function $SceDelegateProvider() {
        this.SCE_CONTEXTS = SCE_CONTEXTS;
        var resourceUrlWhitelist = ['self'],
            resourceUrlBlacklist = [];
        this.resourceUrlWhitelist = function(value) {
          if (arguments.length) {
            resourceUrlWhitelist = adjustMatchers(value);
          }
          return resourceUrlWhitelist;
        };
        this.resourceUrlBlacklist = function(value) {
          if (arguments.length) {
            resourceUrlBlacklist = adjustMatchers(value);
          }
          return resourceUrlBlacklist;
        };
        this.$get = ['$injector', function($injector) {
          var htmlSanitizer = function htmlSanitizer(html) {
            throw $sceMinErr('unsafe', 'Attempting to use an unsafe value in a safe context.');
          };
          if ($injector.has('$sanitize')) {
            htmlSanitizer = $injector.get('$sanitize');
          }
          function matchUrl(matcher, parsedUrl) {
            if (matcher === 'self') {
              return urlIsSameOrigin(parsedUrl);
            } else {
              return !!matcher.exec(parsedUrl.href);
            }
          }
          function isResourceUrlAllowedByPolicy(url) {
            var parsedUrl = urlResolve(url.toString());
            var i,
                n,
                allowed = false;
            for (i = 0, n = resourceUrlWhitelist.length; i < n; i++) {
              if (matchUrl(resourceUrlWhitelist[i], parsedUrl)) {
                allowed = true;
                break;
              }
            }
            if (allowed) {
              for (i = 0, n = resourceUrlBlacklist.length; i < n; i++) {
                if (matchUrl(resourceUrlBlacklist[i], parsedUrl)) {
                  allowed = false;
                  break;
                }
              }
            }
            return allowed;
          }
          function generateHolderType(Base) {
            var holderType = function TrustedValueHolderType(trustedValue) {
              this.$$unwrapTrustedValue = function() {
                return trustedValue;
              };
            };
            if (Base) {
              holderType.prototype = new Base();
            }
            holderType.prototype.valueOf = function sceValueOf() {
              return this.$$unwrapTrustedValue();
            };
            holderType.prototype.toString = function sceToString() {
              return this.$$unwrapTrustedValue().toString();
            };
            return holderType;
          }
          var trustedValueHolderBase = generateHolderType(),
              byType = {};
          byType[SCE_CONTEXTS.HTML] = generateHolderType(trustedValueHolderBase);
          byType[SCE_CONTEXTS.CSS] = generateHolderType(trustedValueHolderBase);
          byType[SCE_CONTEXTS.URL] = generateHolderType(trustedValueHolderBase);
          byType[SCE_CONTEXTS.JS] = generateHolderType(trustedValueHolderBase);
          byType[SCE_CONTEXTS.RESOURCE_URL] = generateHolderType(byType[SCE_CONTEXTS.URL]);
          function trustAs(type, trustedValue) {
            var Constructor = (byType.hasOwnProperty(type) ? byType[type] : null);
            if (!Constructor) {
              throw $sceMinErr('icontext', 'Attempted to trust a value in invalid context. Context: {0}; Value: {1}', type, trustedValue);
            }
            if (trustedValue === null || isUndefined(trustedValue) || trustedValue === '') {
              return trustedValue;
            }
            if (typeof trustedValue !== 'string') {
              throw $sceMinErr('itype', 'Attempted to trust a non-string value in a content requiring a string: Context: {0}', type);
            }
            return new Constructor(trustedValue);
          }
          function valueOf(maybeTrusted) {
            if (maybeTrusted instanceof trustedValueHolderBase) {
              return maybeTrusted.$$unwrapTrustedValue();
            } else {
              return maybeTrusted;
            }
          }
          function getTrusted(type, maybeTrusted) {
            if (maybeTrusted === null || isUndefined(maybeTrusted) || maybeTrusted === '') {
              return maybeTrusted;
            }
            var constructor = (byType.hasOwnProperty(type) ? byType[type] : null);
            if (constructor && maybeTrusted instanceof constructor) {
              return maybeTrusted.$$unwrapTrustedValue();
            }
            if (type === SCE_CONTEXTS.RESOURCE_URL) {
              if (isResourceUrlAllowedByPolicy(maybeTrusted)) {
                return maybeTrusted;
              } else {
                throw $sceMinErr('insecurl', 'Blocked loading resource from url not allowed by $sceDelegate policy.  URL: {0}', maybeTrusted.toString());
              }
            } else if (type === SCE_CONTEXTS.HTML) {
              return htmlSanitizer(maybeTrusted);
            }
            throw $sceMinErr('unsafe', 'Attempting to use an unsafe value in a safe context.');
          }
          return {
            trustAs: trustAs,
            getTrusted: getTrusted,
            valueOf: valueOf
          };
        }];
      }
      function $SceProvider() {
        var enabled = true;
        this.enabled = function(value) {
          if (arguments.length) {
            enabled = !!value;
          }
          return enabled;
        };
        this.$get = ['$parse', '$sceDelegate', function($parse, $sceDelegate) {
          if (enabled && msie < 8) {
            throw $sceMinErr('iequirks', 'Strict Contextual Escaping does not support Internet Explorer version < 11 in quirks ' + 'mode.  You can fix this by adding the text <!doctype html> to the top of your HTML ' + 'document.  See http://docs.angularjs.org/api/ng.$sce for more information.');
          }
          var sce = shallowCopy(SCE_CONTEXTS);
          sce.isEnabled = function() {
            return enabled;
          };
          sce.trustAs = $sceDelegate.trustAs;
          sce.getTrusted = $sceDelegate.getTrusted;
          sce.valueOf = $sceDelegate.valueOf;
          if (!enabled) {
            sce.trustAs = sce.getTrusted = function(type, value) {
              return value;
            };
            sce.valueOf = identity;
          }
          sce.parseAs = function sceParseAs(type, expr) {
            var parsed = $parse(expr);
            if (parsed.literal && parsed.constant) {
              return parsed;
            } else {
              return $parse(expr, function(value) {
                return sce.getTrusted(type, value);
              });
            }
          };
          var parse = sce.parseAs,
              getTrusted = sce.getTrusted,
              trustAs = sce.trustAs;
          forEach(SCE_CONTEXTS, function(enumValue, name) {
            var lName = lowercase(name);
            sce[camelCase("parse_as_" + lName)] = function(expr) {
              return parse(enumValue, expr);
            };
            sce[camelCase("get_trusted_" + lName)] = function(value) {
              return getTrusted(enumValue, value);
            };
            sce[camelCase("trust_as_" + lName)] = function(value) {
              return trustAs(enumValue, value);
            };
          });
          return sce;
        }];
      }
      function $SnifferProvider() {
        this.$get = ['$window', '$document', function($window, $document) {
          var eventSupport = {},
              isChromePackagedApp = $window.chrome && $window.chrome.app && $window.chrome.app.runtime,
              hasHistoryPushState = !isChromePackagedApp && $window.history && $window.history.pushState,
              android = toInt((/android (\d+)/.exec(lowercase(($window.navigator || {}).userAgent)) || [])[1]),
              boxee = /Boxee/i.test(($window.navigator || {}).userAgent),
              document = $document[0] || {},
              vendorPrefix,
              vendorRegex = /^(Moz|webkit|ms)(?=[A-Z])/,
              bodyStyle = document.body && document.body.style,
              transitions = false,
              animations = false,
              match;
          if (bodyStyle) {
            for (var prop in bodyStyle) {
              if (match = vendorRegex.exec(prop)) {
                vendorPrefix = match[0];
                vendorPrefix = vendorPrefix[0].toUpperCase() + vendorPrefix.substr(1);
                break;
              }
            }
            if (!vendorPrefix) {
              vendorPrefix = ('WebkitOpacity' in bodyStyle) && 'webkit';
            }
            transitions = !!(('transition' in bodyStyle) || (vendorPrefix + 'Transition' in bodyStyle));
            animations = !!(('animation' in bodyStyle) || (vendorPrefix + 'Animation' in bodyStyle));
            if (android && (!transitions || !animations)) {
              transitions = isString(bodyStyle.webkitTransition);
              animations = isString(bodyStyle.webkitAnimation);
            }
          }
          return {
            history: !!(hasHistoryPushState && !(android < 4) && !boxee),
            hasEvent: function(event) {
              if (event === 'input' && msie <= 11)
                return false;
              if (isUndefined(eventSupport[event])) {
                var divElm = document.createElement('div');
                eventSupport[event] = 'on' + event in divElm;
              }
              return eventSupport[event];
            },
            csp: csp(),
            vendorPrefix: vendorPrefix,
            transitions: transitions,
            animations: animations,
            android: android
          };
        }];
      }
      var $templateRequestMinErr = minErr('$compile');
      function $TemplateRequestProvider() {
        var httpOptions;
        this.httpOptions = function(val) {
          if (val) {
            httpOptions = val;
            return this;
          }
          return httpOptions;
        };
        this.$get = ['$templateCache', '$http', '$q', '$sce', function($templateCache, $http, $q, $sce) {
          function handleRequestFn(tpl, ignoreRequestError) {
            handleRequestFn.totalPendingRequests++;
            if (!isString(tpl) || isUndefined($templateCache.get(tpl))) {
              tpl = $sce.getTrustedResourceUrl(tpl);
            }
            var transformResponse = $http.defaults && $http.defaults.transformResponse;
            if (isArray(transformResponse)) {
              transformResponse = transformResponse.filter(function(transformer) {
                return transformer !== defaultHttpResponseTransform;
              });
            } else if (transformResponse === defaultHttpResponseTransform) {
              transformResponse = null;
            }
            return $http.get(tpl, extend({
              cache: $templateCache,
              transformResponse: transformResponse
            }, httpOptions))['finally'](function() {
              handleRequestFn.totalPendingRequests--;
            }).then(function(response) {
              $templateCache.put(tpl, response.data);
              return response.data;
            }, handleError);
            function handleError(resp) {
              if (!ignoreRequestError) {
                throw $templateRequestMinErr('tpload', 'Failed to load template: {0} (HTTP status: {1} {2})', tpl, resp.status, resp.statusText);
              }
              return $q.reject(resp);
            }
          }
          handleRequestFn.totalPendingRequests = 0;
          return handleRequestFn;
        }];
      }
      function $$TestabilityProvider() {
        this.$get = ['$rootScope', '$browser', '$location', function($rootScope, $browser, $location) {
          var testability = {};
          testability.findBindings = function(element, expression, opt_exactMatch) {
            var bindings = element.getElementsByClassName('ng-binding');
            var matches = [];
            forEach(bindings, function(binding) {
              var dataBinding = angular.element(binding).data('$binding');
              if (dataBinding) {
                forEach(dataBinding, function(bindingName) {
                  if (opt_exactMatch) {
                    var matcher = new RegExp('(^|\\s)' + escapeForRegexp(expression) + '(\\s|\\||$)');
                    if (matcher.test(bindingName)) {
                      matches.push(binding);
                    }
                  } else {
                    if (bindingName.indexOf(expression) != -1) {
                      matches.push(binding);
                    }
                  }
                });
              }
            });
            return matches;
          };
          testability.findModels = function(element, expression, opt_exactMatch) {
            var prefixes = ['ng-', 'data-ng-', 'ng\\:'];
            for (var p = 0; p < prefixes.length; ++p) {
              var attributeEquals = opt_exactMatch ? '=' : '*=';
              var selector = '[' + prefixes[p] + 'model' + attributeEquals + '"' + expression + '"]';
              var elements = element.querySelectorAll(selector);
              if (elements.length) {
                return elements;
              }
            }
          };
          testability.getLocation = function() {
            return $location.url();
          };
          testability.setLocation = function(url) {
            if (url !== $location.url()) {
              $location.url(url);
              $rootScope.$digest();
            }
          };
          testability.whenStable = function(callback) {
            $browser.notifyWhenNoOutstandingRequests(callback);
          };
          return testability;
        }];
      }
      function $TimeoutProvider() {
        this.$get = ['$rootScope', '$browser', '$q', '$$q', '$exceptionHandler', function($rootScope, $browser, $q, $$q, $exceptionHandler) {
          var deferreds = {};
          function timeout(fn, delay, invokeApply) {
            if (!isFunction(fn)) {
              invokeApply = delay;
              delay = fn;
              fn = noop;
            }
            var args = sliceArgs(arguments, 3),
                skipApply = (isDefined(invokeApply) && !invokeApply),
                deferred = (skipApply ? $$q : $q).defer(),
                promise = deferred.promise,
                timeoutId;
            timeoutId = $browser.defer(function() {
              try {
                deferred.resolve(fn.apply(null, args));
              } catch (e) {
                deferred.reject(e);
                $exceptionHandler(e);
              } finally {
                delete deferreds[promise.$$timeoutId];
              }
              if (!skipApply)
                $rootScope.$apply();
            }, delay);
            promise.$$timeoutId = timeoutId;
            deferreds[timeoutId] = deferred;
            return promise;
          }
          timeout.cancel = function(promise) {
            if (promise && promise.$$timeoutId in deferreds) {
              deferreds[promise.$$timeoutId].reject('canceled');
              delete deferreds[promise.$$timeoutId];
              return $browser.defer.cancel(promise.$$timeoutId);
            }
            return false;
          };
          return timeout;
        }];
      }
      var urlParsingNode = window.document.createElement("a");
      var originUrl = urlResolve(window.location.href);
      function urlResolve(url) {
        var href = url;
        if (msie) {
          urlParsingNode.setAttribute("href", href);
          href = urlParsingNode.href;
        }
        urlParsingNode.setAttribute('href', href);
        return {
          href: urlParsingNode.href,
          protocol: urlParsingNode.protocol ? urlParsingNode.protocol.replace(/:$/, '') : '',
          host: urlParsingNode.host,
          search: urlParsingNode.search ? urlParsingNode.search.replace(/^\?/, '') : '',
          hash: urlParsingNode.hash ? urlParsingNode.hash.replace(/^#/, '') : '',
          hostname: urlParsingNode.hostname,
          port: urlParsingNode.port,
          pathname: (urlParsingNode.pathname.charAt(0) === '/') ? urlParsingNode.pathname : '/' + urlParsingNode.pathname
        };
      }
      function urlIsSameOrigin(requestUrl) {
        var parsed = (isString(requestUrl)) ? urlResolve(requestUrl) : requestUrl;
        return (parsed.protocol === originUrl.protocol && parsed.host === originUrl.host);
      }
      function $WindowProvider() {
        this.$get = valueFn(window);
      }
      function $$CookieReader($document) {
        var rawDocument = $document[0] || {};
        var lastCookies = {};
        var lastCookieString = '';
        function safeDecodeURIComponent(str) {
          try {
            return decodeURIComponent(str);
          } catch (e) {
            return str;
          }
        }
        return function() {
          var cookieArray,
              cookie,
              i,
              index,
              name;
          var currentCookieString = rawDocument.cookie || '';
          if (currentCookieString !== lastCookieString) {
            lastCookieString = currentCookieString;
            cookieArray = lastCookieString.split('; ');
            lastCookies = {};
            for (i = 0; i < cookieArray.length; i++) {
              cookie = cookieArray[i];
              index = cookie.indexOf('=');
              if (index > 0) {
                name = safeDecodeURIComponent(cookie.substring(0, index));
                if (isUndefined(lastCookies[name])) {
                  lastCookies[name] = safeDecodeURIComponent(cookie.substring(index + 1));
                }
              }
            }
          }
          return lastCookies;
        };
      }
      $$CookieReader.$inject = ['$document'];
      function $$CookieReaderProvider() {
        this.$get = $$CookieReader;
      }
      $FilterProvider.$inject = ['$provide'];
      function $FilterProvider($provide) {
        var suffix = 'Filter';
        function register(name, factory) {
          if (isObject(name)) {
            var filters = {};
            forEach(name, function(filter, key) {
              filters[key] = register(key, filter);
            });
            return filters;
          } else {
            return $provide.factory(name + suffix, factory);
          }
        }
        this.register = register;
        this.$get = ['$injector', function($injector) {
          return function(name) {
            return $injector.get(name + suffix);
          };
        }];
        register('currency', currencyFilter);
        register('date', dateFilter);
        register('filter', filterFilter);
        register('json', jsonFilter);
        register('limitTo', limitToFilter);
        register('lowercase', lowercaseFilter);
        register('number', numberFilter);
        register('orderBy', orderByFilter);
        register('uppercase', uppercaseFilter);
      }
      function filterFilter() {
        return function(array, expression, comparator) {
          if (!isArrayLike(array)) {
            if (array == null) {
              return array;
            } else {
              throw minErr('filter')('notarray', 'Expected array but received: {0}', array);
            }
          }
          var expressionType = getTypeForFilter(expression);
          var predicateFn;
          var matchAgainstAnyProp;
          switch (expressionType) {
            case 'function':
              predicateFn = expression;
              break;
            case 'boolean':
            case 'null':
            case 'number':
            case 'string':
              matchAgainstAnyProp = true;
            case 'object':
              predicateFn = createPredicateFn(expression, comparator, matchAgainstAnyProp);
              break;
            default:
              return array;
          }
          return Array.prototype.filter.call(array, predicateFn);
        };
      }
      function createPredicateFn(expression, comparator, matchAgainstAnyProp) {
        var shouldMatchPrimitives = isObject(expression) && ('$' in expression);
        var predicateFn;
        if (comparator === true) {
          comparator = equals;
        } else if (!isFunction(comparator)) {
          comparator = function(actual, expected) {
            if (isUndefined(actual)) {
              return false;
            }
            if ((actual === null) || (expected === null)) {
              return actual === expected;
            }
            if (isObject(expected) || (isObject(actual) && !hasCustomToString(actual))) {
              return false;
            }
            actual = lowercase('' + actual);
            expected = lowercase('' + expected);
            return actual.indexOf(expected) !== -1;
          };
        }
        predicateFn = function(item) {
          if (shouldMatchPrimitives && !isObject(item)) {
            return deepCompare(item, expression.$, comparator, false);
          }
          return deepCompare(item, expression, comparator, matchAgainstAnyProp);
        };
        return predicateFn;
      }
      function deepCompare(actual, expected, comparator, matchAgainstAnyProp, dontMatchWholeObject) {
        var actualType = getTypeForFilter(actual);
        var expectedType = getTypeForFilter(expected);
        if ((expectedType === 'string') && (expected.charAt(0) === '!')) {
          return !deepCompare(actual, expected.substring(1), comparator, matchAgainstAnyProp);
        } else if (isArray(actual)) {
          return actual.some(function(item) {
            return deepCompare(item, expected, comparator, matchAgainstAnyProp);
          });
        }
        switch (actualType) {
          case 'object':
            var key;
            if (matchAgainstAnyProp) {
              for (key in actual) {
                if ((key.charAt(0) !== '$') && deepCompare(actual[key], expected, comparator, true)) {
                  return true;
                }
              }
              return dontMatchWholeObject ? false : deepCompare(actual, expected, comparator, false);
            } else if (expectedType === 'object') {
              for (key in expected) {
                var expectedVal = expected[key];
                if (isFunction(expectedVal) || isUndefined(expectedVal)) {
                  continue;
                }
                var matchAnyProperty = key === '$';
                var actualVal = matchAnyProperty ? actual : actual[key];
                if (!deepCompare(actualVal, expectedVal, comparator, matchAnyProperty, matchAnyProperty)) {
                  return false;
                }
              }
              return true;
            } else {
              return comparator(actual, expected);
            }
            break;
          case 'function':
            return false;
          default:
            return comparator(actual, expected);
        }
      }
      function getTypeForFilter(val) {
        return (val === null) ? 'null' : typeof val;
      }
      var MAX_DIGITS = 22;
      var DECIMAL_SEP = '.';
      var ZERO_CHAR = '0';
      currencyFilter.$inject = ['$locale'];
      function currencyFilter($locale) {
        var formats = $locale.NUMBER_FORMATS;
        return function(amount, currencySymbol, fractionSize) {
          if (isUndefined(currencySymbol)) {
            currencySymbol = formats.CURRENCY_SYM;
          }
          if (isUndefined(fractionSize)) {
            fractionSize = formats.PATTERNS[1].maxFrac;
          }
          return (amount == null) ? amount : formatNumber(amount, formats.PATTERNS[1], formats.GROUP_SEP, formats.DECIMAL_SEP, fractionSize).replace(/\u00A4/g, currencySymbol);
        };
      }
      numberFilter.$inject = ['$locale'];
      function numberFilter($locale) {
        var formats = $locale.NUMBER_FORMATS;
        return function(number, fractionSize) {
          return (number == null) ? number : formatNumber(number, formats.PATTERNS[0], formats.GROUP_SEP, formats.DECIMAL_SEP, fractionSize);
        };
      }
      function parse(numStr) {
        var exponent = 0,
            digits,
            numberOfIntegerDigits;
        var i,
            j,
            zeros;
        if ((numberOfIntegerDigits = numStr.indexOf(DECIMAL_SEP)) > -1) {
          numStr = numStr.replace(DECIMAL_SEP, '');
        }
        if ((i = numStr.search(/e/i)) > 0) {
          if (numberOfIntegerDigits < 0)
            numberOfIntegerDigits = i;
          numberOfIntegerDigits += +numStr.slice(i + 1);
          numStr = numStr.substring(0, i);
        } else if (numberOfIntegerDigits < 0) {
          numberOfIntegerDigits = numStr.length;
        }
        for (i = 0; numStr.charAt(i) == ZERO_CHAR; i++) {}
        if (i == (zeros = numStr.length)) {
          digits = [0];
          numberOfIntegerDigits = 1;
        } else {
          zeros--;
          while (numStr.charAt(zeros) == ZERO_CHAR)
            zeros--;
          numberOfIntegerDigits -= i;
          digits = [];
          for (j = 0; i <= zeros; i++, j++) {
            digits[j] = +numStr.charAt(i);
          }
        }
        if (numberOfIntegerDigits > MAX_DIGITS) {
          digits = digits.splice(0, MAX_DIGITS - 1);
          exponent = numberOfIntegerDigits - 1;
          numberOfIntegerDigits = 1;
        }
        return {
          d: digits,
          e: exponent,
          i: numberOfIntegerDigits
        };
      }
      function roundNumber(parsedNumber, fractionSize, minFrac, maxFrac) {
        var digits = parsedNumber.d;
        var fractionLen = digits.length - parsedNumber.i;
        fractionSize = (isUndefined(fractionSize)) ? Math.min(Math.max(minFrac, fractionLen), maxFrac) : +fractionSize;
        var roundAt = fractionSize + parsedNumber.i;
        var digit = digits[roundAt];
        if (roundAt > 0) {
          digits.splice(Math.max(parsedNumber.i, roundAt));
          for (var j = roundAt; j < digits.length; j++) {
            digits[j] = 0;
          }
        } else {
          fractionLen = Math.max(0, fractionLen);
          parsedNumber.i = 1;
          digits.length = Math.max(1, roundAt = fractionSize + 1);
          digits[0] = 0;
          for (var i = 1; i < roundAt; i++)
            digits[i] = 0;
        }
        if (digit >= 5) {
          if (roundAt - 1 < 0) {
            for (var k = 0; k > roundAt; k--) {
              digits.unshift(0);
              parsedNumber.i++;
            }
            digits.unshift(1);
            parsedNumber.i++;
          } else {
            digits[roundAt - 1]++;
          }
        }
        for (; fractionLen < Math.max(0, fractionSize); fractionLen++)
          digits.push(0);
        var carry = digits.reduceRight(function(carry, d, i, digits) {
          d = d + carry;
          digits[i] = d % 10;
          return Math.floor(d / 10);
        }, 0);
        if (carry) {
          digits.unshift(carry);
          parsedNumber.i++;
        }
      }
      function formatNumber(number, pattern, groupSep, decimalSep, fractionSize) {
        if (!(isString(number) || isNumber(number)) || isNaN(number))
          return '';
        var isInfinity = !isFinite(number);
        var isZero = false;
        var numStr = Math.abs(number) + '',
            formattedText = '',
            parsedNumber;
        if (isInfinity) {
          formattedText = '\u221e';
        } else {
          parsedNumber = parse(numStr);
          roundNumber(parsedNumber, fractionSize, pattern.minFrac, pattern.maxFrac);
          var digits = parsedNumber.d;
          var integerLen = parsedNumber.i;
          var exponent = parsedNumber.e;
          var decimals = [];
          isZero = digits.reduce(function(isZero, d) {
            return isZero && !d;
          }, true);
          while (integerLen < 0) {
            digits.unshift(0);
            integerLen++;
          }
          if (integerLen > 0) {
            decimals = digits.splice(integerLen, digits.length);
          } else {
            decimals = digits;
            digits = [0];
          }
          var groups = [];
          if (digits.length >= pattern.lgSize) {
            groups.unshift(digits.splice(-pattern.lgSize, digits.length).join(''));
          }
          while (digits.length > pattern.gSize) {
            groups.unshift(digits.splice(-pattern.gSize, digits.length).join(''));
          }
          if (digits.length) {
            groups.unshift(digits.join(''));
          }
          formattedText = groups.join(groupSep);
          if (decimals.length) {
            formattedText += decimalSep + decimals.join('');
          }
          if (exponent) {
            formattedText += 'e+' + exponent;
          }
        }
        if (number < 0 && !isZero) {
          return pattern.negPre + formattedText + pattern.negSuf;
        } else {
          return pattern.posPre + formattedText + pattern.posSuf;
        }
      }
      function padNumber(num, digits, trim, negWrap) {
        var neg = '';
        if (num < 0 || (negWrap && num <= 0)) {
          if (negWrap) {
            num = -num + 1;
          } else {
            num = -num;
            neg = '-';
          }
        }
        num = '' + num;
        while (num.length < digits)
          num = ZERO_CHAR + num;
        if (trim) {
          num = num.substr(num.length - digits);
        }
        return neg + num;
      }
      function dateGetter(name, size, offset, trim, negWrap) {
        offset = offset || 0;
        return function(date) {
          var value = date['get' + name]();
          if (offset > 0 || value > -offset) {
            value += offset;
          }
          if (value === 0 && offset == -12)
            value = 12;
          return padNumber(value, size, trim, negWrap);
        };
      }
      function dateStrGetter(name, shortForm, standAlone) {
        return function(date, formats) {
          var value = date['get' + name]();
          var propPrefix = (standAlone ? 'STANDALONE' : '') + (shortForm ? 'SHORT' : '');
          var get = uppercase(propPrefix + name);
          return formats[get][value];
        };
      }
      function timeZoneGetter(date, formats, offset) {
        var zone = -1 * offset;
        var paddedZone = (zone >= 0) ? "+" : "";
        paddedZone += padNumber(Math[zone > 0 ? 'floor' : 'ceil'](zone / 60), 2) + padNumber(Math.abs(zone % 60), 2);
        return paddedZone;
      }
      function getFirstThursdayOfYear(year) {
        var dayOfWeekOnFirst = (new Date(year, 0, 1)).getDay();
        return new Date(year, 0, ((dayOfWeekOnFirst <= 4) ? 5 : 12) - dayOfWeekOnFirst);
      }
      function getThursdayThisWeek(datetime) {
        return new Date(datetime.getFullYear(), datetime.getMonth(), datetime.getDate() + (4 - datetime.getDay()));
      }
      function weekGetter(size) {
        return function(date) {
          var firstThurs = getFirstThursdayOfYear(date.getFullYear()),
              thisThurs = getThursdayThisWeek(date);
          var diff = +thisThurs - +firstThurs,
              result = 1 + Math.round(diff / 6.048e8);
          return padNumber(result, size);
        };
      }
      function ampmGetter(date, formats) {
        return date.getHours() < 12 ? formats.AMPMS[0] : formats.AMPMS[1];
      }
      function eraGetter(date, formats) {
        return date.getFullYear() <= 0 ? formats.ERAS[0] : formats.ERAS[1];
      }
      function longEraGetter(date, formats) {
        return date.getFullYear() <= 0 ? formats.ERANAMES[0] : formats.ERANAMES[1];
      }
      var DATE_FORMATS = {
        yyyy: dateGetter('FullYear', 4, 0, false, true),
        yy: dateGetter('FullYear', 2, 0, true, true),
        y: dateGetter('FullYear', 1, 0, false, true),
        MMMM: dateStrGetter('Month'),
        MMM: dateStrGetter('Month', true),
        MM: dateGetter('Month', 2, 1),
        M: dateGetter('Month', 1, 1),
        LLLL: dateStrGetter('Month', false, true),
        dd: dateGetter('Date', 2),
        d: dateGetter('Date', 1),
        HH: dateGetter('Hours', 2),
        H: dateGetter('Hours', 1),
        hh: dateGetter('Hours', 2, -12),
        h: dateGetter('Hours', 1, -12),
        mm: dateGetter('Minutes', 2),
        m: dateGetter('Minutes', 1),
        ss: dateGetter('Seconds', 2),
        s: dateGetter('Seconds', 1),
        sss: dateGetter('Milliseconds', 3),
        EEEE: dateStrGetter('Day'),
        EEE: dateStrGetter('Day', true),
        a: ampmGetter,
        Z: timeZoneGetter,
        ww: weekGetter(2),
        w: weekGetter(1),
        G: eraGetter,
        GG: eraGetter,
        GGG: eraGetter,
        GGGG: longEraGetter
      };
      var DATE_FORMATS_SPLIT = /((?:[^yMLdHhmsaZEwG']+)|(?:'(?:[^']|'')*')|(?:E+|y+|M+|L+|d+|H+|h+|m+|s+|a|Z|G+|w+))(.*)/,
          NUMBER_STRING = /^\-?\d+$/;
      dateFilter.$inject = ['$locale'];
      function dateFilter($locale) {
        var R_ISO8601_STR = /^(\d{4})-?(\d\d)-?(\d\d)(?:T(\d\d)(?::?(\d\d)(?::?(\d\d)(?:\.(\d+))?)?)?(Z|([+-])(\d\d):?(\d\d))?)?$/;
        function jsonStringToDate(string) {
          var match;
          if (match = string.match(R_ISO8601_STR)) {
            var date = new Date(0),
                tzHour = 0,
                tzMin = 0,
                dateSetter = match[8] ? date.setUTCFullYear : date.setFullYear,
                timeSetter = match[8] ? date.setUTCHours : date.setHours;
            if (match[9]) {
              tzHour = toInt(match[9] + match[10]);
              tzMin = toInt(match[9] + match[11]);
            }
            dateSetter.call(date, toInt(match[1]), toInt(match[2]) - 1, toInt(match[3]));
            var h = toInt(match[4] || 0) - tzHour;
            var m = toInt(match[5] || 0) - tzMin;
            var s = toInt(match[6] || 0);
            var ms = Math.round(parseFloat('0.' + (match[7] || 0)) * 1000);
            timeSetter.call(date, h, m, s, ms);
            return date;
          }
          return string;
        }
        return function(date, format, timezone) {
          var text = '',
              parts = [],
              fn,
              match;
          format = format || 'mediumDate';
          format = $locale.DATETIME_FORMATS[format] || format;
          if (isString(date)) {
            date = NUMBER_STRING.test(date) ? toInt(date) : jsonStringToDate(date);
          }
          if (isNumber(date)) {
            date = new Date(date);
          }
          if (!isDate(date) || !isFinite(date.getTime())) {
            return date;
          }
          while (format) {
            match = DATE_FORMATS_SPLIT.exec(format);
            if (match) {
              parts = concat(parts, match, 1);
              format = parts.pop();
            } else {
              parts.push(format);
              format = null;
            }
          }
          var dateTimezoneOffset = date.getTimezoneOffset();
          if (timezone) {
            dateTimezoneOffset = timezoneToOffset(timezone, dateTimezoneOffset);
            date = convertTimezoneToLocal(date, timezone, true);
          }
          forEach(parts, function(value) {
            fn = DATE_FORMATS[value];
            text += fn ? fn(date, $locale.DATETIME_FORMATS, dateTimezoneOffset) : value === "''" ? "'" : value.replace(/(^'|'$)/g, '').replace(/''/g, "'");
          });
          return text;
        };
      }
      function jsonFilter() {
        return function(object, spacing) {
          if (isUndefined(spacing)) {
            spacing = 2;
          }
          return toJson(object, spacing);
        };
      }
      var lowercaseFilter = valueFn(lowercase);
      var uppercaseFilter = valueFn(uppercase);
      function limitToFilter() {
        return function(input, limit, begin) {
          if (Math.abs(Number(limit)) === Infinity) {
            limit = Number(limit);
          } else {
            limit = toInt(limit);
          }
          if (isNaN(limit))
            return input;
          if (isNumber(input))
            input = input.toString();
          if (!isArrayLike(input))
            return input;
          begin = (!begin || isNaN(begin)) ? 0 : toInt(begin);
          begin = (begin < 0) ? Math.max(0, input.length + begin) : begin;
          if (limit >= 0) {
            return sliceFn(input, begin, begin + limit);
          } else {
            if (begin === 0) {
              return sliceFn(input, limit, input.length);
            } else {
              return sliceFn(input, Math.max(0, begin + limit), begin);
            }
          }
        };
      }
      function sliceFn(input, begin, end) {
        if (isString(input))
          return input.slice(begin, end);
        return slice.call(input, begin, end);
      }
      orderByFilter.$inject = ['$parse'];
      function orderByFilter($parse) {
        return function(array, sortPredicate, reverseOrder, compareFn) {
          if (array == null)
            return array;
          if (!isArrayLike(array)) {
            throw minErr('orderBy')('notarray', 'Expected array but received: {0}', array);
          }
          if (!isArray(sortPredicate)) {
            sortPredicate = [sortPredicate];
          }
          if (sortPredicate.length === 0) {
            sortPredicate = ['+'];
          }
          var predicates = processPredicates(sortPredicate);
          var descending = reverseOrder ? -1 : 1;
          var compare = isFunction(compareFn) ? compareFn : defaultCompare;
          var compareValues = Array.prototype.map.call(array, getComparisonObject);
          compareValues.sort(doComparison);
          array = compareValues.map(function(item) {
            return item.value;
          });
          return array;
          function getComparisonObject(value, index) {
            return {
              value: value,
              tieBreaker: {
                value: index,
                type: 'number',
                index: index
              },
              predicateValues: predicates.map(function(predicate) {
                return getPredicateValue(predicate.get(value), index);
              })
            };
          }
          function doComparison(v1, v2) {
            for (var i = 0,
                ii = predicates.length; i < ii; i++) {
              var result = compare(v1.predicateValues[i], v2.predicateValues[i]);
              if (result) {
                return result * predicates[i].descending * descending;
              }
            }
            return compare(v1.tieBreaker, v2.tieBreaker) * descending;
          }
        };
        function processPredicates(sortPredicates) {
          return sortPredicates.map(function(predicate) {
            var descending = 1,
                get = identity;
            if (isFunction(predicate)) {
              get = predicate;
            } else if (isString(predicate)) {
              if ((predicate.charAt(0) == '+' || predicate.charAt(0) == '-')) {
                descending = predicate.charAt(0) == '-' ? -1 : 1;
                predicate = predicate.substring(1);
              }
              if (predicate !== '') {
                get = $parse(predicate);
                if (get.constant) {
                  var key = get();
                  get = function(value) {
                    return value[key];
                  };
                }
              }
            }
            return {
              get: get,
              descending: descending
            };
          });
        }
        function isPrimitive(value) {
          switch (typeof value) {
            case 'number':
            case 'boolean':
            case 'string':
              return true;
            default:
              return false;
          }
        }
        function objectValue(value) {
          if (isFunction(value.valueOf)) {
            value = value.valueOf();
            if (isPrimitive(value))
              return value;
          }
          if (hasCustomToString(value)) {
            value = value.toString();
            if (isPrimitive(value))
              return value;
          }
          return value;
        }
        function getPredicateValue(value, index) {
          var type = typeof value;
          if (value === null) {
            type = 'string';
            value = 'null';
          } else if (type === 'object') {
            value = objectValue(value);
          }
          return {
            value: value,
            type: type,
            index: index
          };
        }
        function defaultCompare(v1, v2) {
          var result = 0;
          var type1 = v1.type;
          var type2 = v2.type;
          if (type1 === type2) {
            var value1 = v1.value;
            var value2 = v2.value;
            if (type1 === 'string') {
              value1 = value1.toLowerCase();
              value2 = value2.toLowerCase();
            } else if (type1 === 'object') {
              if (isObject(value1))
                value1 = v1.index;
              if (isObject(value2))
                value2 = v2.index;
            }
            if (value1 !== value2) {
              result = value1 < value2 ? -1 : 1;
            }
          } else {
            result = type1 < type2 ? -1 : 1;
          }
          return result;
        }
      }
      function ngDirective(directive) {
        if (isFunction(directive)) {
          directive = {link: directive};
        }
        directive.restrict = directive.restrict || 'AC';
        return valueFn(directive);
      }
      var htmlAnchorDirective = valueFn({
        restrict: 'E',
        compile: function(element, attr) {
          if (!attr.href && !attr.xlinkHref) {
            return function(scope, element) {
              if (element[0].nodeName.toLowerCase() !== 'a')
                return;
              var href = toString.call(element.prop('href')) === '[object SVGAnimatedString]' ? 'xlink:href' : 'href';
              element.on('click', function(event) {
                if (!element.attr(href)) {
                  event.preventDefault();
                }
              });
            };
          }
        }
      });
      var ngAttributeAliasDirectives = {};
      forEach(BOOLEAN_ATTR, function(propName, attrName) {
        if (propName == "multiple")
          return;
        function defaultLinkFn(scope, element, attr) {
          scope.$watch(attr[normalized], function ngBooleanAttrWatchAction(value) {
            attr.$set(attrName, !!value);
          });
        }
        var normalized = directiveNormalize('ng-' + attrName);
        var linkFn = defaultLinkFn;
        if (propName === 'checked') {
          linkFn = function(scope, element, attr) {
            if (attr.ngModel !== attr[normalized]) {
              defaultLinkFn(scope, element, attr);
            }
          };
        }
        ngAttributeAliasDirectives[normalized] = function() {
          return {
            restrict: 'A',
            priority: 100,
            link: linkFn
          };
        };
      });
      forEach(ALIASED_ATTR, function(htmlAttr, ngAttr) {
        ngAttributeAliasDirectives[ngAttr] = function() {
          return {
            priority: 100,
            link: function(scope, element, attr) {
              if (ngAttr === "ngPattern" && attr.ngPattern.charAt(0) == "/") {
                var match = attr.ngPattern.match(REGEX_STRING_REGEXP);
                if (match) {
                  attr.$set("ngPattern", new RegExp(match[1], match[2]));
                  return;
                }
              }
              scope.$watch(attr[ngAttr], function ngAttrAliasWatchAction(value) {
                attr.$set(ngAttr, value);
              });
            }
          };
        };
      });
      forEach(['src', 'srcset', 'href'], function(attrName) {
        var normalized = directiveNormalize('ng-' + attrName);
        ngAttributeAliasDirectives[normalized] = function() {
          return {
            priority: 99,
            link: function(scope, element, attr) {
              var propName = attrName,
                  name = attrName;
              if (attrName === 'href' && toString.call(element.prop('href')) === '[object SVGAnimatedString]') {
                name = 'xlinkHref';
                attr.$attr[name] = 'xlink:href';
                propName = null;
              }
              attr.$observe(normalized, function(value) {
                if (!value) {
                  if (attrName === 'href') {
                    attr.$set(name, null);
                  }
                  return;
                }
                attr.$set(name, value);
                if (msie && propName)
                  element.prop(propName, attr[name]);
              });
            }
          };
        };
      });
      var nullFormCtrl = {
        $addControl: noop,
        $$renameControl: nullFormRenameControl,
        $removeControl: noop,
        $setValidity: noop,
        $setDirty: noop,
        $setPristine: noop,
        $setSubmitted: noop
      },
          SUBMITTED_CLASS = 'ng-submitted';
      function nullFormRenameControl(control, name) {
        control.$name = name;
      }
      FormController.$inject = ['$element', '$attrs', '$scope', '$animate', '$interpolate'];
      function FormController(element, attrs, $scope, $animate, $interpolate) {
        var form = this,
            controls = [];
        form.$error = {};
        form.$$success = {};
        form.$pending = undefined;
        form.$name = $interpolate(attrs.name || attrs.ngForm || '')($scope);
        form.$dirty = false;
        form.$pristine = true;
        form.$valid = true;
        form.$invalid = false;
        form.$submitted = false;
        form.$$parentForm = nullFormCtrl;
        form.$rollbackViewValue = function() {
          forEach(controls, function(control) {
            control.$rollbackViewValue();
          });
        };
        form.$commitViewValue = function() {
          forEach(controls, function(control) {
            control.$commitViewValue();
          });
        };
        form.$addControl = function(control) {
          assertNotHasOwnProperty(control.$name, 'input');
          controls.push(control);
          if (control.$name) {
            form[control.$name] = control;
          }
          control.$$parentForm = form;
        };
        form.$$renameControl = function(control, newName) {
          var oldName = control.$name;
          if (form[oldName] === control) {
            delete form[oldName];
          }
          form[newName] = control;
          control.$name = newName;
        };
        form.$removeControl = function(control) {
          if (control.$name && form[control.$name] === control) {
            delete form[control.$name];
          }
          forEach(form.$pending, function(value, name) {
            form.$setValidity(name, null, control);
          });
          forEach(form.$error, function(value, name) {
            form.$setValidity(name, null, control);
          });
          forEach(form.$$success, function(value, name) {
            form.$setValidity(name, null, control);
          });
          arrayRemove(controls, control);
          control.$$parentForm = nullFormCtrl;
        };
        addSetValidityMethod({
          ctrl: this,
          $element: element,
          set: function(object, property, controller) {
            var list = object[property];
            if (!list) {
              object[property] = [controller];
            } else {
              var index = list.indexOf(controller);
              if (index === -1) {
                list.push(controller);
              }
            }
          },
          unset: function(object, property, controller) {
            var list = object[property];
            if (!list) {
              return;
            }
            arrayRemove(list, controller);
            if (list.length === 0) {
              delete object[property];
            }
          },
          $animate: $animate
        });
        form.$setDirty = function() {
          $animate.removeClass(element, PRISTINE_CLASS);
          $animate.addClass(element, DIRTY_CLASS);
          form.$dirty = true;
          form.$pristine = false;
          form.$$parentForm.$setDirty();
        };
        form.$setPristine = function() {
          $animate.setClass(element, PRISTINE_CLASS, DIRTY_CLASS + ' ' + SUBMITTED_CLASS);
          form.$dirty = false;
          form.$pristine = true;
          form.$submitted = false;
          forEach(controls, function(control) {
            control.$setPristine();
          });
        };
        form.$setUntouched = function() {
          forEach(controls, function(control) {
            control.$setUntouched();
          });
        };
        form.$setSubmitted = function() {
          $animate.addClass(element, SUBMITTED_CLASS);
          form.$submitted = true;
          form.$$parentForm.$setSubmitted();
        };
      }
      var formDirectiveFactory = function(isNgForm) {
        return ['$timeout', '$parse', function($timeout, $parse) {
          var formDirective = {
            name: 'form',
            restrict: isNgForm ? 'EAC' : 'E',
            require: ['form', '^^?form'],
            controller: FormController,
            compile: function ngFormCompile(formElement, attr) {
              formElement.addClass(PRISTINE_CLASS).addClass(VALID_CLASS);
              var nameAttr = attr.name ? 'name' : (isNgForm && attr.ngForm ? 'ngForm' : false);
              return {pre: function ngFormPreLink(scope, formElement, attr, ctrls) {
                  var controller = ctrls[0];
                  if (!('action' in attr)) {
                    var handleFormSubmission = function(event) {
                      scope.$apply(function() {
                        controller.$commitViewValue();
                        controller.$setSubmitted();
                      });
                      event.preventDefault();
                    };
                    addEventListenerFn(formElement[0], 'submit', handleFormSubmission);
                    formElement.on('$destroy', function() {
                      $timeout(function() {
                        removeEventListenerFn(formElement[0], 'submit', handleFormSubmission);
                      }, 0, false);
                    });
                  }
                  var parentFormCtrl = ctrls[1] || controller.$$parentForm;
                  parentFormCtrl.$addControl(controller);
                  var setter = nameAttr ? getSetter(controller.$name) : noop;
                  if (nameAttr) {
                    setter(scope, controller);
                    attr.$observe(nameAttr, function(newValue) {
                      if (controller.$name === newValue)
                        return;
                      setter(scope, undefined);
                      controller.$$parentForm.$$renameControl(controller, newValue);
                      setter = getSetter(controller.$name);
                      setter(scope, controller);
                    });
                  }
                  formElement.on('$destroy', function() {
                    controller.$$parentForm.$removeControl(controller);
                    setter(scope, undefined);
                    extend(controller, nullFormCtrl);
                  });
                }};
            }
          };
          return formDirective;
          function getSetter(expression) {
            if (expression === '') {
              return $parse('this[""]').assign;
            }
            return $parse(expression).assign || noop;
          }
        }];
      };
      var formDirective = formDirectiveFactory();
      var ngFormDirective = formDirectiveFactory(true);
      var ISO_DATE_REGEXP = /^\d{4,}-[01]\d-[0-3]\dT[0-2]\d:[0-5]\d:[0-5]\d\.\d+(?:[+-][0-2]\d:[0-5]\d|Z)$/;
      var URL_REGEXP = /^[a-z][a-z\d.+-]*:\/*(?:[^:@]+(?::[^@]+)?@)?(?:[^\s:/?#]+|\[[a-f\d:]+\])(?::\d+)?(?:\/[^?#]*)?(?:\?[^#]*)?(?:#.*)?$/i;
      var EMAIL_REGEXP = /^(?=.{1,254}$)(?=.{1,64}@)[-!#$%&'*+\/0-9=?A-Z^_`a-z{|}~]+(\.[-!#$%&'*+\/0-9=?A-Z^_`a-z{|}~]+)*@[A-Za-z0-9]([A-Za-z0-9-]{0,61}[A-Za-z0-9])?(\.[A-Za-z0-9]([A-Za-z0-9-]{0,61}[A-Za-z0-9])?)*$/;
      var NUMBER_REGEXP = /^\s*(\-|\+)?(\d+|(\d*(\.\d*)))([eE][+-]?\d+)?\s*$/;
      var DATE_REGEXP = /^(\d{4,})-(\d{2})-(\d{2})$/;
      var DATETIMELOCAL_REGEXP = /^(\d{4,})-(\d\d)-(\d\d)T(\d\d):(\d\d)(?::(\d\d)(\.\d{1,3})?)?$/;
      var WEEK_REGEXP = /^(\d{4,})-W(\d\d)$/;
      var MONTH_REGEXP = /^(\d{4,})-(\d\d)$/;
      var TIME_REGEXP = /^(\d\d):(\d\d)(?::(\d\d)(\.\d{1,3})?)?$/;
      var PARTIAL_VALIDATION_EVENTS = 'keydown wheel mousedown';
      var PARTIAL_VALIDATION_TYPES = createMap();
      forEach('date,datetime-local,month,time,week'.split(','), function(type) {
        PARTIAL_VALIDATION_TYPES[type] = true;
      });
      var inputType = {
        'text': textInputType,
        'date': createDateInputType('date', DATE_REGEXP, createDateParser(DATE_REGEXP, ['yyyy', 'MM', 'dd']), 'yyyy-MM-dd'),
        'datetime-local': createDateInputType('datetimelocal', DATETIMELOCAL_REGEXP, createDateParser(DATETIMELOCAL_REGEXP, ['yyyy', 'MM', 'dd', 'HH', 'mm', 'ss', 'sss']), 'yyyy-MM-ddTHH:mm:ss.sss'),
        'time': createDateInputType('time', TIME_REGEXP, createDateParser(TIME_REGEXP, ['HH', 'mm', 'ss', 'sss']), 'HH:mm:ss.sss'),
        'week': createDateInputType('week', WEEK_REGEXP, weekParser, 'yyyy-Www'),
        'month': createDateInputType('month', MONTH_REGEXP, createDateParser(MONTH_REGEXP, ['yyyy', 'MM']), 'yyyy-MM'),
        'number': numberInputType,
        'url': urlInputType,
        'email': emailInputType,
        'radio': radioInputType,
        'checkbox': checkboxInputType,
        'hidden': noop,
        'button': noop,
        'submit': noop,
        'reset': noop,
        'file': noop
      };
      function stringBasedInputType(ctrl) {
        ctrl.$formatters.push(function(value) {
          return ctrl.$isEmpty(value) ? value : value.toString();
        });
      }
      function textInputType(scope, element, attr, ctrl, $sniffer, $browser) {
        baseInputType(scope, element, attr, ctrl, $sniffer, $browser);
        stringBasedInputType(ctrl);
      }
      function baseInputType(scope, element, attr, ctrl, $sniffer, $browser) {
        var type = lowercase(element[0].type);
        if (!$sniffer.android) {
          var composing = false;
          element.on('compositionstart', function() {
            composing = true;
          });
          element.on('compositionend', function() {
            composing = false;
            listener();
          });
        }
        var timeout;
        var listener = function(ev) {
          if (timeout) {
            $browser.defer.cancel(timeout);
            timeout = null;
          }
          if (composing)
            return;
          var value = element.val(),
              event = ev && ev.type;
          if (type !== 'password' && (!attr.ngTrim || attr.ngTrim !== 'false')) {
            value = trim(value);
          }
          if (ctrl.$viewValue !== value || (value === '' && ctrl.$$hasNativeValidators)) {
            ctrl.$setViewValue(value, event);
          }
        };
        if ($sniffer.hasEvent('input')) {
          element.on('input', listener);
        } else {
          var deferListener = function(ev, input, origValue) {
            if (!timeout) {
              timeout = $browser.defer(function() {
                timeout = null;
                if (!input || input.value !== origValue) {
                  listener(ev);
                }
              });
            }
          };
          element.on('keydown', function(event) {
            var key = event.keyCode;
            if (key === 91 || (15 < key && key < 19) || (37 <= key && key <= 40))
              return;
            deferListener(event, this, this.value);
          });
          if ($sniffer.hasEvent('paste')) {
            element.on('paste cut', deferListener);
          }
        }
        element.on('change', listener);
        if (PARTIAL_VALIDATION_TYPES[type] && ctrl.$$hasNativeValidators && type === attr.type) {
          element.on(PARTIAL_VALIDATION_EVENTS, function(ev) {
            if (!timeout) {
              var validity = this[VALIDITY_STATE_PROPERTY];
              var origBadInput = validity.badInput;
              var origTypeMismatch = validity.typeMismatch;
              timeout = $browser.defer(function() {
                timeout = null;
                if (validity.badInput !== origBadInput || validity.typeMismatch !== origTypeMismatch) {
                  listener(ev);
                }
              });
            }
          });
        }
        ctrl.$render = function() {
          var value = ctrl.$isEmpty(ctrl.$viewValue) ? '' : ctrl.$viewValue;
          if (element.val() !== value) {
            element.val(value);
          }
        };
      }
      function weekParser(isoWeek, existingDate) {
        if (isDate(isoWeek)) {
          return isoWeek;
        }
        if (isString(isoWeek)) {
          WEEK_REGEXP.lastIndex = 0;
          var parts = WEEK_REGEXP.exec(isoWeek);
          if (parts) {
            var year = +parts[1],
                week = +parts[2],
                hours = 0,
                minutes = 0,
                seconds = 0,
                milliseconds = 0,
                firstThurs = getFirstThursdayOfYear(year),
                addDays = (week - 1) * 7;
            if (existingDate) {
              hours = existingDate.getHours();
              minutes = existingDate.getMinutes();
              seconds = existingDate.getSeconds();
              milliseconds = existingDate.getMilliseconds();
            }
            return new Date(year, 0, firstThurs.getDate() + addDays, hours, minutes, seconds, milliseconds);
          }
        }
        return NaN;
      }
      function createDateParser(regexp, mapping) {
        return function(iso, date) {
          var parts,
              map;
          if (isDate(iso)) {
            return iso;
          }
          if (isString(iso)) {
            if (iso.charAt(0) == '"' && iso.charAt(iso.length - 1) == '"') {
              iso = iso.substring(1, iso.length - 1);
            }
            if (ISO_DATE_REGEXP.test(iso)) {
              return new Date(iso);
            }
            regexp.lastIndex = 0;
            parts = regexp.exec(iso);
            if (parts) {
              parts.shift();
              if (date) {
                map = {
                  yyyy: date.getFullYear(),
                  MM: date.getMonth() + 1,
                  dd: date.getDate(),
                  HH: date.getHours(),
                  mm: date.getMinutes(),
                  ss: date.getSeconds(),
                  sss: date.getMilliseconds() / 1000
                };
              } else {
                map = {
                  yyyy: 1970,
                  MM: 1,
                  dd: 1,
                  HH: 0,
                  mm: 0,
                  ss: 0,
                  sss: 0
                };
              }
              forEach(parts, function(part, index) {
                if (index < mapping.length) {
                  map[mapping[index]] = +part;
                }
              });
              return new Date(map.yyyy, map.MM - 1, map.dd, map.HH, map.mm, map.ss || 0, map.sss * 1000 || 0);
            }
          }
          return NaN;
        };
      }
      function createDateInputType(type, regexp, parseDate, format) {
        return function dynamicDateInputType(scope, element, attr, ctrl, $sniffer, $browser, $filter) {
          badInputChecker(scope, element, attr, ctrl);
          baseInputType(scope, element, attr, ctrl, $sniffer, $browser);
          var timezone = ctrl && ctrl.$options && ctrl.$options.timezone;
          var previousDate;
          ctrl.$$parserName = type;
          ctrl.$parsers.push(function(value) {
            if (ctrl.$isEmpty(value))
              return null;
            if (regexp.test(value)) {
              var parsedDate = parseDate(value, previousDate);
              if (timezone) {
                parsedDate = convertTimezoneToLocal(parsedDate, timezone);
              }
              return parsedDate;
            }
            return undefined;
          });
          ctrl.$formatters.push(function(value) {
            if (value && !isDate(value)) {
              throw ngModelMinErr('datefmt', 'Expected `{0}` to be a date', value);
            }
            if (isValidDate(value)) {
              previousDate = value;
              if (previousDate && timezone) {
                previousDate = convertTimezoneToLocal(previousDate, timezone, true);
              }
              return $filter('date')(value, format, timezone);
            } else {
              previousDate = null;
              return '';
            }
          });
          if (isDefined(attr.min) || attr.ngMin) {
            var minVal;
            ctrl.$validators.min = function(value) {
              return !isValidDate(value) || isUndefined(minVal) || parseDate(value) >= minVal;
            };
            attr.$observe('min', function(val) {
              minVal = parseObservedDateValue(val);
              ctrl.$validate();
            });
          }
          if (isDefined(attr.max) || attr.ngMax) {
            var maxVal;
            ctrl.$validators.max = function(value) {
              return !isValidDate(value) || isUndefined(maxVal) || parseDate(value) <= maxVal;
            };
            attr.$observe('max', function(val) {
              maxVal = parseObservedDateValue(val);
              ctrl.$validate();
            });
          }
          function isValidDate(value) {
            return value && !(value.getTime && value.getTime() !== value.getTime());
          }
          function parseObservedDateValue(val) {
            return isDefined(val) && !isDate(val) ? parseDate(val) || undefined : val;
          }
        };
      }
      function badInputChecker(scope, element, attr, ctrl) {
        var node = element[0];
        var nativeValidation = ctrl.$$hasNativeValidators = isObject(node.validity);
        if (nativeValidation) {
          ctrl.$parsers.push(function(value) {
            var validity = element.prop(VALIDITY_STATE_PROPERTY) || {};
            return validity.badInput || validity.typeMismatch ? undefined : value;
          });
        }
      }
      function numberInputType(scope, element, attr, ctrl, $sniffer, $browser) {
        badInputChecker(scope, element, attr, ctrl);
        baseInputType(scope, element, attr, ctrl, $sniffer, $browser);
        ctrl.$$parserName = 'number';
        ctrl.$parsers.push(function(value) {
          if (ctrl.$isEmpty(value))
            return null;
          if (NUMBER_REGEXP.test(value))
            return parseFloat(value);
          return undefined;
        });
        ctrl.$formatters.push(function(value) {
          if (!ctrl.$isEmpty(value)) {
            if (!isNumber(value)) {
              throw ngModelMinErr('numfmt', 'Expected `{0}` to be a number', value);
            }
            value = value.toString();
          }
          return value;
        });
        if (isDefined(attr.min) || attr.ngMin) {
          var minVal;
          ctrl.$validators.min = function(value) {
            return ctrl.$isEmpty(value) || isUndefined(minVal) || value >= minVal;
          };
          attr.$observe('min', function(val) {
            if (isDefined(val) && !isNumber(val)) {
              val = parseFloat(val, 10);
            }
            minVal = isNumber(val) && !isNaN(val) ? val : undefined;
            ctrl.$validate();
          });
        }
        if (isDefined(attr.max) || attr.ngMax) {
          var maxVal;
          ctrl.$validators.max = function(value) {
            return ctrl.$isEmpty(value) || isUndefined(maxVal) || value <= maxVal;
          };
          attr.$observe('max', function(val) {
            if (isDefined(val) && !isNumber(val)) {
              val = parseFloat(val, 10);
            }
            maxVal = isNumber(val) && !isNaN(val) ? val : undefined;
            ctrl.$validate();
          });
        }
      }
      function urlInputType(scope, element, attr, ctrl, $sniffer, $browser) {
        baseInputType(scope, element, attr, ctrl, $sniffer, $browser);
        stringBasedInputType(ctrl);
        ctrl.$$parserName = 'url';
        ctrl.$validators.url = function(modelValue, viewValue) {
          var value = modelValue || viewValue;
          return ctrl.$isEmpty(value) || URL_REGEXP.test(value);
        };
      }
      function emailInputType(scope, element, attr, ctrl, $sniffer, $browser) {
        baseInputType(scope, element, attr, ctrl, $sniffer, $browser);
        stringBasedInputType(ctrl);
        ctrl.$$parserName = 'email';
        ctrl.$validators.email = function(modelValue, viewValue) {
          var value = modelValue || viewValue;
          return ctrl.$isEmpty(value) || EMAIL_REGEXP.test(value);
        };
      }
      function radioInputType(scope, element, attr, ctrl) {
        if (isUndefined(attr.name)) {
          element.attr('name', nextUid());
        }
        var listener = function(ev) {
          if (element[0].checked) {
            ctrl.$setViewValue(attr.value, ev && ev.type);
          }
        };
        element.on('click', listener);
        ctrl.$render = function() {
          var value = attr.value;
          element[0].checked = (value == ctrl.$viewValue);
        };
        attr.$observe('value', ctrl.$render);
      }
      function parseConstantExpr($parse, context, name, expression, fallback) {
        var parseFn;
        if (isDefined(expression)) {
          parseFn = $parse(expression);
          if (!parseFn.constant) {
            throw ngModelMinErr('constexpr', 'Expected constant expression for `{0}`, but saw ' + '`{1}`.', name, expression);
          }
          return parseFn(context);
        }
        return fallback;
      }
      function checkboxInputType(scope, element, attr, ctrl, $sniffer, $browser, $filter, $parse) {
        var trueValue = parseConstantExpr($parse, scope, 'ngTrueValue', attr.ngTrueValue, true);
        var falseValue = parseConstantExpr($parse, scope, 'ngFalseValue', attr.ngFalseValue, false);
        var listener = function(ev) {
          ctrl.$setViewValue(element[0].checked, ev && ev.type);
        };
        element.on('click', listener);
        ctrl.$render = function() {
          element[0].checked = ctrl.$viewValue;
        };
        ctrl.$isEmpty = function(value) {
          return value === false;
        };
        ctrl.$formatters.push(function(value) {
          return equals(value, trueValue);
        });
        ctrl.$parsers.push(function(value) {
          return value ? trueValue : falseValue;
        });
      }
      var inputDirective = ['$browser', '$sniffer', '$filter', '$parse', function($browser, $sniffer, $filter, $parse) {
        return {
          restrict: 'E',
          require: ['?ngModel'],
          link: {pre: function(scope, element, attr, ctrls) {
              if (ctrls[0]) {
                (inputType[lowercase(attr.type)] || inputType.text)(scope, element, attr, ctrls[0], $sniffer, $browser, $filter, $parse);
              }
            }}
        };
      }];
      var CONSTANT_VALUE_REGEXP = /^(true|false|\d+)$/;
      var ngValueDirective = function() {
        return {
          restrict: 'A',
          priority: 100,
          compile: function(tpl, tplAttr) {
            if (CONSTANT_VALUE_REGEXP.test(tplAttr.ngValue)) {
              return function ngValueConstantLink(scope, elm, attr) {
                attr.$set('value', scope.$eval(attr.ngValue));
              };
            } else {
              return function ngValueLink(scope, elm, attr) {
                scope.$watch(attr.ngValue, function valueWatchAction(value) {
                  attr.$set('value', value);
                });
              };
            }
          }
        };
      };
      var ngBindDirective = ['$compile', function($compile) {
        return {
          restrict: 'AC',
          compile: function ngBindCompile(templateElement) {
            $compile.$$addBindingClass(templateElement);
            return function ngBindLink(scope, element, attr) {
              $compile.$$addBindingInfo(element, attr.ngBind);
              element = element[0];
              scope.$watch(attr.ngBind, function ngBindWatchAction(value) {
                element.textContent = isUndefined(value) ? '' : value;
              });
            };
          }
        };
      }];
      var ngBindTemplateDirective = ['$interpolate', '$compile', function($interpolate, $compile) {
        return {compile: function ngBindTemplateCompile(templateElement) {
            $compile.$$addBindingClass(templateElement);
            return function ngBindTemplateLink(scope, element, attr) {
              var interpolateFn = $interpolate(element.attr(attr.$attr.ngBindTemplate));
              $compile.$$addBindingInfo(element, interpolateFn.expressions);
              element = element[0];
              attr.$observe('ngBindTemplate', function(value) {
                element.textContent = isUndefined(value) ? '' : value;
              });
            };
          }};
      }];
      var ngBindHtmlDirective = ['$sce', '$parse', '$compile', function($sce, $parse, $compile) {
        return {
          restrict: 'A',
          compile: function ngBindHtmlCompile(tElement, tAttrs) {
            var ngBindHtmlGetter = $parse(tAttrs.ngBindHtml);
            var ngBindHtmlWatch = $parse(tAttrs.ngBindHtml, function sceValueOf(val) {
              return $sce.valueOf(val);
            });
            $compile.$$addBindingClass(tElement);
            return function ngBindHtmlLink(scope, element, attr) {
              $compile.$$addBindingInfo(element, attr.ngBindHtml);
              scope.$watch(ngBindHtmlWatch, function ngBindHtmlWatchAction() {
                var value = ngBindHtmlGetter(scope);
                element.html($sce.getTrustedHtml(value) || '');
              });
            };
          }
        };
      }];
      var ngChangeDirective = valueFn({
        restrict: 'A',
        require: 'ngModel',
        link: function(scope, element, attr, ctrl) {
          ctrl.$viewChangeListeners.push(function() {
            scope.$eval(attr.ngChange);
          });
        }
      });
      function classDirective(name, selector) {
        name = 'ngClass' + name;
        return ['$animate', function($animate) {
          return {
            restrict: 'AC',
            link: function(scope, element, attr) {
              var oldVal;
              scope.$watch(attr[name], ngClassWatchAction, true);
              attr.$observe('class', function(value) {
                ngClassWatchAction(scope.$eval(attr[name]));
              });
              if (name !== 'ngClass') {
                scope.$watch('$index', function($index, old$index) {
                  var mod = $index & 1;
                  if (mod !== (old$index & 1)) {
                    var classes = arrayClasses(scope.$eval(attr[name]));
                    mod === selector ? addClasses(classes) : removeClasses(classes);
                  }
                });
              }
              function addClasses(classes) {
                var newClasses = digestClassCounts(classes, 1);
                attr.$addClass(newClasses);
              }
              function removeClasses(classes) {
                var newClasses = digestClassCounts(classes, -1);
                attr.$removeClass(newClasses);
              }
              function digestClassCounts(classes, count) {
                var classCounts = element.data('$classCounts') || createMap();
                var classesToUpdate = [];
                forEach(classes, function(className) {
                  if (count > 0 || classCounts[className]) {
                    classCounts[className] = (classCounts[className] || 0) + count;
                    if (classCounts[className] === +(count > 0)) {
                      classesToUpdate.push(className);
                    }
                  }
                });
                element.data('$classCounts', classCounts);
                return classesToUpdate.join(' ');
              }
              function updateClasses(oldClasses, newClasses) {
                var toAdd = arrayDifference(newClasses, oldClasses);
                var toRemove = arrayDifference(oldClasses, newClasses);
                toAdd = digestClassCounts(toAdd, 1);
                toRemove = digestClassCounts(toRemove, -1);
                if (toAdd && toAdd.length) {
                  $animate.addClass(element, toAdd);
                }
                if (toRemove && toRemove.length) {
                  $animate.removeClass(element, toRemove);
                }
              }
              function ngClassWatchAction(newVal) {
                if (selector === true || (scope.$index & 1) === selector) {
                  var newClasses = arrayClasses(newVal || []);
                  if (!oldVal) {
                    addClasses(newClasses);
                  } else if (!equals(newVal, oldVal)) {
                    var oldClasses = arrayClasses(oldVal);
                    updateClasses(oldClasses, newClasses);
                  }
                }
                if (isArray(newVal)) {
                  oldVal = newVal.map(function(v) {
                    return shallowCopy(v);
                  });
                } else {
                  oldVal = shallowCopy(newVal);
                }
              }
            }
          };
          function arrayDifference(tokens1, tokens2) {
            var values = [];
            outer: for (var i = 0; i < tokens1.length; i++) {
              var token = tokens1[i];
              for (var j = 0; j < tokens2.length; j++) {
                if (token == tokens2[j])
                  continue outer;
              }
              values.push(token);
            }
            return values;
          }
          function arrayClasses(classVal) {
            var classes = [];
            if (isArray(classVal)) {
              forEach(classVal, function(v) {
                classes = classes.concat(arrayClasses(v));
              });
              return classes;
            } else if (isString(classVal)) {
              return classVal.split(' ');
            } else if (isObject(classVal)) {
              forEach(classVal, function(v, k) {
                if (v) {
                  classes = classes.concat(k.split(' '));
                }
              });
              return classes;
            }
            return classVal;
          }
        }];
      }
      var ngClassDirective = classDirective('', true);
      var ngClassOddDirective = classDirective('Odd', 0);
      var ngClassEvenDirective = classDirective('Even', 1);
      var ngCloakDirective = ngDirective({compile: function(element, attr) {
          attr.$set('ngCloak', undefined);
          element.removeClass('ng-cloak');
        }});
      var ngControllerDirective = [function() {
        return {
          restrict: 'A',
          scope: true,
          controller: '@',
          priority: 500
        };
      }];
      var ngEventDirectives = {};
      var forceAsyncEvents = {
        'blur': true,
        'focus': true
      };
      forEach('click dblclick mousedown mouseup mouseover mouseout mousemove mouseenter mouseleave keydown keyup keypress submit focus blur copy cut paste'.split(' '), function(eventName) {
        var directiveName = directiveNormalize('ng-' + eventName);
        ngEventDirectives[directiveName] = ['$parse', '$rootScope', function($parse, $rootScope) {
          return {
            restrict: 'A',
            compile: function($element, attr) {
              var fn = $parse(attr[directiveName], null, true);
              return function ngEventHandler(scope, element) {
                element.on(eventName, function(event) {
                  var callback = function() {
                    fn(scope, {$event: event});
                  };
                  if (forceAsyncEvents[eventName] && $rootScope.$$phase) {
                    scope.$evalAsync(callback);
                  } else {
                    scope.$apply(callback);
                  }
                });
              };
            }
          };
        }];
      });
      var ngIfDirective = ['$animate', '$compile', function($animate, $compile) {
        return {
          multiElement: true,
          transclude: 'element',
          priority: 600,
          terminal: true,
          restrict: 'A',
          $$tlb: true,
          link: function($scope, $element, $attr, ctrl, $transclude) {
            var block,
                childScope,
                previousElements;
            $scope.$watch($attr.ngIf, function ngIfWatchAction(value) {
              if (value) {
                if (!childScope) {
                  $transclude(function(clone, newScope) {
                    childScope = newScope;
                    clone[clone.length++] = $compile.$$createComment('end ngIf', $attr.ngIf);
                    block = {clone: clone};
                    $animate.enter(clone, $element.parent(), $element);
                  });
                }
              } else {
                if (previousElements) {
                  previousElements.remove();
                  previousElements = null;
                }
                if (childScope) {
                  childScope.$destroy();
                  childScope = null;
                }
                if (block) {
                  previousElements = getBlockNodes(block.clone);
                  $animate.leave(previousElements).then(function() {
                    previousElements = null;
                  });
                  block = null;
                }
              }
            });
          }
        };
      }];
      var ngIncludeDirective = ['$templateRequest', '$anchorScroll', '$animate', function($templateRequest, $anchorScroll, $animate) {
        return {
          restrict: 'ECA',
          priority: 400,
          terminal: true,
          transclude: 'element',
          controller: angular.noop,
          compile: function(element, attr) {
            var srcExp = attr.ngInclude || attr.src,
                onloadExp = attr.onload || '',
                autoScrollExp = attr.autoscroll;
            return function(scope, $element, $attr, ctrl, $transclude) {
              var changeCounter = 0,
                  currentScope,
                  previousElement,
                  currentElement;
              var cleanupLastIncludeContent = function() {
                if (previousElement) {
                  previousElement.remove();
                  previousElement = null;
                }
                if (currentScope) {
                  currentScope.$destroy();
                  currentScope = null;
                }
                if (currentElement) {
                  $animate.leave(currentElement).then(function() {
                    previousElement = null;
                  });
                  previousElement = currentElement;
                  currentElement = null;
                }
              };
              scope.$watch(srcExp, function ngIncludeWatchAction(src) {
                var afterAnimation = function() {
                  if (isDefined(autoScrollExp) && (!autoScrollExp || scope.$eval(autoScrollExp))) {
                    $anchorScroll();
                  }
                };
                var thisChangeId = ++changeCounter;
                if (src) {
                  $templateRequest(src, true).then(function(response) {
                    if (scope.$$destroyed)
                      return;
                    if (thisChangeId !== changeCounter)
                      return;
                    var newScope = scope.$new();
                    ctrl.template = response;
                    var clone = $transclude(newScope, function(clone) {
                      cleanupLastIncludeContent();
                      $animate.enter(clone, null, $element).then(afterAnimation);
                    });
                    currentScope = newScope;
                    currentElement = clone;
                    currentScope.$emit('$includeContentLoaded', src);
                    scope.$eval(onloadExp);
                  }, function() {
                    if (scope.$$destroyed)
                      return;
                    if (thisChangeId === changeCounter) {
                      cleanupLastIncludeContent();
                      scope.$emit('$includeContentError', src);
                    }
                  });
                  scope.$emit('$includeContentRequested', src);
                } else {
                  cleanupLastIncludeContent();
                  ctrl.template = null;
                }
              });
            };
          }
        };
      }];
      var ngIncludeFillContentDirective = ['$compile', function($compile) {
        return {
          restrict: 'ECA',
          priority: -400,
          require: 'ngInclude',
          link: function(scope, $element, $attr, ctrl) {
            if (toString.call($element[0]).match(/SVG/)) {
              $element.empty();
              $compile(jqLiteBuildFragment(ctrl.template, window.document).childNodes)(scope, function namespaceAdaptedClone(clone) {
                $element.append(clone);
              }, {futureParentElement: $element});
              return;
            }
            $element.html(ctrl.template);
            $compile($element.contents())(scope);
          }
        };
      }];
      var ngInitDirective = ngDirective({
        priority: 450,
        compile: function() {
          return {pre: function(scope, element, attrs) {
              scope.$eval(attrs.ngInit);
            }};
        }
      });
      var ngListDirective = function() {
        return {
          restrict: 'A',
          priority: 100,
          require: 'ngModel',
          link: function(scope, element, attr, ctrl) {
            var ngList = element.attr(attr.$attr.ngList) || ', ';
            var trimValues = attr.ngTrim !== 'false';
            var separator = trimValues ? trim(ngList) : ngList;
            var parse = function(viewValue) {
              if (isUndefined(viewValue))
                return;
              var list = [];
              if (viewValue) {
                forEach(viewValue.split(separator), function(value) {
                  if (value)
                    list.push(trimValues ? trim(value) : value);
                });
              }
              return list;
            };
            ctrl.$parsers.push(parse);
            ctrl.$formatters.push(function(value) {
              if (isArray(value)) {
                return value.join(ngList);
              }
              return undefined;
            });
            ctrl.$isEmpty = function(value) {
              return !value || !value.length;
            };
          }
        };
      };
      var VALID_CLASS = 'ng-valid',
          INVALID_CLASS = 'ng-invalid',
          PRISTINE_CLASS = 'ng-pristine',
          DIRTY_CLASS = 'ng-dirty',
          UNTOUCHED_CLASS = 'ng-untouched',
          TOUCHED_CLASS = 'ng-touched',
          PENDING_CLASS = 'ng-pending',
          EMPTY_CLASS = 'ng-empty',
          NOT_EMPTY_CLASS = 'ng-not-empty';
      var ngModelMinErr = minErr('ngModel');
      var NgModelController = ['$scope', '$exceptionHandler', '$attrs', '$element', '$parse', '$animate', '$timeout', '$rootScope', '$q', '$interpolate', function($scope, $exceptionHandler, $attr, $element, $parse, $animate, $timeout, $rootScope, $q, $interpolate) {
        this.$viewValue = Number.NaN;
        this.$modelValue = Number.NaN;
        this.$$rawModelValue = undefined;
        this.$validators = {};
        this.$asyncValidators = {};
        this.$parsers = [];
        this.$formatters = [];
        this.$viewChangeListeners = [];
        this.$untouched = true;
        this.$touched = false;
        this.$pristine = true;
        this.$dirty = false;
        this.$valid = true;
        this.$invalid = false;
        this.$error = {};
        this.$$success = {};
        this.$pending = undefined;
        this.$name = $interpolate($attr.name || '', false)($scope);
        this.$$parentForm = nullFormCtrl;
        var parsedNgModel = $parse($attr.ngModel),
            parsedNgModelAssign = parsedNgModel.assign,
            ngModelGet = parsedNgModel,
            ngModelSet = parsedNgModelAssign,
            pendingDebounce = null,
            parserValid,
            ctrl = this;
        this.$$setOptions = function(options) {
          ctrl.$options = options;
          if (options && options.getterSetter) {
            var invokeModelGetter = $parse($attr.ngModel + '()'),
                invokeModelSetter = $parse($attr.ngModel + '($$$p)');
            ngModelGet = function($scope) {
              var modelValue = parsedNgModel($scope);
              if (isFunction(modelValue)) {
                modelValue = invokeModelGetter($scope);
              }
              return modelValue;
            };
            ngModelSet = function($scope, newValue) {
              if (isFunction(parsedNgModel($scope))) {
                invokeModelSetter($scope, {$$$p: newValue});
              } else {
                parsedNgModelAssign($scope, newValue);
              }
            };
          } else if (!parsedNgModel.assign) {
            throw ngModelMinErr('nonassign', "Expression '{0}' is non-assignable. Element: {1}", $attr.ngModel, startingTag($element));
          }
        };
        this.$render = noop;
        this.$isEmpty = function(value) {
          return isUndefined(value) || value === '' || value === null || value !== value;
        };
        this.$$updateEmptyClasses = function(value) {
          if (ctrl.$isEmpty(value)) {
            $animate.removeClass($element, NOT_EMPTY_CLASS);
            $animate.addClass($element, EMPTY_CLASS);
          } else {
            $animate.removeClass($element, EMPTY_CLASS);
            $animate.addClass($element, NOT_EMPTY_CLASS);
          }
        };
        var currentValidationRunId = 0;
        addSetValidityMethod({
          ctrl: this,
          $element: $element,
          set: function(object, property) {
            object[property] = true;
          },
          unset: function(object, property) {
            delete object[property];
          },
          $animate: $animate
        });
        this.$setPristine = function() {
          ctrl.$dirty = false;
          ctrl.$pristine = true;
          $animate.removeClass($element, DIRTY_CLASS);
          $animate.addClass($element, PRISTINE_CLASS);
        };
        this.$setDirty = function() {
          ctrl.$dirty = true;
          ctrl.$pristine = false;
          $animate.removeClass($element, PRISTINE_CLASS);
          $animate.addClass($element, DIRTY_CLASS);
          ctrl.$$parentForm.$setDirty();
        };
        this.$setUntouched = function() {
          ctrl.$touched = false;
          ctrl.$untouched = true;
          $animate.setClass($element, UNTOUCHED_CLASS, TOUCHED_CLASS);
        };
        this.$setTouched = function() {
          ctrl.$touched = true;
          ctrl.$untouched = false;
          $animate.setClass($element, TOUCHED_CLASS, UNTOUCHED_CLASS);
        };
        this.$rollbackViewValue = function() {
          $timeout.cancel(pendingDebounce);
          ctrl.$viewValue = ctrl.$$lastCommittedViewValue;
          ctrl.$render();
        };
        this.$validate = function() {
          if (isNumber(ctrl.$modelValue) && isNaN(ctrl.$modelValue)) {
            return;
          }
          var viewValue = ctrl.$$lastCommittedViewValue;
          var modelValue = ctrl.$$rawModelValue;
          var prevValid = ctrl.$valid;
          var prevModelValue = ctrl.$modelValue;
          var allowInvalid = ctrl.$options && ctrl.$options.allowInvalid;
          ctrl.$$runValidators(modelValue, viewValue, function(allValid) {
            if (!allowInvalid && prevValid !== allValid) {
              ctrl.$modelValue = allValid ? modelValue : undefined;
              if (ctrl.$modelValue !== prevModelValue) {
                ctrl.$$writeModelToScope();
              }
            }
          });
        };
        this.$$runValidators = function(modelValue, viewValue, doneCallback) {
          currentValidationRunId++;
          var localValidationRunId = currentValidationRunId;
          if (!processParseErrors()) {
            validationDone(false);
            return;
          }
          if (!processSyncValidators()) {
            validationDone(false);
            return;
          }
          processAsyncValidators();
          function processParseErrors() {
            var errorKey = ctrl.$$parserName || 'parse';
            if (isUndefined(parserValid)) {
              setValidity(errorKey, null);
            } else {
              if (!parserValid) {
                forEach(ctrl.$validators, function(v, name) {
                  setValidity(name, null);
                });
                forEach(ctrl.$asyncValidators, function(v, name) {
                  setValidity(name, null);
                });
              }
              setValidity(errorKey, parserValid);
              return parserValid;
            }
            return true;
          }
          function processSyncValidators() {
            var syncValidatorsValid = true;
            forEach(ctrl.$validators, function(validator, name) {
              var result = validator(modelValue, viewValue);
              syncValidatorsValid = syncValidatorsValid && result;
              setValidity(name, result);
            });
            if (!syncValidatorsValid) {
              forEach(ctrl.$asyncValidators, function(v, name) {
                setValidity(name, null);
              });
              return false;
            }
            return true;
          }
          function processAsyncValidators() {
            var validatorPromises = [];
            var allValid = true;
            forEach(ctrl.$asyncValidators, function(validator, name) {
              var promise = validator(modelValue, viewValue);
              if (!isPromiseLike(promise)) {
                throw ngModelMinErr('nopromise', "Expected asynchronous validator to return a promise but got '{0}' instead.", promise);
              }
              setValidity(name, undefined);
              validatorPromises.push(promise.then(function() {
                setValidity(name, true);
              }, function() {
                allValid = false;
                setValidity(name, false);
              }));
            });
            if (!validatorPromises.length) {
              validationDone(true);
            } else {
              $q.all(validatorPromises).then(function() {
                validationDone(allValid);
              }, noop);
            }
          }
          function setValidity(name, isValid) {
            if (localValidationRunId === currentValidationRunId) {
              ctrl.$setValidity(name, isValid);
            }
          }
          function validationDone(allValid) {
            if (localValidationRunId === currentValidationRunId) {
              doneCallback(allValid);
            }
          }
        };
        this.$commitViewValue = function() {
          var viewValue = ctrl.$viewValue;
          $timeout.cancel(pendingDebounce);
          if (ctrl.$$lastCommittedViewValue === viewValue && (viewValue !== '' || !ctrl.$$hasNativeValidators)) {
            return;
          }
          ctrl.$$updateEmptyClasses(viewValue);
          ctrl.$$lastCommittedViewValue = viewValue;
          if (ctrl.$pristine) {
            this.$setDirty();
          }
          this.$$parseAndValidate();
        };
        this.$$parseAndValidate = function() {
          var viewValue = ctrl.$$lastCommittedViewValue;
          var modelValue = viewValue;
          parserValid = isUndefined(modelValue) ? undefined : true;
          if (parserValid) {
            for (var i = 0; i < ctrl.$parsers.length; i++) {
              modelValue = ctrl.$parsers[i](modelValue);
              if (isUndefined(modelValue)) {
                parserValid = false;
                break;
              }
            }
          }
          if (isNumber(ctrl.$modelValue) && isNaN(ctrl.$modelValue)) {
            ctrl.$modelValue = ngModelGet($scope);
          }
          var prevModelValue = ctrl.$modelValue;
          var allowInvalid = ctrl.$options && ctrl.$options.allowInvalid;
          ctrl.$$rawModelValue = modelValue;
          if (allowInvalid) {
            ctrl.$modelValue = modelValue;
            writeToModelIfNeeded();
          }
          ctrl.$$runValidators(modelValue, ctrl.$$lastCommittedViewValue, function(allValid) {
            if (!allowInvalid) {
              ctrl.$modelValue = allValid ? modelValue : undefined;
              writeToModelIfNeeded();
            }
          });
          function writeToModelIfNeeded() {
            if (ctrl.$modelValue !== prevModelValue) {
              ctrl.$$writeModelToScope();
            }
          }
        };
        this.$$writeModelToScope = function() {
          ngModelSet($scope, ctrl.$modelValue);
          forEach(ctrl.$viewChangeListeners, function(listener) {
            try {
              listener();
            } catch (e) {
              $exceptionHandler(e);
            }
          });
        };
        this.$setViewValue = function(value, trigger) {
          ctrl.$viewValue = value;
          if (!ctrl.$options || ctrl.$options.updateOnDefault) {
            ctrl.$$debounceViewValueCommit(trigger);
          }
        };
        this.$$debounceViewValueCommit = function(trigger) {
          var debounceDelay = 0,
              options = ctrl.$options,
              debounce;
          if (options && isDefined(options.debounce)) {
            debounce = options.debounce;
            if (isNumber(debounce)) {
              debounceDelay = debounce;
            } else if (isNumber(debounce[trigger])) {
              debounceDelay = debounce[trigger];
            } else if (isNumber(debounce['default'])) {
              debounceDelay = debounce['default'];
            }
          }
          $timeout.cancel(pendingDebounce);
          if (debounceDelay) {
            pendingDebounce = $timeout(function() {
              ctrl.$commitViewValue();
            }, debounceDelay);
          } else if ($rootScope.$$phase) {
            ctrl.$commitViewValue();
          } else {
            $scope.$apply(function() {
              ctrl.$commitViewValue();
            });
          }
        };
        $scope.$watch(function ngModelWatch() {
          var modelValue = ngModelGet($scope);
          if (modelValue !== ctrl.$modelValue && (ctrl.$modelValue === ctrl.$modelValue || modelValue === modelValue)) {
            ctrl.$modelValue = ctrl.$$rawModelValue = modelValue;
            parserValid = undefined;
            var formatters = ctrl.$formatters,
                idx = formatters.length;
            var viewValue = modelValue;
            while (idx--) {
              viewValue = formatters[idx](viewValue);
            }
            if (ctrl.$viewValue !== viewValue) {
              ctrl.$$updateEmptyClasses(viewValue);
              ctrl.$viewValue = ctrl.$$lastCommittedViewValue = viewValue;
              ctrl.$render();
              ctrl.$$runValidators(modelValue, viewValue, noop);
            }
          }
          return modelValue;
        });
      }];
      var ngModelDirective = ['$rootScope', function($rootScope) {
        return {
          restrict: 'A',
          require: ['ngModel', '^?form', '^?ngModelOptions'],
          controller: NgModelController,
          priority: 1,
          compile: function ngModelCompile(element) {
            element.addClass(PRISTINE_CLASS).addClass(UNTOUCHED_CLASS).addClass(VALID_CLASS);
            return {
              pre: function ngModelPreLink(scope, element, attr, ctrls) {
                var modelCtrl = ctrls[0],
                    formCtrl = ctrls[1] || modelCtrl.$$parentForm;
                modelCtrl.$$setOptions(ctrls[2] && ctrls[2].$options);
                formCtrl.$addControl(modelCtrl);
                attr.$observe('name', function(newValue) {
                  if (modelCtrl.$name !== newValue) {
                    modelCtrl.$$parentForm.$$renameControl(modelCtrl, newValue);
                  }
                });
                scope.$on('$destroy', function() {
                  modelCtrl.$$parentForm.$removeControl(modelCtrl);
                });
              },
              post: function ngModelPostLink(scope, element, attr, ctrls) {
                var modelCtrl = ctrls[0];
                if (modelCtrl.$options && modelCtrl.$options.updateOn) {
                  element.on(modelCtrl.$options.updateOn, function(ev) {
                    modelCtrl.$$debounceViewValueCommit(ev && ev.type);
                  });
                }
                element.on('blur', function() {
                  if (modelCtrl.$touched)
                    return;
                  if ($rootScope.$$phase) {
                    scope.$evalAsync(modelCtrl.$setTouched);
                  } else {
                    scope.$apply(modelCtrl.$setTouched);
                  }
                });
              }
            };
          }
        };
      }];
      var DEFAULT_REGEXP = /(\s+|^)default(\s+|$)/;
      var ngModelOptionsDirective = function() {
        return {
          restrict: 'A',
          controller: ['$scope', '$attrs', function($scope, $attrs) {
            var that = this;
            this.$options = copy($scope.$eval($attrs.ngModelOptions));
            if (isDefined(this.$options.updateOn)) {
              this.$options.updateOnDefault = false;
              this.$options.updateOn = trim(this.$options.updateOn.replace(DEFAULT_REGEXP, function() {
                that.$options.updateOnDefault = true;
                return ' ';
              }));
            } else {
              this.$options.updateOnDefault = true;
            }
          }]
        };
      };
      function addSetValidityMethod(context) {
        var ctrl = context.ctrl,
            $element = context.$element,
            classCache = {},
            set = context.set,
            unset = context.unset,
            $animate = context.$animate;
        classCache[INVALID_CLASS] = !(classCache[VALID_CLASS] = $element.hasClass(VALID_CLASS));
        ctrl.$setValidity = setValidity;
        function setValidity(validationErrorKey, state, controller) {
          if (isUndefined(state)) {
            createAndSet('$pending', validationErrorKey, controller);
          } else {
            unsetAndCleanup('$pending', validationErrorKey, controller);
          }
          if (!isBoolean(state)) {
            unset(ctrl.$error, validationErrorKey, controller);
            unset(ctrl.$$success, validationErrorKey, controller);
          } else {
            if (state) {
              unset(ctrl.$error, validationErrorKey, controller);
              set(ctrl.$$success, validationErrorKey, controller);
            } else {
              set(ctrl.$error, validationErrorKey, controller);
              unset(ctrl.$$success, validationErrorKey, controller);
            }
          }
          if (ctrl.$pending) {
            cachedToggleClass(PENDING_CLASS, true);
            ctrl.$valid = ctrl.$invalid = undefined;
            toggleValidationCss('', null);
          } else {
            cachedToggleClass(PENDING_CLASS, false);
            ctrl.$valid = isObjectEmpty(ctrl.$error);
            ctrl.$invalid = !ctrl.$valid;
            toggleValidationCss('', ctrl.$valid);
          }
          var combinedState;
          if (ctrl.$pending && ctrl.$pending[validationErrorKey]) {
            combinedState = undefined;
          } else if (ctrl.$error[validationErrorKey]) {
            combinedState = false;
          } else if (ctrl.$$success[validationErrorKey]) {
            combinedState = true;
          } else {
            combinedState = null;
          }
          toggleValidationCss(validationErrorKey, combinedState);
          ctrl.$$parentForm.$setValidity(validationErrorKey, combinedState, ctrl);
        }
        function createAndSet(name, value, controller) {
          if (!ctrl[name]) {
            ctrl[name] = {};
          }
          set(ctrl[name], value, controller);
        }
        function unsetAndCleanup(name, value, controller) {
          if (ctrl[name]) {
            unset(ctrl[name], value, controller);
          }
          if (isObjectEmpty(ctrl[name])) {
            ctrl[name] = undefined;
          }
        }
        function cachedToggleClass(className, switchValue) {
          if (switchValue && !classCache[className]) {
            $animate.addClass($element, className);
            classCache[className] = true;
          } else if (!switchValue && classCache[className]) {
            $animate.removeClass($element, className);
            classCache[className] = false;
          }
        }
        function toggleValidationCss(validationErrorKey, isValid) {
          validationErrorKey = validationErrorKey ? '-' + snake_case(validationErrorKey, '-') : '';
          cachedToggleClass(VALID_CLASS + validationErrorKey, isValid === true);
          cachedToggleClass(INVALID_CLASS + validationErrorKey, isValid === false);
        }
      }
      function isObjectEmpty(obj) {
        if (obj) {
          for (var prop in obj) {
            if (obj.hasOwnProperty(prop)) {
              return false;
            }
          }
        }
        return true;
      }
      var ngNonBindableDirective = ngDirective({
        terminal: true,
        priority: 1000
      });
      var ngOptionsMinErr = minErr('ngOptions');
      var NG_OPTIONS_REGEXP = /^\s*([\s\S]+?)(?:\s+as\s+([\s\S]+?))?(?:\s+group\s+by\s+([\s\S]+?))?(?:\s+disable\s+when\s+([\s\S]+?))?\s+for\s+(?:([\$\w][\$\w]*)|(?:\(\s*([\$\w][\$\w]*)\s*,\s*([\$\w][\$\w]*)\s*\)))\s+in\s+([\s\S]+?)(?:\s+track\s+by\s+([\s\S]+?))?$/;
      var ngOptionsDirective = ['$compile', '$document', '$parse', function($compile, $document, $parse) {
        function parseOptionsExpression(optionsExp, selectElement, scope) {
          var match = optionsExp.match(NG_OPTIONS_REGEXP);
          if (!(match)) {
            throw ngOptionsMinErr('iexp', "Expected expression in form of " + "'_select_ (as _label_)? for (_key_,)?_value_ in _collection_'" + " but got '{0}'. Element: {1}", optionsExp, startingTag(selectElement));
          }
          var valueName = match[5] || match[7];
          var keyName = match[6];
          var selectAs = / as /.test(match[0]) && match[1];
          var trackBy = match[9];
          var valueFn = $parse(match[2] ? match[1] : valueName);
          var selectAsFn = selectAs && $parse(selectAs);
          var viewValueFn = selectAsFn || valueFn;
          var trackByFn = trackBy && $parse(trackBy);
          var getTrackByValueFn = trackBy ? function(value, locals) {
            return trackByFn(scope, locals);
          } : function getHashOfValue(value) {
            return hashKey(value);
          };
          var getTrackByValue = function(value, key) {
            return getTrackByValueFn(value, getLocals(value, key));
          };
          var displayFn = $parse(match[2] || match[1]);
          var groupByFn = $parse(match[3] || '');
          var disableWhenFn = $parse(match[4] || '');
          var valuesFn = $parse(match[8]);
          var locals = {};
          var getLocals = keyName ? function(value, key) {
            locals[keyName] = key;
            locals[valueName] = value;
            return locals;
          } : function(value) {
            locals[valueName] = value;
            return locals;
          };
          function Option(selectValue, viewValue, label, group, disabled) {
            this.selectValue = selectValue;
            this.viewValue = viewValue;
            this.label = label;
            this.group = group;
            this.disabled = disabled;
          }
          function getOptionValuesKeys(optionValues) {
            var optionValuesKeys;
            if (!keyName && isArrayLike(optionValues)) {
              optionValuesKeys = optionValues;
            } else {
              optionValuesKeys = [];
              for (var itemKey in optionValues) {
                if (optionValues.hasOwnProperty(itemKey) && itemKey.charAt(0) !== '$') {
                  optionValuesKeys.push(itemKey);
                }
              }
            }
            return optionValuesKeys;
          }
          return {
            trackBy: trackBy,
            getTrackByValue: getTrackByValue,
            getWatchables: $parse(valuesFn, function(optionValues) {
              var watchedArray = [];
              optionValues = optionValues || [];
              var optionValuesKeys = getOptionValuesKeys(optionValues);
              var optionValuesLength = optionValuesKeys.length;
              for (var index = 0; index < optionValuesLength; index++) {
                var key = (optionValues === optionValuesKeys) ? index : optionValuesKeys[index];
                var value = optionValues[key];
                var locals = getLocals(value, key);
                var selectValue = getTrackByValueFn(value, locals);
                watchedArray.push(selectValue);
                if (match[2] || match[1]) {
                  var label = displayFn(scope, locals);
                  watchedArray.push(label);
                }
                if (match[4]) {
                  var disableWhen = disableWhenFn(scope, locals);
                  watchedArray.push(disableWhen);
                }
              }
              return watchedArray;
            }),
            getOptions: function() {
              var optionItems = [];
              var selectValueMap = {};
              var optionValues = valuesFn(scope) || [];
              var optionValuesKeys = getOptionValuesKeys(optionValues);
              var optionValuesLength = optionValuesKeys.length;
              for (var index = 0; index < optionValuesLength; index++) {
                var key = (optionValues === optionValuesKeys) ? index : optionValuesKeys[index];
                var value = optionValues[key];
                var locals = getLocals(value, key);
                var viewValue = viewValueFn(scope, locals);
                var selectValue = getTrackByValueFn(viewValue, locals);
                var label = displayFn(scope, locals);
                var group = groupByFn(scope, locals);
                var disabled = disableWhenFn(scope, locals);
                var optionItem = new Option(selectValue, viewValue, label, group, disabled);
                optionItems.push(optionItem);
                selectValueMap[selectValue] = optionItem;
              }
              return {
                items: optionItems,
                selectValueMap: selectValueMap,
                getOptionFromViewValue: function(value) {
                  return selectValueMap[getTrackByValue(value)];
                },
                getViewValueFromOption: function(option) {
                  return trackBy ? angular.copy(option.viewValue) : option.viewValue;
                }
              };
            }
          };
        }
        var optionTemplate = window.document.createElement('option'),
            optGroupTemplate = window.document.createElement('optgroup');
        function ngOptionsPostLink(scope, selectElement, attr, ctrls) {
          var selectCtrl = ctrls[0];
          var ngModelCtrl = ctrls[1];
          var multiple = attr.multiple;
          var emptyOption;
          for (var i = 0,
              children = selectElement.children(),
              ii = children.length; i < ii; i++) {
            if (children[i].value === '') {
              emptyOption = children.eq(i);
              break;
            }
          }
          var providedEmptyOption = !!emptyOption;
          var unknownOption = jqLite(optionTemplate.cloneNode(false));
          unknownOption.val('?');
          var options;
          var ngOptions = parseOptionsExpression(attr.ngOptions, selectElement, scope);
          var listFragment = $document[0].createDocumentFragment();
          var renderEmptyOption = function() {
            if (!providedEmptyOption) {
              selectElement.prepend(emptyOption);
            }
            selectElement.val('');
            emptyOption.prop('selected', true);
            emptyOption.attr('selected', true);
          };
          var removeEmptyOption = function() {
            if (!providedEmptyOption) {
              emptyOption.remove();
            }
          };
          var renderUnknownOption = function() {
            selectElement.prepend(unknownOption);
            selectElement.val('?');
            unknownOption.prop('selected', true);
            unknownOption.attr('selected', true);
          };
          var removeUnknownOption = function() {
            unknownOption.remove();
          };
          if (!multiple) {
            selectCtrl.writeValue = function writeNgOptionsValue(value) {
              var option = options.getOptionFromViewValue(value);
              if (option) {
                if (selectElement[0].value !== option.selectValue) {
                  removeUnknownOption();
                  removeEmptyOption();
                  selectElement[0].value = option.selectValue;
                  option.element.selected = true;
                }
                option.element.setAttribute('selected', 'selected');
              } else {
                if (value === null || providedEmptyOption) {
                  removeUnknownOption();
                  renderEmptyOption();
                } else {
                  removeEmptyOption();
                  renderUnknownOption();
                }
              }
            };
            selectCtrl.readValue = function readNgOptionsValue() {
              var selectedOption = options.selectValueMap[selectElement.val()];
              if (selectedOption && !selectedOption.disabled) {
                removeEmptyOption();
                removeUnknownOption();
                return options.getViewValueFromOption(selectedOption);
              }
              return null;
            };
            if (ngOptions.trackBy) {
              scope.$watch(function() {
                return ngOptions.getTrackByValue(ngModelCtrl.$viewValue);
              }, function() {
                ngModelCtrl.$render();
              });
            }
          } else {
            ngModelCtrl.$isEmpty = function(value) {
              return !value || value.length === 0;
            };
            selectCtrl.writeValue = function writeNgOptionsMultiple(value) {
              options.items.forEach(function(option) {
                option.element.selected = false;
              });
              if (value) {
                value.forEach(function(item) {
                  var option = options.getOptionFromViewValue(item);
                  if (option)
                    option.element.selected = true;
                });
              }
            };
            selectCtrl.readValue = function readNgOptionsMultiple() {
              var selectedValues = selectElement.val() || [],
                  selections = [];
              forEach(selectedValues, function(value) {
                var option = options.selectValueMap[value];
                if (option && !option.disabled)
                  selections.push(options.getViewValueFromOption(option));
              });
              return selections;
            };
            if (ngOptions.trackBy) {
              scope.$watchCollection(function() {
                if (isArray(ngModelCtrl.$viewValue)) {
                  return ngModelCtrl.$viewValue.map(function(value) {
                    return ngOptions.getTrackByValue(value);
                  });
                }
              }, function() {
                ngModelCtrl.$render();
              });
            }
          }
          if (providedEmptyOption) {
            emptyOption.remove();
            $compile(emptyOption)(scope);
            emptyOption.removeClass('ng-scope');
          } else {
            emptyOption = jqLite(optionTemplate.cloneNode(false));
          }
          selectElement.empty();
          updateOptions();
          scope.$watchCollection(ngOptions.getWatchables, updateOptions);
          function addOptionElement(option, parent) {
            var optionElement = optionTemplate.cloneNode(false);
            parent.appendChild(optionElement);
            updateOptionElement(option, optionElement);
          }
          function updateOptionElement(option, element) {
            option.element = element;
            element.disabled = option.disabled;
            if (option.label !== element.label) {
              element.label = option.label;
              element.textContent = option.label;
            }
            if (option.value !== element.value)
              element.value = option.selectValue;
          }
          function updateOptions() {
            var previousValue = options && selectCtrl.readValue();
            if (options) {
              for (var i = options.items.length - 1; i >= 0; i--) {
                var option = options.items[i];
                if (option.group) {
                  jqLiteRemove(option.element.parentNode);
                } else {
                  jqLiteRemove(option.element);
                }
              }
            }
            options = ngOptions.getOptions();
            var groupElementMap = {};
            if (providedEmptyOption) {
              selectElement.prepend(emptyOption);
            }
            options.items.forEach(function addOption(option) {
              var groupElement;
              if (isDefined(option.group)) {
                groupElement = groupElementMap[option.group];
                if (!groupElement) {
                  groupElement = optGroupTemplate.cloneNode(false);
                  listFragment.appendChild(groupElement);
                  groupElement.label = option.group;
                  groupElementMap[option.group] = groupElement;
                }
                addOptionElement(option, groupElement);
              } else {
                addOptionElement(option, listFragment);
              }
            });
            selectElement[0].appendChild(listFragment);
            ngModelCtrl.$render();
            if (!ngModelCtrl.$isEmpty(previousValue)) {
              var nextValue = selectCtrl.readValue();
              var isNotPrimitive = ngOptions.trackBy || multiple;
              if (isNotPrimitive ? !equals(previousValue, nextValue) : previousValue !== nextValue) {
                ngModelCtrl.$setViewValue(nextValue);
                ngModelCtrl.$render();
              }
            }
          }
        }
        return {
          restrict: 'A',
          terminal: true,
          require: ['select', 'ngModel'],
          link: {
            pre: function ngOptionsPreLink(scope, selectElement, attr, ctrls) {
              ctrls[0].registerOption = noop;
            },
            post: ngOptionsPostLink
          }
        };
      }];
      var ngPluralizeDirective = ['$locale', '$interpolate', '$log', function($locale, $interpolate, $log) {
        var BRACE = /{}/g,
            IS_WHEN = /^when(Minus)?(.+)$/;
        return {link: function(scope, element, attr) {
            var numberExp = attr.count,
                whenExp = attr.$attr.when && element.attr(attr.$attr.when),
                offset = attr.offset || 0,
                whens = scope.$eval(whenExp) || {},
                whensExpFns = {},
                startSymbol = $interpolate.startSymbol(),
                endSymbol = $interpolate.endSymbol(),
                braceReplacement = startSymbol + numberExp + '-' + offset + endSymbol,
                watchRemover = angular.noop,
                lastCount;
            forEach(attr, function(expression, attributeName) {
              var tmpMatch = IS_WHEN.exec(attributeName);
              if (tmpMatch) {
                var whenKey = (tmpMatch[1] ? '-' : '') + lowercase(tmpMatch[2]);
                whens[whenKey] = element.attr(attr.$attr[attributeName]);
              }
            });
            forEach(whens, function(expression, key) {
              whensExpFns[key] = $interpolate(expression.replace(BRACE, braceReplacement));
            });
            scope.$watch(numberExp, function ngPluralizeWatchAction(newVal) {
              var count = parseFloat(newVal);
              var countIsNaN = isNaN(count);
              if (!countIsNaN && !(count in whens)) {
                count = $locale.pluralCat(count - offset);
              }
              if ((count !== lastCount) && !(countIsNaN && isNumber(lastCount) && isNaN(lastCount))) {
                watchRemover();
                var whenExpFn = whensExpFns[count];
                if (isUndefined(whenExpFn)) {
                  if (newVal != null) {
                    $log.debug("ngPluralize: no rule defined for '" + count + "' in " + whenExp);
                  }
                  watchRemover = noop;
                  updateElementText();
                } else {
                  watchRemover = scope.$watch(whenExpFn, updateElementText);
                }
                lastCount = count;
              }
            });
            function updateElementText(newText) {
              element.text(newText || '');
            }
          }};
      }];
      var ngRepeatDirective = ['$parse', '$animate', '$compile', function($parse, $animate, $compile) {
        var NG_REMOVED = '$$NG_REMOVED';
        var ngRepeatMinErr = minErr('ngRepeat');
        var updateScope = function(scope, index, valueIdentifier, value, keyIdentifier, key, arrayLength) {
          scope[valueIdentifier] = value;
          if (keyIdentifier)
            scope[keyIdentifier] = key;
          scope.$index = index;
          scope.$first = (index === 0);
          scope.$last = (index === (arrayLength - 1));
          scope.$middle = !(scope.$first || scope.$last);
          scope.$odd = !(scope.$even = (index & 1) === 0);
        };
        var getBlockStart = function(block) {
          return block.clone[0];
        };
        var getBlockEnd = function(block) {
          return block.clone[block.clone.length - 1];
        };
        return {
          restrict: 'A',
          multiElement: true,
          transclude: 'element',
          priority: 1000,
          terminal: true,
          $$tlb: true,
          compile: function ngRepeatCompile($element, $attr) {
            var expression = $attr.ngRepeat;
            var ngRepeatEndComment = $compile.$$createComment('end ngRepeat', expression);
            var match = expression.match(/^\s*([\s\S]+?)\s+in\s+([\s\S]+?)(?:\s+as\s+([\s\S]+?))?(?:\s+track\s+by\s+([\s\S]+?))?\s*$/);
            if (!match) {
              throw ngRepeatMinErr('iexp', "Expected expression in form of '_item_ in _collection_[ track by _id_]' but got '{0}'.", expression);
            }
            var lhs = match[1];
            var rhs = match[2];
            var aliasAs = match[3];
            var trackByExp = match[4];
            match = lhs.match(/^(?:(\s*[\$\w]+)|\(\s*([\$\w]+)\s*,\s*([\$\w]+)\s*\))$/);
            if (!match) {
              throw ngRepeatMinErr('iidexp', "'_item_' in '_item_ in _collection_' should be an identifier or '(_key_, _value_)' expression, but got '{0}'.", lhs);
            }
            var valueIdentifier = match[3] || match[1];
            var keyIdentifier = match[2];
            if (aliasAs && (!/^[$a-zA-Z_][$a-zA-Z0-9_]*$/.test(aliasAs) || /^(null|undefined|this|\$index|\$first|\$middle|\$last|\$even|\$odd|\$parent|\$root|\$id)$/.test(aliasAs))) {
              throw ngRepeatMinErr('badident', "alias '{0}' is invalid --- must be a valid JS identifier which is not a reserved name.", aliasAs);
            }
            var trackByExpGetter,
                trackByIdExpFn,
                trackByIdArrayFn,
                trackByIdObjFn;
            var hashFnLocals = {$id: hashKey};
            if (trackByExp) {
              trackByExpGetter = $parse(trackByExp);
            } else {
              trackByIdArrayFn = function(key, value) {
                return hashKey(value);
              };
              trackByIdObjFn = function(key) {
                return key;
              };
            }
            return function ngRepeatLink($scope, $element, $attr, ctrl, $transclude) {
              if (trackByExpGetter) {
                trackByIdExpFn = function(key, value, index) {
                  if (keyIdentifier)
                    hashFnLocals[keyIdentifier] = key;
                  hashFnLocals[valueIdentifier] = value;
                  hashFnLocals.$index = index;
                  return trackByExpGetter($scope, hashFnLocals);
                };
              }
              var lastBlockMap = createMap();
              $scope.$watchCollection(rhs, function ngRepeatAction(collection) {
                var index,
                    length,
                    previousNode = $element[0],
                    nextNode,
                    nextBlockMap = createMap(),
                    collectionLength,
                    key,
                    value,
                    trackById,
                    trackByIdFn,
                    collectionKeys,
                    block,
                    nextBlockOrder,
                    elementsToRemove;
                if (aliasAs) {
                  $scope[aliasAs] = collection;
                }
                if (isArrayLike(collection)) {
                  collectionKeys = collection;
                  trackByIdFn = trackByIdExpFn || trackByIdArrayFn;
                } else {
                  trackByIdFn = trackByIdExpFn || trackByIdObjFn;
                  collectionKeys = [];
                  for (var itemKey in collection) {
                    if (hasOwnProperty.call(collection, itemKey) && itemKey.charAt(0) !== '$') {
                      collectionKeys.push(itemKey);
                    }
                  }
                }
                collectionLength = collectionKeys.length;
                nextBlockOrder = new Array(collectionLength);
                for (index = 0; index < collectionLength; index++) {
                  key = (collection === collectionKeys) ? index : collectionKeys[index];
                  value = collection[key];
                  trackById = trackByIdFn(key, value, index);
                  if (lastBlockMap[trackById]) {
                    block = lastBlockMap[trackById];
                    delete lastBlockMap[trackById];
                    nextBlockMap[trackById] = block;
                    nextBlockOrder[index] = block;
                  } else if (nextBlockMap[trackById]) {
                    forEach(nextBlockOrder, function(block) {
                      if (block && block.scope)
                        lastBlockMap[block.id] = block;
                    });
                    throw ngRepeatMinErr('dupes', "Duplicates in a repeater are not allowed. Use 'track by' expression to specify unique keys. Repeater: {0}, Duplicate key: {1}, Duplicate value: {2}", expression, trackById, value);
                  } else {
                    nextBlockOrder[index] = {
                      id: trackById,
                      scope: undefined,
                      clone: undefined
                    };
                    nextBlockMap[trackById] = true;
                  }
                }
                for (var blockKey in lastBlockMap) {
                  block = lastBlockMap[blockKey];
                  elementsToRemove = getBlockNodes(block.clone);
                  $animate.leave(elementsToRemove);
                  if (elementsToRemove[0].parentNode) {
                    for (index = 0, length = elementsToRemove.length; index < length; index++) {
                      elementsToRemove[index][NG_REMOVED] = true;
                    }
                  }
                  block.scope.$destroy();
                }
                for (index = 0; index < collectionLength; index++) {
                  key = (collection === collectionKeys) ? index : collectionKeys[index];
                  value = collection[key];
                  block = nextBlockOrder[index];
                  if (block.scope) {
                    nextNode = previousNode;
                    do {
                      nextNode = nextNode.nextSibling;
                    } while (nextNode && nextNode[NG_REMOVED]);
                    if (getBlockStart(block) != nextNode) {
                      $animate.move(getBlockNodes(block.clone), null, previousNode);
                    }
                    previousNode = getBlockEnd(block);
                    updateScope(block.scope, index, valueIdentifier, value, keyIdentifier, key, collectionLength);
                  } else {
                    $transclude(function ngRepeatTransclude(clone, scope) {
                      block.scope = scope;
                      var endNode = ngRepeatEndComment.cloneNode(false);
                      clone[clone.length++] = endNode;
                      $animate.enter(clone, null, previousNode);
                      previousNode = endNode;
                      block.clone = clone;
                      nextBlockMap[block.id] = block;
                      updateScope(block.scope, index, valueIdentifier, value, keyIdentifier, key, collectionLength);
                    });
                  }
                }
                lastBlockMap = nextBlockMap;
              });
            };
          }
        };
      }];
      var NG_HIDE_CLASS = 'ng-hide';
      var NG_HIDE_IN_PROGRESS_CLASS = 'ng-hide-animate';
      var ngShowDirective = ['$animate', function($animate) {
        return {
          restrict: 'A',
          multiElement: true,
          link: function(scope, element, attr) {
            scope.$watch(attr.ngShow, function ngShowWatchAction(value) {
              $animate[value ? 'removeClass' : 'addClass'](element, NG_HIDE_CLASS, {tempClasses: NG_HIDE_IN_PROGRESS_CLASS});
            });
          }
        };
      }];
      var ngHideDirective = ['$animate', function($animate) {
        return {
          restrict: 'A',
          multiElement: true,
          link: function(scope, element, attr) {
            scope.$watch(attr.ngHide, function ngHideWatchAction(value) {
              $animate[value ? 'addClass' : 'removeClass'](element, NG_HIDE_CLASS, {tempClasses: NG_HIDE_IN_PROGRESS_CLASS});
            });
          }
        };
      }];
      var ngStyleDirective = ngDirective(function(scope, element, attr) {
        scope.$watch(attr.ngStyle, function ngStyleWatchAction(newStyles, oldStyles) {
          if (oldStyles && (newStyles !== oldStyles)) {
            forEach(oldStyles, function(val, style) {
              element.css(style, '');
            });
          }
          if (newStyles)
            element.css(newStyles);
        }, true);
      });
      var ngSwitchDirective = ['$animate', '$compile', function($animate, $compile) {
        return {
          require: 'ngSwitch',
          controller: ['$scope', function ngSwitchController() {
            this.cases = {};
          }],
          link: function(scope, element, attr, ngSwitchController) {
            var watchExpr = attr.ngSwitch || attr.on,
                selectedTranscludes = [],
                selectedElements = [],
                previousLeaveAnimations = [],
                selectedScopes = [];
            var spliceFactory = function(array, index) {
              return function() {
                array.splice(index, 1);
              };
            };
            scope.$watch(watchExpr, function ngSwitchWatchAction(value) {
              var i,
                  ii;
              for (i = 0, ii = previousLeaveAnimations.length; i < ii; ++i) {
                $animate.cancel(previousLeaveAnimations[i]);
              }
              previousLeaveAnimations.length = 0;
              for (i = 0, ii = selectedScopes.length; i < ii; ++i) {
                var selected = getBlockNodes(selectedElements[i].clone);
                selectedScopes[i].$destroy();
                var promise = previousLeaveAnimations[i] = $animate.leave(selected);
                promise.then(spliceFactory(previousLeaveAnimations, i));
              }
              selectedElements.length = 0;
              selectedScopes.length = 0;
              if ((selectedTranscludes = ngSwitchController.cases['!' + value] || ngSwitchController.cases['?'])) {
                forEach(selectedTranscludes, function(selectedTransclude) {
                  selectedTransclude.transclude(function(caseElement, selectedScope) {
                    selectedScopes.push(selectedScope);
                    var anchor = selectedTransclude.element;
                    caseElement[caseElement.length++] = $compile.$$createComment('end ngSwitchWhen');
                    var block = {clone: caseElement};
                    selectedElements.push(block);
                    $animate.enter(caseElement, anchor.parent(), anchor);
                  });
                });
              }
            });
          }
        };
      }];
      var ngSwitchWhenDirective = ngDirective({
        transclude: 'element',
        priority: 1200,
        require: '^ngSwitch',
        multiElement: true,
        link: function(scope, element, attrs, ctrl, $transclude) {
          ctrl.cases['!' + attrs.ngSwitchWhen] = (ctrl.cases['!' + attrs.ngSwitchWhen] || []);
          ctrl.cases['!' + attrs.ngSwitchWhen].push({
            transclude: $transclude,
            element: element
          });
        }
      });
      var ngSwitchDefaultDirective = ngDirective({
        transclude: 'element',
        priority: 1200,
        require: '^ngSwitch',
        multiElement: true,
        link: function(scope, element, attr, ctrl, $transclude) {
          ctrl.cases['?'] = (ctrl.cases['?'] || []);
          ctrl.cases['?'].push({
            transclude: $transclude,
            element: element
          });
        }
      });
      var ngTranscludeMinErr = minErr('ngTransclude');
      var ngTranscludeDirective = ngDirective({
        restrict: 'EAC',
        link: function($scope, $element, $attrs, controller, $transclude) {
          if ($attrs.ngTransclude === $attrs.$attr.ngTransclude) {
            $attrs.ngTransclude = '';
          }
          function ngTranscludeCloneAttachFn(clone) {
            if (clone.length) {
              $element.empty();
              $element.append(clone);
            }
          }
          if (!$transclude) {
            throw ngTranscludeMinErr('orphan', 'Illegal use of ngTransclude directive in the template! ' + 'No parent directive that requires a transclusion found. ' + 'Element: {0}', startingTag($element));
          }
          var slotName = $attrs.ngTransclude || $attrs.ngTranscludeSlot;
          $transclude(ngTranscludeCloneAttachFn, null, slotName);
        }
      });
      var scriptDirective = ['$templateCache', function($templateCache) {
        return {
          restrict: 'E',
          terminal: true,
          compile: function(element, attr) {
            if (attr.type == 'text/ng-template') {
              var templateUrl = attr.id,
                  text = element[0].text;
              $templateCache.put(templateUrl, text);
            }
          }
        };
      }];
      var noopNgModelController = {
        $setViewValue: noop,
        $render: noop
      };
      function chromeHack(optionElement) {
        if (optionElement[0].hasAttribute('selected')) {
          optionElement[0].selected = true;
        }
      }
      var SelectController = ['$element', '$scope', function($element, $scope) {
        var self = this,
            optionsMap = new HashMap();
        self.ngModelCtrl = noopNgModelController;
        self.unknownOption = jqLite(window.document.createElement('option'));
        self.renderUnknownOption = function(val) {
          var unknownVal = '? ' + hashKey(val) + ' ?';
          self.unknownOption.val(unknownVal);
          $element.prepend(self.unknownOption);
          $element.val(unknownVal);
        };
        $scope.$on('$destroy', function() {
          self.renderUnknownOption = noop;
        });
        self.removeUnknownOption = function() {
          if (self.unknownOption.parent())
            self.unknownOption.remove();
        };
        self.readValue = function readSingleValue() {
          self.removeUnknownOption();
          return $element.val();
        };
        self.writeValue = function writeSingleValue(value) {
          if (self.hasOption(value)) {
            self.removeUnknownOption();
            $element.val(value);
            if (value === '')
              self.emptyOption.prop('selected', true);
          } else {
            if (value == null && self.emptyOption) {
              self.removeUnknownOption();
              $element.val('');
            } else {
              self.renderUnknownOption(value);
            }
          }
        };
        self.addOption = function(value, element) {
          if (element[0].nodeType === NODE_TYPE_COMMENT)
            return;
          assertNotHasOwnProperty(value, '"option value"');
          if (value === '') {
            self.emptyOption = element;
          }
          var count = optionsMap.get(value) || 0;
          optionsMap.put(value, count + 1);
          self.ngModelCtrl.$render();
          chromeHack(element);
        };
        self.removeOption = function(value) {
          var count = optionsMap.get(value);
          if (count) {
            if (count === 1) {
              optionsMap.remove(value);
              if (value === '') {
                self.emptyOption = undefined;
              }
            } else {
              optionsMap.put(value, count - 1);
            }
          }
        };
        self.hasOption = function(value) {
          return !!optionsMap.get(value);
        };
        self.registerOption = function(optionScope, optionElement, optionAttrs, interpolateValueFn, interpolateTextFn) {
          if (interpolateValueFn) {
            var oldVal;
            optionAttrs.$observe('value', function valueAttributeObserveAction(newVal) {
              if (isDefined(oldVal)) {
                self.removeOption(oldVal);
              }
              oldVal = newVal;
              self.addOption(newVal, optionElement);
            });
          } else if (interpolateTextFn) {
            optionScope.$watch(interpolateTextFn, function interpolateWatchAction(newVal, oldVal) {
              optionAttrs.$set('value', newVal);
              if (oldVal !== newVal) {
                self.removeOption(oldVal);
              }
              self.addOption(newVal, optionElement);
            });
          } else {
            self.addOption(optionAttrs.value, optionElement);
          }
          optionElement.on('$destroy', function() {
            self.removeOption(optionAttrs.value);
            self.ngModelCtrl.$render();
          });
        };
      }];
      var selectDirective = function() {
        return {
          restrict: 'E',
          require: ['select', '?ngModel'],
          controller: SelectController,
          priority: 1,
          link: {
            pre: selectPreLink,
            post: selectPostLink
          }
        };
        function selectPreLink(scope, element, attr, ctrls) {
          var ngModelCtrl = ctrls[1];
          if (!ngModelCtrl)
            return;
          var selectCtrl = ctrls[0];
          selectCtrl.ngModelCtrl = ngModelCtrl;
          element.on('change', function() {
            scope.$apply(function() {
              ngModelCtrl.$setViewValue(selectCtrl.readValue());
            });
          });
          if (attr.multiple) {
            selectCtrl.readValue = function readMultipleValue() {
              var array = [];
              forEach(element.find('option'), function(option) {
                if (option.selected) {
                  array.push(option.value);
                }
              });
              return array;
            };
            selectCtrl.writeValue = function writeMultipleValue(value) {
              var items = new HashMap(value);
              forEach(element.find('option'), function(option) {
                option.selected = isDefined(items.get(option.value));
              });
            };
            var lastView,
                lastViewRef = NaN;
            scope.$watch(function selectMultipleWatch() {
              if (lastViewRef === ngModelCtrl.$viewValue && !equals(lastView, ngModelCtrl.$viewValue)) {
                lastView = shallowCopy(ngModelCtrl.$viewValue);
                ngModelCtrl.$render();
              }
              lastViewRef = ngModelCtrl.$viewValue;
            });
            ngModelCtrl.$isEmpty = function(value) {
              return !value || value.length === 0;
            };
          }
        }
        function selectPostLink(scope, element, attrs, ctrls) {
          var ngModelCtrl = ctrls[1];
          if (!ngModelCtrl)
            return;
          var selectCtrl = ctrls[0];
          ngModelCtrl.$render = function() {
            selectCtrl.writeValue(ngModelCtrl.$viewValue);
          };
        }
      };
      var optionDirective = ['$interpolate', function($interpolate) {
        return {
          restrict: 'E',
          priority: 100,
          compile: function(element, attr) {
            if (isDefined(attr.value)) {
              var interpolateValueFn = $interpolate(attr.value, true);
            } else {
              var interpolateTextFn = $interpolate(element.text(), true);
              if (!interpolateTextFn) {
                attr.$set('value', element.text());
              }
            }
            return function(scope, element, attr) {
              var selectCtrlName = '$selectController',
                  parent = element.parent(),
                  selectCtrl = parent.data(selectCtrlName) || parent.parent().data(selectCtrlName);
              if (selectCtrl) {
                selectCtrl.registerOption(scope, element, attr, interpolateValueFn, interpolateTextFn);
              }
            };
          }
        };
      }];
      var styleDirective = valueFn({
        restrict: 'E',
        terminal: false
      });
      var requiredDirective = function() {
        return {
          restrict: 'A',
          require: '?ngModel',
          link: function(scope, elm, attr, ctrl) {
            if (!ctrl)
              return;
            attr.required = true;
            ctrl.$validators.required = function(modelValue, viewValue) {
              return !attr.required || !ctrl.$isEmpty(viewValue);
            };
            attr.$observe('required', function() {
              ctrl.$validate();
            });
          }
        };
      };
      var patternDirective = function() {
        return {
          restrict: 'A',
          require: '?ngModel',
          link: function(scope, elm, attr, ctrl) {
            if (!ctrl)
              return;
            var regexp,
                patternExp = attr.ngPattern || attr.pattern;
            attr.$observe('pattern', function(regex) {
              if (isString(regex) && regex.length > 0) {
                regex = new RegExp('^' + regex + '$');
              }
              if (regex && !regex.test) {
                throw minErr('ngPattern')('noregexp', 'Expected {0} to be a RegExp but was {1}. Element: {2}', patternExp, regex, startingTag(elm));
              }
              regexp = regex || undefined;
              ctrl.$validate();
            });
            ctrl.$validators.pattern = function(modelValue, viewValue) {
              return ctrl.$isEmpty(viewValue) || isUndefined(regexp) || regexp.test(viewValue);
            };
          }
        };
      };
      var maxlengthDirective = function() {
        return {
          restrict: 'A',
          require: '?ngModel',
          link: function(scope, elm, attr, ctrl) {
            if (!ctrl)
              return;
            var maxlength = -1;
            attr.$observe('maxlength', function(value) {
              var intVal = toInt(value);
              maxlength = isNaN(intVal) ? -1 : intVal;
              ctrl.$validate();
            });
            ctrl.$validators.maxlength = function(modelValue, viewValue) {
              return (maxlength < 0) || ctrl.$isEmpty(viewValue) || (viewValue.length <= maxlength);
            };
          }
        };
      };
      var minlengthDirective = function() {
        return {
          restrict: 'A',
          require: '?ngModel',
          link: function(scope, elm, attr, ctrl) {
            if (!ctrl)
              return;
            var minlength = 0;
            attr.$observe('minlength', function(value) {
              minlength = toInt(value) || 0;
              ctrl.$validate();
            });
            ctrl.$validators.minlength = function(modelValue, viewValue) {
              return ctrl.$isEmpty(viewValue) || viewValue.length >= minlength;
            };
          }
        };
      };
      if (window.angular.bootstrap) {
        if (window.console) {
          console.log('WARNING: Tried to load angular more than once.');
        }
        return;
      }
      bindJQuery();
      publishExternalAPI(angular);
      angular.module("ngLocale", [], ["$provide", function($provide) {
        var PLURAL_CATEGORY = {
          ZERO: "zero",
          ONE: "one",
          TWO: "two",
          FEW: "few",
          MANY: "many",
          OTHER: "other"
        };
        function getDecimals(n) {
          n = n + '';
          var i = n.indexOf('.');
          return (i == -1) ? 0 : n.length - i - 1;
        }
        function getVF(n, opt_precision) {
          var v = opt_precision;
          if (undefined === v) {
            v = Math.min(getDecimals(n), 3);
          }
          var base = Math.pow(10, v);
          var f = ((n * base) | 0) % base;
          return {
            v: v,
            f: f
          };
        }
        $provide.value("$locale", {
          "DATETIME_FORMATS": {
            "AMPMS": ["AM", "PM"],
            "DAY": ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"],
            "ERANAMES": ["Before Christ", "Anno Domini"],
            "ERAS": ["BC", "AD"],
            "FIRSTDAYOFWEEK": 6,
            "MONTH": ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"],
            "SHORTDAY": ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
            "SHORTMONTH": ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"],
            "STANDALONEMONTH": ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"],
            "WEEKENDRANGE": [5, 6],
            "fullDate": "EEEE, MMMM d, y",
            "longDate": "MMMM d, y",
            "medium": "MMM d, y h:mm:ss a",
            "mediumDate": "MMM d, y",
            "mediumTime": "h:mm:ss a",
            "short": "M/d/yy h:mm a",
            "shortDate": "M/d/yy",
            "shortTime": "h:mm a"
          },
          "NUMBER_FORMATS": {
            "CURRENCY_SYM": "$",
            "DECIMAL_SEP": ".",
            "GROUP_SEP": ",",
            "PATTERNS": [{
              "gSize": 3,
              "lgSize": 3,
              "maxFrac": 3,
              "minFrac": 0,
              "minInt": 1,
              "negPre": "-",
              "negSuf": "",
              "posPre": "",
              "posSuf": ""
            }, {
              "gSize": 3,
              "lgSize": 3,
              "maxFrac": 2,
              "minFrac": 2,
              "minInt": 1,
              "negPre": "-\u00a4",
              "negSuf": "",
              "posPre": "\u00a4",
              "posSuf": ""
            }]
          },
          "id": "en-us",
          "localeID": "en_US",
          "pluralCat": function(n, opt_precision) {
            var i = n | 0;
            var vf = getVF(n, opt_precision);
            if (i == 1 && vf.v == 0) {
              return PLURAL_CATEGORY.ONE;
            }
            return PLURAL_CATEGORY.OTHER;
          }
        });
      }]);
      jqLite(window.document).ready(function() {
        angularInit(window.document, bootstrap);
      });
    })(window);
    !window.angular.$$csp().noInlineStyle && window.angular.element(document.head).prepend('<style type="text/css">@charset "UTF-8";[ng\\:cloak],[ng-cloak],[data-ng-cloak],[x-ng-cloak],.ng-cloak,.x-ng-cloak,.ng-hide:not(.ng-hide-animate){display:none !important;}ng\\:form{display:block;}.ng-animate-shim{visibility:hidden;}.ng-anchor{position:absolute;}</style>');
  })();
  return _retrieveGlobal();
});

System.registerDynamic("github:angular/bower-angular@1.5.7.js", ["github:angular/bower-angular@1.5.7/angular.js"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = $__require('github:angular/bower-angular@1.5.7/angular.js');
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:process@0.11.2/browser.js", [], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var process = module.exports = {};
  var queue = [];
  var draining = false;
  var currentQueue;
  var queueIndex = -1;
  function cleanUpNextTick() {
    draining = false;
    if (currentQueue.length) {
      queue = currentQueue.concat(queue);
    } else {
      queueIndex = -1;
    }
    if (queue.length) {
      drainQueue();
    }
  }
  function drainQueue() {
    if (draining) {
      return;
    }
    var timeout = setTimeout(cleanUpNextTick);
    draining = true;
    var len = queue.length;
    while (len) {
      currentQueue = queue;
      queue = [];
      while (++queueIndex < len) {
        if (currentQueue) {
          currentQueue[queueIndex].run();
        }
      }
      queueIndex = -1;
      len = queue.length;
    }
    currentQueue = null;
    draining = false;
    clearTimeout(timeout);
  }
  process.nextTick = function(fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
      for (var i = 1; i < arguments.length; i++) {
        args[i - 1] = arguments[i];
      }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
      setTimeout(drainQueue, 0);
    }
  };
  function Item(fun, array) {
    this.fun = fun;
    this.array = array;
  }
  Item.prototype.run = function() {
    this.fun.apply(null, this.array);
  };
  process.title = 'browser';
  process.browser = true;
  process.env = {};
  process.argv = [];
  process.version = '';
  process.versions = {};
  function noop() {}
  process.on = noop;
  process.addListener = noop;
  process.once = noop;
  process.off = noop;
  process.removeListener = noop;
  process.removeAllListeners = noop;
  process.emit = noop;
  process.binding = function(name) {
    throw new Error('process.binding is not supported');
  };
  process.cwd = function() {
    return '/';
  };
  process.chdir = function(dir) {
    throw new Error('process.chdir is not supported');
  };
  process.umask = function() {
    return 0;
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:process@0.11.2.js", ["npm:process@0.11.2/browser.js"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = $__require('npm:process@0.11.2/browser.js');
  global.define = __define;
  return module.exports;
});

System.registerDynamic("github:jspm/nodelibs-process@0.1.2/index.js", ["npm:process@0.11.2.js"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = System._nodeRequire ? process : $__require('npm:process@0.11.2.js');
  global.define = __define;
  return module.exports;
});

System.registerDynamic("github:jspm/nodelibs-process@0.1.2.js", ["github:jspm/nodelibs-process@0.1.2/index.js"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = $__require('github:jspm/nodelibs-process@0.1.2/index.js');
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:angular-ui-mask@1.8.1/dist/mask.js", ["github:jspm/nodelibs-process@0.1.2.js"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  (function(process) {
    (function() {
      'use strict';
      angular.module('ui.mask', []).value('uiMaskConfig', {
        maskDefinitions: {
          '9': /\d/,
          'A': /[a-zA-Z]/,
          '*': /[a-zA-Z0-9]/
        },
        clearOnBlur: true,
        clearOnBlurPlaceholder: false,
        eventsToHandle: ['input', 'keyup', 'click', 'focus']
      }).provider('uiMask.Config', function() {
        var options = {};
        this.clearOnBlur = function(clearOnBlur) {
          return options.clearOnBlur = clearOnBlur;
        };
        this.clearOnBlurPlaceholder = function(clearOnBlurPlaceholder) {
          return options.clearOnBlurPlaceholder = clearOnBlurPlaceholder;
        };
        this.eventsToHandle = function(eventsToHandle) {
          return options.eventsToHandle = eventsToHandle;
        };
        this.$get = ['uiMaskConfig', function(uiMaskConfig) {
          var tempOptions = uiMaskConfig;
          for (var prop in options) {
            tempOptions[prop] = options[prop];
          }
          return tempOptions;
        }];
      }).directive('uiMask', ['uiMask.Config', function(maskConfig) {
        function isFocused(elem) {
          return elem === document.activeElement && (!document.hasFocus || document.hasFocus()) && !!(elem.type || elem.href || ~elem.tabIndex);
        }
        return {
          priority: 100,
          require: 'ngModel',
          restrict: 'A',
          compile: function uiMaskCompilingFunction() {
            var options = maskConfig;
            return function uiMaskLinkingFunction(scope, iElement, iAttrs, controller) {
              var maskProcessed = false,
                  eventsBound = false,
                  maskCaretMap,
                  maskPatterns,
                  maskPlaceholder,
                  maskComponents,
                  minRequiredLength,
                  value,
                  valueMasked,
                  isValid,
                  originalPlaceholder = iAttrs.placeholder,
                  originalMaxlength = iAttrs.maxlength,
                  oldValue,
                  oldValueUnmasked,
                  oldCaretPosition,
                  oldSelectionLength,
                  preventBackspace;
              var originalIsEmpty = controller.$isEmpty;
              controller.$isEmpty = function(value) {
                if (maskProcessed) {
                  return originalIsEmpty(unmaskValue(value || ''));
                } else {
                  return originalIsEmpty(value);
                }
              };
              function initialize(maskAttr) {
                if (!angular.isDefined(maskAttr)) {
                  return uninitialize();
                }
                processRawMask(maskAttr);
                if (!maskProcessed) {
                  return uninitialize();
                }
                initializeElement();
                bindEventListeners();
                return true;
              }
              function initPlaceholder(placeholderAttr) {
                if (!placeholderAttr) {
                  return;
                }
                maskPlaceholder = placeholderAttr;
                if (maskProcessed && !(iElement.val().length === 0 && angular.isDefined(iAttrs.placeholder))) {
                  iElement.val(maskValue(unmaskValue(iElement.val())));
                }
              }
              function initPlaceholderChar() {
                return initialize(iAttrs.uiMask);
              }
              var modelViewValue = false;
              iAttrs.$observe('modelViewValue', function(val) {
                if (val === 'true') {
                  modelViewValue = true;
                }
              });
              function formatter(fromModelValue) {
                if (!maskProcessed) {
                  return fromModelValue;
                }
                value = unmaskValue(fromModelValue || '');
                isValid = validateValue(value);
                controller.$setValidity('mask', isValid);
                return isValid && value.length ? maskValue(value) : undefined;
              }
              function parser(fromViewValue) {
                if (!maskProcessed) {
                  return fromViewValue;
                }
                value = unmaskValue(fromViewValue || '');
                isValid = validateValue(value);
                controller.$viewValue = value.length ? maskValue(value) : '';
                controller.$setValidity('mask', isValid);
                if (isValid) {
                  return modelViewValue ? controller.$viewValue : value;
                } else {
                  return undefined;
                }
              }
              var linkOptions = {};
              if (iAttrs.uiOptions) {
                linkOptions = scope.$eval('[' + iAttrs.uiOptions + ']');
                if (angular.isObject(linkOptions[0])) {
                  linkOptions = (function(original, current) {
                    for (var i in original) {
                      if (Object.prototype.hasOwnProperty.call(original, i)) {
                        if (current[i] === undefined) {
                          current[i] = angular.copy(original[i]);
                        } else {
                          if (angular.isObject(current[i]) && !angular.isArray(current[i])) {
                            current[i] = angular.extend({}, original[i], current[i]);
                          }
                        }
                      }
                    }
                    return current;
                  })(options, linkOptions[0]);
                } else {
                  linkOptions = options;
                }
              } else {
                linkOptions = options;
              }
              iAttrs.$observe('uiMask', initialize);
              if (angular.isDefined(iAttrs.uiMaskPlaceholder)) {
                iAttrs.$observe('uiMaskPlaceholder', initPlaceholder);
              } else {
                iAttrs.$observe('placeholder', initPlaceholder);
              }
              if (angular.isDefined(iAttrs.uiMaskPlaceholderChar)) {
                iAttrs.$observe('uiMaskPlaceholderChar', initPlaceholderChar);
              }
              controller.$formatters.unshift(formatter);
              controller.$parsers.unshift(parser);
              function uninitialize() {
                maskProcessed = false;
                unbindEventListeners();
                if (angular.isDefined(originalPlaceholder)) {
                  iElement.attr('placeholder', originalPlaceholder);
                } else {
                  iElement.removeAttr('placeholder');
                }
                if (angular.isDefined(originalMaxlength)) {
                  iElement.attr('maxlength', originalMaxlength);
                } else {
                  iElement.removeAttr('maxlength');
                }
                iElement.val(controller.$modelValue);
                controller.$viewValue = controller.$modelValue;
                return false;
              }
              function initializeElement() {
                value = oldValueUnmasked = unmaskValue(controller.$modelValue || '');
                valueMasked = oldValue = maskValue(value);
                isValid = validateValue(value);
                if (iAttrs.maxlength) {
                  iElement.attr('maxlength', maskCaretMap[maskCaretMap.length - 1] * 2);
                }
                if (!originalPlaceholder) {
                  iElement.attr('placeholder', maskPlaceholder);
                }
                var viewValue = controller.$modelValue;
                var idx = controller.$formatters.length;
                while (idx--) {
                  viewValue = controller.$formatters[idx](viewValue);
                }
                controller.$viewValue = viewValue || '';
                controller.$render();
              }
              function bindEventListeners() {
                if (eventsBound) {
                  return;
                }
                iElement.bind('blur', blurHandler);
                iElement.bind('mousedown mouseup', mouseDownUpHandler);
                iElement.bind('keydown', keydownHandler);
                iElement.bind(linkOptions.eventsToHandle.join(' '), eventHandler);
                eventsBound = true;
              }
              function unbindEventListeners() {
                if (!eventsBound) {
                  return;
                }
                iElement.unbind('blur', blurHandler);
                iElement.unbind('mousedown', mouseDownUpHandler);
                iElement.unbind('mouseup', mouseDownUpHandler);
                iElement.unbind('keydown', keydownHandler);
                iElement.unbind('input', eventHandler);
                iElement.unbind('keyup', eventHandler);
                iElement.unbind('click', eventHandler);
                iElement.unbind('focus', eventHandler);
                eventsBound = false;
              }
              function validateValue(value) {
                return value.length ? value.length >= minRequiredLength : true;
              }
              function unmaskValue(value) {
                var valueUnmasked = '',
                    input = iElement[0],
                    maskPatternsCopy = maskPatterns.slice(),
                    selectionStart = oldCaretPosition,
                    selectionEnd = selectionStart + getSelectionLength(input),
                    valueOffset,
                    valueDelta,
                    tempValue = '';
                value = value.toString();
                valueOffset = 0;
                valueDelta = value.length - maskPlaceholder.length;
                angular.forEach(maskComponents, function(component) {
                  var position = component.position;
                  if (!(position >= selectionStart && position < selectionEnd)) {
                    if (position >= selectionStart) {
                      position += valueDelta;
                    }
                    if (value.substring(position, position + component.value.length) === component.value) {
                      tempValue += value.slice(valueOffset, position);
                      valueOffset = position + component.value.length;
                    }
                  }
                });
                value = tempValue + value.slice(valueOffset);
                angular.forEach(value.split(''), function(chr) {
                  if (maskPatternsCopy.length && maskPatternsCopy[0].test(chr)) {
                    valueUnmasked += chr;
                    maskPatternsCopy.shift();
                  }
                });
                return valueUnmasked;
              }
              function maskValue(unmaskedValue) {
                var valueMasked = '',
                    maskCaretMapCopy = maskCaretMap.slice();
                angular.forEach(maskPlaceholder.split(''), function(chr, i) {
                  if (unmaskedValue.length && i === maskCaretMapCopy[0]) {
                    valueMasked += unmaskedValue.charAt(0) || '_';
                    unmaskedValue = unmaskedValue.substr(1);
                    maskCaretMapCopy.shift();
                  } else {
                    valueMasked += chr;
                  }
                });
                return valueMasked;
              }
              function getPlaceholderChar(i) {
                var placeholder = angular.isDefined(iAttrs.uiMaskPlaceholder) ? iAttrs.uiMaskPlaceholder : iAttrs.placeholder,
                    defaultPlaceholderChar;
                if (angular.isDefined(placeholder) && placeholder[i]) {
                  return placeholder[i];
                } else {
                  defaultPlaceholderChar = angular.isDefined(iAttrs.uiMaskPlaceholderChar) && iAttrs.uiMaskPlaceholderChar ? iAttrs.uiMaskPlaceholderChar : '_';
                  return (defaultPlaceholderChar.toLowerCase() === 'space') ? ' ' : defaultPlaceholderChar[0];
                }
              }
              function getMaskComponents() {
                var maskPlaceholderChars = maskPlaceholder.split(''),
                    maskPlaceholderCopy,
                    components;
                if (maskCaretMap && !isNaN(maskCaretMap[0])) {
                  angular.forEach(maskCaretMap, function(value) {
                    maskPlaceholderChars[value] = '_';
                  });
                }
                maskPlaceholderCopy = maskPlaceholderChars.join('');
                components = maskPlaceholderCopy.replace(/[_]+/g, '_').split('_');
                components = components.filter(function(s) {
                  return s !== '';
                });
                var offset = 0;
                return components.map(function(c) {
                  var componentPosition = maskPlaceholderCopy.indexOf(c, offset);
                  offset = componentPosition + 1;
                  return {
                    value: c,
                    position: componentPosition
                  };
                });
              }
              function processRawMask(mask) {
                var characterCount = 0;
                maskCaretMap = [];
                maskPatterns = [];
                maskPlaceholder = '';
                if (angular.isString(mask)) {
                  minRequiredLength = 0;
                  var isOptional = false,
                      numberOfOptionalCharacters = 0,
                      splitMask = mask.split('');
                  angular.forEach(splitMask, function(chr, i) {
                    if (linkOptions.maskDefinitions[chr]) {
                      maskCaretMap.push(characterCount);
                      maskPlaceholder += getPlaceholderChar(i - numberOfOptionalCharacters);
                      maskPatterns.push(linkOptions.maskDefinitions[chr]);
                      characterCount++;
                      if (!isOptional) {
                        minRequiredLength++;
                      }
                      isOptional = false;
                    } else if (chr === '?') {
                      isOptional = true;
                      numberOfOptionalCharacters++;
                    } else {
                      maskPlaceholder += chr;
                      characterCount++;
                    }
                  });
                }
                maskCaretMap.push(maskCaretMap.slice().pop() + 1);
                maskComponents = getMaskComponents();
                maskProcessed = maskCaretMap.length > 1 ? true : false;
              }
              var prevValue = iElement.val();
              function blurHandler() {
                if (linkOptions.clearOnBlur || ((linkOptions.clearOnBlurPlaceholder) && (value.length === 0) && iAttrs.placeholder)) {
                  oldCaretPosition = 0;
                  oldSelectionLength = 0;
                  if (!isValid || value.length === 0) {
                    valueMasked = '';
                    iElement.val('');
                    scope.$apply(function() {
                      controller.$viewValue = '';
                    });
                  }
                }
                if (value !== prevValue) {
                  triggerChangeEvent(iElement[0]);
                }
                prevValue = value;
              }
              function triggerChangeEvent(element) {
                var change;
                if (angular.isFunction(window.Event) && !element.fireEvent) {
                  change = new Event('change', {
                    view: window,
                    bubbles: true,
                    cancelable: false
                  });
                  element.dispatchEvent(change);
                } else if ('createEvent' in document) {
                  change = document.createEvent('HTMLEvents');
                  change.initEvent('change', false, true);
                  element.dispatchEvent(change);
                } else if (element.fireEvent) {
                  element.fireEvent('onchange');
                }
              }
              function mouseDownUpHandler(e) {
                if (e.type === 'mousedown') {
                  iElement.bind('mouseout', mouseoutHandler);
                } else {
                  iElement.unbind('mouseout', mouseoutHandler);
                }
              }
              iElement.bind('mousedown mouseup', mouseDownUpHandler);
              function mouseoutHandler() {
                oldSelectionLength = getSelectionLength(this);
                iElement.unbind('mouseout', mouseoutHandler);
              }
              function keydownHandler(e) {
                var isKeyBackspace = e.which === 8,
                    caretPos = getCaretPosition(this) - 1 || 0;
                if (isKeyBackspace) {
                  while (caretPos >= 0) {
                    if (isValidCaretPosition(caretPos)) {
                      setCaretPosition(this, caretPos + 1);
                      break;
                    }
                    caretPos--;
                  }
                  preventBackspace = caretPos === -1;
                }
              }
              function eventHandler(e) {
                e = e || {};
                var eventWhich = e.which,
                    eventType = e.type;
                if (eventWhich === 16 || eventWhich === 91) {
                  return;
                }
                var val = iElement.val(),
                    valOld = oldValue,
                    valMasked,
                    valAltered = false,
                    valUnmasked = unmaskValue(val),
                    valUnmaskedOld = oldValueUnmasked,
                    caretPos = getCaretPosition(this) || 0,
                    caretPosOld = oldCaretPosition || 0,
                    caretPosDelta = caretPos - caretPosOld,
                    caretPosMin = maskCaretMap[0],
                    caretPosMax = maskCaretMap[valUnmasked.length] || maskCaretMap.slice().shift(),
                    selectionLenOld = oldSelectionLength || 0,
                    isSelected = getSelectionLength(this) > 0,
                    wasSelected = selectionLenOld > 0,
                    isAddition = (val.length > valOld.length) || (selectionLenOld && val.length > valOld.length - selectionLenOld),
                    isDeletion = (val.length < valOld.length) || (selectionLenOld && val.length === valOld.length - selectionLenOld),
                    isSelection = (eventWhich >= 37 && eventWhich <= 40) && e.shiftKey,
                    isKeyLeftArrow = eventWhich === 37,
                    isKeyBackspace = eventWhich === 8 || (eventType !== 'keyup' && isDeletion && (caretPosDelta === -1)),
                    isKeyDelete = eventWhich === 46 || (eventType !== 'keyup' && isDeletion && (caretPosDelta === 0) && !wasSelected),
                    caretBumpBack = (isKeyLeftArrow || isKeyBackspace || eventType === 'click') && caretPos > caretPosMin;
                oldSelectionLength = getSelectionLength(this);
                if (isSelection || (isSelected && (eventType === 'click' || eventType === 'keyup' || eventType === 'focus'))) {
                  return;
                }
                if (isKeyBackspace && preventBackspace) {
                  iElement.val(maskPlaceholder);
                  scope.$apply(function() {
                    controller.$setViewValue('');
                  });
                  setCaretPosition(this, caretPosOld);
                  return;
                }
                if ((eventType === 'input') && isDeletion && !wasSelected && valUnmasked === valUnmaskedOld) {
                  while (isKeyBackspace && caretPos > caretPosMin && !isValidCaretPosition(caretPos)) {
                    caretPos--;
                  }
                  while (isKeyDelete && caretPos < caretPosMax && maskCaretMap.indexOf(caretPos) === -1) {
                    caretPos++;
                  }
                  var charIndex = maskCaretMap.indexOf(caretPos);
                  valUnmasked = valUnmasked.substring(0, charIndex) + valUnmasked.substring(charIndex + 1);
                  if (valUnmasked !== valUnmaskedOld)
                    valAltered = true;
                }
                valMasked = maskValue(valUnmasked);
                oldValue = valMasked;
                oldValueUnmasked = valUnmasked;
                if (!valAltered && val.length > valMasked.length)
                  valAltered = true;
                iElement.val(valMasked);
                if (valAltered) {
                  scope.$apply(function() {
                    controller.$setViewValue(valMasked);
                  });
                }
                if (isAddition && (caretPos <= caretPosMin)) {
                  caretPos = caretPosMin + 1;
                }
                if (caretBumpBack) {
                  caretPos--;
                }
                caretPos = caretPos > caretPosMax ? caretPosMax : caretPos < caretPosMin ? caretPosMin : caretPos;
                while (!isValidCaretPosition(caretPos) && caretPos > caretPosMin && caretPos < caretPosMax) {
                  caretPos += caretBumpBack ? -1 : 1;
                }
                if ((caretBumpBack && caretPos < caretPosMax) || (isAddition && !isValidCaretPosition(caretPosOld))) {
                  caretPos++;
                }
                oldCaretPosition = caretPos;
                setCaretPosition(this, caretPos);
              }
              function isValidCaretPosition(pos) {
                return maskCaretMap.indexOf(pos) > -1;
              }
              function getCaretPosition(input) {
                if (!input)
                  return 0;
                if (input.selectionStart !== undefined) {
                  return input.selectionStart;
                } else if (document.selection) {
                  if (isFocused(iElement[0])) {
                    input.focus();
                    var selection = document.selection.createRange();
                    selection.moveStart('character', input.value ? -input.value.length : 0);
                    return selection.text.length;
                  }
                }
                return 0;
              }
              function setCaretPosition(input, pos) {
                if (!input)
                  return 0;
                if (input.offsetWidth === 0 || input.offsetHeight === 0) {
                  return;
                }
                if (input.setSelectionRange) {
                  if (isFocused(iElement[0])) {
                    input.focus();
                    input.setSelectionRange(pos, pos);
                  }
                } else if (input.createTextRange) {
                  var range = input.createTextRange();
                  range.collapse(true);
                  range.moveEnd('character', pos);
                  range.moveStart('character', pos);
                  range.select();
                }
              }
              function getSelectionLength(input) {
                if (!input)
                  return 0;
                if (input.selectionStart !== undefined) {
                  return (input.selectionEnd - input.selectionStart);
                }
                if (document.selection) {
                  return (document.selection.createRange().text.length);
                }
                return 0;
              }
              if (!Array.prototype.indexOf) {
                Array.prototype.indexOf = function(searchElement) {
                  if (this === null) {
                    throw new TypeError();
                  }
                  var t = Object(this);
                  var len = t.length >>> 0;
                  if (len === 0) {
                    return -1;
                  }
                  var n = 0;
                  if (arguments.length > 1) {
                    n = Number(arguments[1]);
                    if (n !== n) {
                      n = 0;
                    } else if (n !== 0 && n !== Infinity && n !== -Infinity) {
                      n = (n > 0 || -1) * Math.floor(Math.abs(n));
                    }
                  }
                  if (n >= len) {
                    return -1;
                  }
                  var k = n >= 0 ? n : Math.max(len - Math.abs(n), 0);
                  for (; k < len; k++) {
                    if (k in t && t[k] === searchElement) {
                      return k;
                    }
                  }
                  return -1;
                };
              }
            };
          }
        };
      }]);
    }());
  })($__require('github:jspm/nodelibs-process@0.1.2.js'));
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:angular-ui-mask@1.8.1/index.js", ["github:angular/bower-angular@1.5.7.js", "npm:angular-ui-mask@1.8.1/dist/mask.js"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var angular = $__require('github:angular/bower-angular@1.5.7.js');
  var mask = $__require('npm:angular-ui-mask@1.8.1/dist/mask.js');
  module.exports = 'ui.mask';
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:angular-ui-mask@1.8.1.js", ["npm:angular-ui-mask@1.8.1/index.js"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = $__require('npm:angular-ui-mask@1.8.1/index.js');
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.6/library/modules/$.to-object.js", ["npm:core-js@1.2.6/library/modules/$.defined.js"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var defined = $__require('npm:core-js@1.2.6/library/modules/$.defined.js');
  module.exports = function(it) {
    return Object(defined(it));
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.6/library/modules/$.object-assign.js", ["npm:core-js@1.2.6/library/modules/$.js", "npm:core-js@1.2.6/library/modules/$.to-object.js", "npm:core-js@1.2.6/library/modules/$.iobject.js", "npm:core-js@1.2.6/library/modules/$.fails.js"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var $ = $__require('npm:core-js@1.2.6/library/modules/$.js'),
      toObject = $__require('npm:core-js@1.2.6/library/modules/$.to-object.js'),
      IObject = $__require('npm:core-js@1.2.6/library/modules/$.iobject.js');
  module.exports = $__require('npm:core-js@1.2.6/library/modules/$.fails.js')(function() {
    var a = Object.assign,
        A = {},
        B = {},
        S = Symbol(),
        K = 'abcdefghijklmnopqrst';
    A[S] = 7;
    K.split('').forEach(function(k) {
      B[k] = k;
    });
    return a({}, A)[S] != 7 || Object.keys(a({}, B)).join('') != K;
  }) ? function assign(target, source) {
    var T = toObject(target),
        $$ = arguments,
        $$len = $$.length,
        index = 1,
        getKeys = $.getKeys,
        getSymbols = $.getSymbols,
        isEnum = $.isEnum;
    while ($$len > index) {
      var S = IObject($$[index++]),
          keys = getSymbols ? getKeys(S).concat(getSymbols(S)) : getKeys(S),
          length = keys.length,
          j = 0,
          key;
      while (length > j)
        if (isEnum.call(S, key = keys[j++]))
          T[key] = S[key];
    }
    return T;
  } : Object.assign;
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.6/library/modules/es6.object.assign.js", ["npm:core-js@1.2.6/library/modules/$.export.js", "npm:core-js@1.2.6/library/modules/$.object-assign.js"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var $export = $__require('npm:core-js@1.2.6/library/modules/$.export.js');
  $export($export.S + $export.F, 'Object', {assign: $__require('npm:core-js@1.2.6/library/modules/$.object-assign.js')});
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.6/library/fn/object/assign.js", ["npm:core-js@1.2.6/library/modules/es6.object.assign.js", "npm:core-js@1.2.6/library/modules/$.core.js"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  $__require('npm:core-js@1.2.6/library/modules/es6.object.assign.js');
  module.exports = $__require('npm:core-js@1.2.6/library/modules/$.core.js').Object.assign;
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:babel-runtime@5.8.35/core-js/object/assign.js", ["npm:core-js@1.2.6/library/fn/object/assign.js"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = {
    "default": $__require('npm:core-js@1.2.6/library/fn/object/assign.js'),
    __esModule: true
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:babel-runtime@5.8.35/helpers/class-call-check.js", [], true, function($__require, exports, module) {
  "use strict";
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  exports["default"] = function(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  };
  exports.__esModule = true;
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.6/library/fn/object/define-property.js", ["npm:core-js@1.2.6/library/modules/$.js"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var $ = $__require('npm:core-js@1.2.6/library/modules/$.js');
  module.exports = function defineProperty(it, key, desc) {
    return $.setDesc(it, key, desc);
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:babel-runtime@5.8.35/core-js/object/define-property.js", ["npm:core-js@1.2.6/library/fn/object/define-property.js"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = {
    "default": $__require('npm:core-js@1.2.6/library/fn/object/define-property.js'),
    __esModule: true
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:babel-runtime@5.8.35/helpers/create-class.js", ["npm:babel-runtime@5.8.35/core-js/object/define-property.js"], true, function($__require, exports, module) {
  "use strict";
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var _Object$defineProperty = $__require('npm:babel-runtime@5.8.35/core-js/object/define-property.js')["default"];
  exports["default"] = (function() {
    function defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor)
          descriptor.writable = true;
        _Object$defineProperty(target, descriptor.key, descriptor);
      }
    }
    return function(Constructor, protoProps, staticProps) {
      if (protoProps)
        defineProperties(Constructor.prototype, protoProps);
      if (staticProps)
        defineProperties(Constructor, staticProps);
      return Constructor;
    };
  })();
  exports.__esModule = true;
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.6/library/modules/$.cof.js", [], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var toString = {}.toString;
  module.exports = function(it) {
    return toString.call(it).slice(8, -1);
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.6/library/modules/$.iobject.js", ["npm:core-js@1.2.6/library/modules/$.cof.js"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var cof = $__require('npm:core-js@1.2.6/library/modules/$.cof.js');
  module.exports = Object('z').propertyIsEnumerable(0) ? Object : function(it) {
    return cof(it) == 'String' ? it.split('') : Object(it);
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.6/library/modules/$.defined.js", [], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = function(it) {
    if (it == undefined)
      throw TypeError("Can't call method on  " + it);
    return it;
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.6/library/modules/$.to-iobject.js", ["npm:core-js@1.2.6/library/modules/$.iobject.js", "npm:core-js@1.2.6/library/modules/$.defined.js"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var IObject = $__require('npm:core-js@1.2.6/library/modules/$.iobject.js'),
      defined = $__require('npm:core-js@1.2.6/library/modules/$.defined.js');
  module.exports = function(it) {
    return IObject(defined(it));
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.6/library/modules/$.fails.js", [], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = function(exec) {
    try {
      return !!exec();
    } catch (e) {
      return true;
    }
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.6/library/modules/$.object-sap.js", ["npm:core-js@1.2.6/library/modules/$.export.js", "npm:core-js@1.2.6/library/modules/$.core.js", "npm:core-js@1.2.6/library/modules/$.fails.js"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var $export = $__require('npm:core-js@1.2.6/library/modules/$.export.js'),
      core = $__require('npm:core-js@1.2.6/library/modules/$.core.js'),
      fails = $__require('npm:core-js@1.2.6/library/modules/$.fails.js');
  module.exports = function(KEY, exec) {
    var fn = (core.Object || {})[KEY] || Object[KEY],
        exp = {};
    exp[KEY] = exec(fn);
    $export($export.S + $export.F * fails(function() {
      fn(1);
    }), 'Object', exp);
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.6/library/modules/es6.object.get-own-property-descriptor.js", ["npm:core-js@1.2.6/library/modules/$.to-iobject.js", "npm:core-js@1.2.6/library/modules/$.object-sap.js"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var toIObject = $__require('npm:core-js@1.2.6/library/modules/$.to-iobject.js');
  $__require('npm:core-js@1.2.6/library/modules/$.object-sap.js')('getOwnPropertyDescriptor', function($getOwnPropertyDescriptor) {
    return function getOwnPropertyDescriptor(it, key) {
      return $getOwnPropertyDescriptor(toIObject(it), key);
    };
  });
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.6/library/fn/object/get-own-property-descriptor.js", ["npm:core-js@1.2.6/library/modules/$.js", "npm:core-js@1.2.6/library/modules/es6.object.get-own-property-descriptor.js"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var $ = $__require('npm:core-js@1.2.6/library/modules/$.js');
  $__require('npm:core-js@1.2.6/library/modules/es6.object.get-own-property-descriptor.js');
  module.exports = function getOwnPropertyDescriptor(it, key) {
    return $.getDesc(it, key);
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:babel-runtime@5.8.35/core-js/object/get-own-property-descriptor.js", ["npm:core-js@1.2.6/library/fn/object/get-own-property-descriptor.js"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = {
    "default": $__require('npm:core-js@1.2.6/library/fn/object/get-own-property-descriptor.js'),
    __esModule: true
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:babel-runtime@5.8.35/helpers/get.js", ["npm:babel-runtime@5.8.35/core-js/object/get-own-property-descriptor.js"], true, function($__require, exports, module) {
  "use strict";
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var _Object$getOwnPropertyDescriptor = $__require('npm:babel-runtime@5.8.35/core-js/object/get-own-property-descriptor.js')["default"];
  exports["default"] = function get(_x, _x2, _x3) {
    var _again = true;
    _function: while (_again) {
      var object = _x,
          property = _x2,
          receiver = _x3;
      _again = false;
      if (object === null)
        object = Function.prototype;
      var desc = _Object$getOwnPropertyDescriptor(object, property);
      if (desc === undefined) {
        var parent = Object.getPrototypeOf(object);
        if (parent === null) {
          return undefined;
        } else {
          _x = parent;
          _x2 = property;
          _x3 = receiver;
          _again = true;
          desc = parent = undefined;
          continue _function;
        }
      } else if ("value" in desc) {
        return desc.value;
      } else {
        var getter = desc.get;
        if (getter === undefined) {
          return undefined;
        }
        return getter.call(receiver);
      }
    }
  };
  exports.__esModule = true;
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.6/library/fn/object/create.js", ["npm:core-js@1.2.6/library/modules/$.js"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var $ = $__require('npm:core-js@1.2.6/library/modules/$.js');
  module.exports = function create(P, D) {
    return $.create(P, D);
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:babel-runtime@5.8.35/core-js/object/create.js", ["npm:core-js@1.2.6/library/fn/object/create.js"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = {
    "default": $__require('npm:core-js@1.2.6/library/fn/object/create.js'),
    __esModule: true
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.6/library/modules/$.global.js", [], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var global = module.exports = typeof window != 'undefined' && window.Math == Math ? window : typeof self != 'undefined' && self.Math == Math ? self : Function('return this')();
  if (typeof __g == 'number')
    __g = global;
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.6/library/modules/$.export.js", ["npm:core-js@1.2.6/library/modules/$.global.js", "npm:core-js@1.2.6/library/modules/$.core.js", "npm:core-js@1.2.6/library/modules/$.ctx.js"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var global = $__require('npm:core-js@1.2.6/library/modules/$.global.js'),
      core = $__require('npm:core-js@1.2.6/library/modules/$.core.js'),
      ctx = $__require('npm:core-js@1.2.6/library/modules/$.ctx.js'),
      PROTOTYPE = 'prototype';
  var $export = function(type, name, source) {
    var IS_FORCED = type & $export.F,
        IS_GLOBAL = type & $export.G,
        IS_STATIC = type & $export.S,
        IS_PROTO = type & $export.P,
        IS_BIND = type & $export.B,
        IS_WRAP = type & $export.W,
        exports = IS_GLOBAL ? core : core[name] || (core[name] = {}),
        target = IS_GLOBAL ? global : IS_STATIC ? global[name] : (global[name] || {})[PROTOTYPE],
        key,
        own,
        out;
    if (IS_GLOBAL)
      source = name;
    for (key in source) {
      own = !IS_FORCED && target && key in target;
      if (own && key in exports)
        continue;
      out = own ? target[key] : source[key];
      exports[key] = IS_GLOBAL && typeof target[key] != 'function' ? source[key] : IS_BIND && own ? ctx(out, global) : IS_WRAP && target[key] == out ? (function(C) {
        var F = function(param) {
          return this instanceof C ? new C(param) : C(param);
        };
        F[PROTOTYPE] = C[PROTOTYPE];
        return F;
      })(out) : IS_PROTO && typeof out == 'function' ? ctx(Function.call, out) : out;
      if (IS_PROTO)
        (exports[PROTOTYPE] || (exports[PROTOTYPE] = {}))[key] = out;
    }
  };
  $export.F = 1;
  $export.G = 2;
  $export.S = 4;
  $export.P = 8;
  $export.B = 16;
  $export.W = 32;
  module.exports = $export;
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.6/library/modules/$.js", [], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var $Object = Object;
  module.exports = {
    create: $Object.create,
    getProto: $Object.getPrototypeOf,
    isEnum: {}.propertyIsEnumerable,
    getDesc: $Object.getOwnPropertyDescriptor,
    setDesc: $Object.defineProperty,
    setDescs: $Object.defineProperties,
    getKeys: $Object.keys,
    getNames: $Object.getOwnPropertyNames,
    getSymbols: $Object.getOwnPropertySymbols,
    each: [].forEach
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.6/library/modules/$.is-object.js", [], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = function(it) {
    return typeof it === 'object' ? it !== null : typeof it === 'function';
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.6/library/modules/$.an-object.js", ["npm:core-js@1.2.6/library/modules/$.is-object.js"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var isObject = $__require('npm:core-js@1.2.6/library/modules/$.is-object.js');
  module.exports = function(it) {
    if (!isObject(it))
      throw TypeError(it + ' is not an object!');
    return it;
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.6/library/modules/$.a-function.js", [], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = function(it) {
    if (typeof it != 'function')
      throw TypeError(it + ' is not a function!');
    return it;
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.6/library/modules/$.ctx.js", ["npm:core-js@1.2.6/library/modules/$.a-function.js"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var aFunction = $__require('npm:core-js@1.2.6/library/modules/$.a-function.js');
  module.exports = function(fn, that, length) {
    aFunction(fn);
    if (that === undefined)
      return fn;
    switch (length) {
      case 1:
        return function(a) {
          return fn.call(that, a);
        };
      case 2:
        return function(a, b) {
          return fn.call(that, a, b);
        };
      case 3:
        return function(a, b, c) {
          return fn.call(that, a, b, c);
        };
    }
    return function() {
      return fn.apply(that, arguments);
    };
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.6/library/modules/$.set-proto.js", ["npm:core-js@1.2.6/library/modules/$.js", "npm:core-js@1.2.6/library/modules/$.is-object.js", "npm:core-js@1.2.6/library/modules/$.an-object.js", "npm:core-js@1.2.6/library/modules/$.ctx.js"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var getDesc = $__require('npm:core-js@1.2.6/library/modules/$.js').getDesc,
      isObject = $__require('npm:core-js@1.2.6/library/modules/$.is-object.js'),
      anObject = $__require('npm:core-js@1.2.6/library/modules/$.an-object.js');
  var check = function(O, proto) {
    anObject(O);
    if (!isObject(proto) && proto !== null)
      throw TypeError(proto + ": can't set as prototype!");
  };
  module.exports = {
    set: Object.setPrototypeOf || ('__proto__' in {} ? function(test, buggy, set) {
      try {
        set = $__require('npm:core-js@1.2.6/library/modules/$.ctx.js')(Function.call, getDesc(Object.prototype, '__proto__').set, 2);
        set(test, []);
        buggy = !(test instanceof Array);
      } catch (e) {
        buggy = true;
      }
      return function setPrototypeOf(O, proto) {
        check(O, proto);
        if (buggy)
          O.__proto__ = proto;
        else
          set(O, proto);
        return O;
      };
    }({}, false) : undefined),
    check: check
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.6/library/modules/es6.object.set-prototype-of.js", ["npm:core-js@1.2.6/library/modules/$.export.js", "npm:core-js@1.2.6/library/modules/$.set-proto.js"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var $export = $__require('npm:core-js@1.2.6/library/modules/$.export.js');
  $export($export.S, 'Object', {setPrototypeOf: $__require('npm:core-js@1.2.6/library/modules/$.set-proto.js').set});
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.6/library/modules/$.core.js", [], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var core = module.exports = {version: '1.2.6'};
  if (typeof __e == 'number')
    __e = core;
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.6/library/fn/object/set-prototype-of.js", ["npm:core-js@1.2.6/library/modules/es6.object.set-prototype-of.js", "npm:core-js@1.2.6/library/modules/$.core.js"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  $__require('npm:core-js@1.2.6/library/modules/es6.object.set-prototype-of.js');
  module.exports = $__require('npm:core-js@1.2.6/library/modules/$.core.js').Object.setPrototypeOf;
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:babel-runtime@5.8.35/core-js/object/set-prototype-of.js", ["npm:core-js@1.2.6/library/fn/object/set-prototype-of.js"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = {
    "default": $__require('npm:core-js@1.2.6/library/fn/object/set-prototype-of.js'),
    __esModule: true
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:babel-runtime@5.8.35/helpers/inherits.js", ["npm:babel-runtime@5.8.35/core-js/object/create.js", "npm:babel-runtime@5.8.35/core-js/object/set-prototype-of.js"], true, function($__require, exports, module) {
  "use strict";
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var _Object$create = $__require('npm:babel-runtime@5.8.35/core-js/object/create.js')["default"];
  var _Object$setPrototypeOf = $__require('npm:babel-runtime@5.8.35/core-js/object/set-prototype-of.js')["default"];
  exports["default"] = function(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
      throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
    }
    subClass.prototype = _Object$create(superClass && superClass.prototype, {constructor: {
        value: subClass,
        enumerable: false,
        writable: true,
        configurable: true
      }});
    if (superClass)
      _Object$setPrototypeOf ? _Object$setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
  };
  exports.__esModule = true;
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:fastclick@1.0.6/lib/fastclick.js", [], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  "format cjs";
  ;
  (function() {
    'use strict';
    function FastClick(layer, options) {
      var oldOnClick;
      options = options || {};
      this.trackingClick = false;
      this.trackingClickStart = 0;
      this.targetElement = null;
      this.touchStartX = 0;
      this.touchStartY = 0;
      this.lastTouchIdentifier = 0;
      this.touchBoundary = options.touchBoundary || 10;
      this.layer = layer;
      this.tapDelay = options.tapDelay || 200;
      this.tapTimeout = options.tapTimeout || 700;
      if (FastClick.notNeeded(layer)) {
        return;
      }
      function bind(method, context) {
        return function() {
          return method.apply(context, arguments);
        };
      }
      var methods = ['onMouse', 'onClick', 'onTouchStart', 'onTouchMove', 'onTouchEnd', 'onTouchCancel'];
      var context = this;
      for (var i = 0,
          l = methods.length; i < l; i++) {
        context[methods[i]] = bind(context[methods[i]], context);
      }
      if (deviceIsAndroid) {
        layer.addEventListener('mouseover', this.onMouse, true);
        layer.addEventListener('mousedown', this.onMouse, true);
        layer.addEventListener('mouseup', this.onMouse, true);
      }
      layer.addEventListener('click', this.onClick, true);
      layer.addEventListener('touchstart', this.onTouchStart, false);
      layer.addEventListener('touchmove', this.onTouchMove, false);
      layer.addEventListener('touchend', this.onTouchEnd, false);
      layer.addEventListener('touchcancel', this.onTouchCancel, false);
      if (!Event.prototype.stopImmediatePropagation) {
        layer.removeEventListener = function(type, callback, capture) {
          var rmv = Node.prototype.removeEventListener;
          if (type === 'click') {
            rmv.call(layer, type, callback.hijacked || callback, capture);
          } else {
            rmv.call(layer, type, callback, capture);
          }
        };
        layer.addEventListener = function(type, callback, capture) {
          var adv = Node.prototype.addEventListener;
          if (type === 'click') {
            adv.call(layer, type, callback.hijacked || (callback.hijacked = function(event) {
              if (!event.propagationStopped) {
                callback(event);
              }
            }), capture);
          } else {
            adv.call(layer, type, callback, capture);
          }
        };
      }
      if (typeof layer.onclick === 'function') {
        oldOnClick = layer.onclick;
        layer.addEventListener('click', function(event) {
          oldOnClick(event);
        }, false);
        layer.onclick = null;
      }
    }
    var deviceIsWindowsPhone = navigator.userAgent.indexOf("Windows Phone") >= 0;
    var deviceIsAndroid = navigator.userAgent.indexOf('Android') > 0 && !deviceIsWindowsPhone;
    var deviceIsIOS = /iP(ad|hone|od)/.test(navigator.userAgent) && !deviceIsWindowsPhone;
    var deviceIsIOS4 = deviceIsIOS && (/OS 4_\d(_\d)?/).test(navigator.userAgent);
    var deviceIsIOSWithBadTarget = deviceIsIOS && (/OS [6-7]_\d/).test(navigator.userAgent);
    var deviceIsBlackBerry10 = navigator.userAgent.indexOf('BB10') > 0;
    FastClick.prototype.needsClick = function(target) {
      switch (target.nodeName.toLowerCase()) {
        case 'button':
        case 'select':
        case 'textarea':
          if (target.disabled) {
            return true;
          }
          break;
        case 'input':
          if ((deviceIsIOS && target.type === 'file') || target.disabled) {
            return true;
          }
          break;
        case 'label':
        case 'iframe':
        case 'video':
          return true;
      }
      return (/\bneedsclick\b/).test(target.className);
    };
    FastClick.prototype.needsFocus = function(target) {
      switch (target.nodeName.toLowerCase()) {
        case 'textarea':
          return true;
        case 'select':
          return !deviceIsAndroid;
        case 'input':
          switch (target.type) {
            case 'button':
            case 'checkbox':
            case 'file':
            case 'image':
            case 'radio':
            case 'submit':
              return false;
          }
          return !target.disabled && !target.readOnly;
        default:
          return (/\bneedsfocus\b/).test(target.className);
      }
    };
    FastClick.prototype.sendClick = function(targetElement, event) {
      var clickEvent,
          touch;
      if (document.activeElement && document.activeElement !== targetElement) {
        document.activeElement.blur();
      }
      touch = event.changedTouches[0];
      clickEvent = document.createEvent('MouseEvents');
      clickEvent.initMouseEvent(this.determineEventType(targetElement), true, true, window, 1, touch.screenX, touch.screenY, touch.clientX, touch.clientY, false, false, false, false, 0, null);
      clickEvent.forwardedTouchEvent = true;
      targetElement.dispatchEvent(clickEvent);
    };
    FastClick.prototype.determineEventType = function(targetElement) {
      if (deviceIsAndroid && targetElement.tagName.toLowerCase() === 'select') {
        return 'mousedown';
      }
      return 'click';
    };
    FastClick.prototype.focus = function(targetElement) {
      var length;
      if (deviceIsIOS && targetElement.setSelectionRange && targetElement.type.indexOf('date') !== 0 && targetElement.type !== 'time' && targetElement.type !== 'month') {
        length = targetElement.value.length;
        targetElement.setSelectionRange(length, length);
      } else {
        targetElement.focus();
      }
    };
    FastClick.prototype.updateScrollParent = function(targetElement) {
      var scrollParent,
          parentElement;
      scrollParent = targetElement.fastClickScrollParent;
      if (!scrollParent || !scrollParent.contains(targetElement)) {
        parentElement = targetElement;
        do {
          if (parentElement.scrollHeight > parentElement.offsetHeight) {
            scrollParent = parentElement;
            targetElement.fastClickScrollParent = parentElement;
            break;
          }
          parentElement = parentElement.parentElement;
        } while (parentElement);
      }
      if (scrollParent) {
        scrollParent.fastClickLastScrollTop = scrollParent.scrollTop;
      }
    };
    FastClick.prototype.getTargetElementFromEventTarget = function(eventTarget) {
      if (eventTarget.nodeType === Node.TEXT_NODE) {
        return eventTarget.parentNode;
      }
      return eventTarget;
    };
    FastClick.prototype.onTouchStart = function(event) {
      var targetElement,
          touch,
          selection;
      if (event.targetTouches.length > 1) {
        return true;
      }
      targetElement = this.getTargetElementFromEventTarget(event.target);
      touch = event.targetTouches[0];
      if (deviceIsIOS) {
        selection = window.getSelection();
        if (selection.rangeCount && !selection.isCollapsed) {
          return true;
        }
        if (!deviceIsIOS4) {
          if (touch.identifier && touch.identifier === this.lastTouchIdentifier) {
            event.preventDefault();
            return false;
          }
          this.lastTouchIdentifier = touch.identifier;
          this.updateScrollParent(targetElement);
        }
      }
      this.trackingClick = true;
      this.trackingClickStart = event.timeStamp;
      this.targetElement = targetElement;
      this.touchStartX = touch.pageX;
      this.touchStartY = touch.pageY;
      if ((event.timeStamp - this.lastClickTime) < this.tapDelay) {
        event.preventDefault();
      }
      return true;
    };
    FastClick.prototype.touchHasMoved = function(event) {
      var touch = event.changedTouches[0],
          boundary = this.touchBoundary;
      if (Math.abs(touch.pageX - this.touchStartX) > boundary || Math.abs(touch.pageY - this.touchStartY) > boundary) {
        return true;
      }
      return false;
    };
    FastClick.prototype.onTouchMove = function(event) {
      if (!this.trackingClick) {
        return true;
      }
      if (this.targetElement !== this.getTargetElementFromEventTarget(event.target) || this.touchHasMoved(event)) {
        this.trackingClick = false;
        this.targetElement = null;
      }
      return true;
    };
    FastClick.prototype.findControl = function(labelElement) {
      if (labelElement.control !== undefined) {
        return labelElement.control;
      }
      if (labelElement.htmlFor) {
        return document.getElementById(labelElement.htmlFor);
      }
      return labelElement.querySelector('button, input:not([type=hidden]), keygen, meter, output, progress, select, textarea');
    };
    FastClick.prototype.onTouchEnd = function(event) {
      var forElement,
          trackingClickStart,
          targetTagName,
          scrollParent,
          touch,
          targetElement = this.targetElement;
      if (!this.trackingClick) {
        return true;
      }
      if ((event.timeStamp - this.lastClickTime) < this.tapDelay) {
        this.cancelNextClick = true;
        return true;
      }
      if ((event.timeStamp - this.trackingClickStart) > this.tapTimeout) {
        return true;
      }
      this.cancelNextClick = false;
      this.lastClickTime = event.timeStamp;
      trackingClickStart = this.trackingClickStart;
      this.trackingClick = false;
      this.trackingClickStart = 0;
      if (deviceIsIOSWithBadTarget) {
        touch = event.changedTouches[0];
        targetElement = document.elementFromPoint(touch.pageX - window.pageXOffset, touch.pageY - window.pageYOffset) || targetElement;
        targetElement.fastClickScrollParent = this.targetElement.fastClickScrollParent;
      }
      targetTagName = targetElement.tagName.toLowerCase();
      if (targetTagName === 'label') {
        forElement = this.findControl(targetElement);
        if (forElement) {
          this.focus(targetElement);
          if (deviceIsAndroid) {
            return false;
          }
          targetElement = forElement;
        }
      } else if (this.needsFocus(targetElement)) {
        if ((event.timeStamp - trackingClickStart) > 100 || (deviceIsIOS && window.top !== window && targetTagName === 'input')) {
          this.targetElement = null;
          return false;
        }
        this.focus(targetElement);
        this.sendClick(targetElement, event);
        if (!deviceIsIOS || targetTagName !== 'select') {
          this.targetElement = null;
          event.preventDefault();
        }
        return false;
      }
      if (deviceIsIOS && !deviceIsIOS4) {
        scrollParent = targetElement.fastClickScrollParent;
        if (scrollParent && scrollParent.fastClickLastScrollTop !== scrollParent.scrollTop) {
          return true;
        }
      }
      if (!this.needsClick(targetElement)) {
        event.preventDefault();
        this.sendClick(targetElement, event);
      }
      return false;
    };
    FastClick.prototype.onTouchCancel = function() {
      this.trackingClick = false;
      this.targetElement = null;
    };
    FastClick.prototype.onMouse = function(event) {
      if (!this.targetElement) {
        return true;
      }
      if (event.forwardedTouchEvent) {
        return true;
      }
      if (!event.cancelable) {
        return true;
      }
      if (!this.needsClick(this.targetElement) || this.cancelNextClick) {
        if (event.stopImmediatePropagation) {
          event.stopImmediatePropagation();
        } else {
          event.propagationStopped = true;
        }
        event.stopPropagation();
        event.preventDefault();
        return false;
      }
      return true;
    };
    FastClick.prototype.onClick = function(event) {
      var permitted;
      if (this.trackingClick) {
        this.targetElement = null;
        this.trackingClick = false;
        return true;
      }
      if (event.target.type === 'submit' && event.detail === 0) {
        return true;
      }
      permitted = this.onMouse(event);
      if (!permitted) {
        this.targetElement = null;
      }
      return permitted;
    };
    FastClick.prototype.destroy = function() {
      var layer = this.layer;
      if (deviceIsAndroid) {
        layer.removeEventListener('mouseover', this.onMouse, true);
        layer.removeEventListener('mousedown', this.onMouse, true);
        layer.removeEventListener('mouseup', this.onMouse, true);
      }
      layer.removeEventListener('click', this.onClick, true);
      layer.removeEventListener('touchstart', this.onTouchStart, false);
      layer.removeEventListener('touchmove', this.onTouchMove, false);
      layer.removeEventListener('touchend', this.onTouchEnd, false);
      layer.removeEventListener('touchcancel', this.onTouchCancel, false);
    };
    FastClick.notNeeded = function(layer) {
      var metaViewport;
      var chromeVersion;
      var blackberryVersion;
      var firefoxVersion;
      if (typeof window.ontouchstart === 'undefined') {
        return true;
      }
      chromeVersion = +(/Chrome\/([0-9]+)/.exec(navigator.userAgent) || [, 0])[1];
      if (chromeVersion) {
        if (deviceIsAndroid) {
          metaViewport = document.querySelector('meta[name=viewport]');
          if (metaViewport) {
            if (metaViewport.content.indexOf('user-scalable=no') !== -1) {
              return true;
            }
            if (chromeVersion > 31 && document.documentElement.scrollWidth <= window.outerWidth) {
              return true;
            }
          }
        } else {
          return true;
        }
      }
      if (deviceIsBlackBerry10) {
        blackberryVersion = navigator.userAgent.match(/Version\/([0-9]*)\.([0-9]*)/);
        if (blackberryVersion[1] >= 10 && blackberryVersion[2] >= 3) {
          metaViewport = document.querySelector('meta[name=viewport]');
          if (metaViewport) {
            if (metaViewport.content.indexOf('user-scalable=no') !== -1) {
              return true;
            }
            if (document.documentElement.scrollWidth <= window.outerWidth) {
              return true;
            }
          }
        }
      }
      if (layer.style.msTouchAction === 'none' || layer.style.touchAction === 'manipulation') {
        return true;
      }
      firefoxVersion = +(/Firefox\/([0-9]+)/.exec(navigator.userAgent) || [, 0])[1];
      if (firefoxVersion >= 27) {
        metaViewport = document.querySelector('meta[name=viewport]');
        if (metaViewport && (metaViewport.content.indexOf('user-scalable=no') !== -1 || document.documentElement.scrollWidth <= window.outerWidth)) {
          return true;
        }
      }
      if (layer.style.touchAction === 'none' || layer.style.touchAction === 'manipulation') {
        return true;
      }
      return false;
    };
    FastClick.attach = function(layer, options) {
      return new FastClick(layer, options);
    };
    if (typeof define === 'function' && typeof define.amd === 'object' && define.amd) {
      define(function() {
        return FastClick;
      });
    } else if (typeof module !== 'undefined' && module.exports) {
      module.exports = FastClick.attach;
      module.exports.FastClick = FastClick;
    } else {
      window.FastClick = FastClick;
    }
  }());
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:fastclick@1.0.6.js", ["npm:fastclick@1.0.6/lib/fastclick.js"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = $__require('npm:fastclick@1.0.6/lib/fastclick.js');
  global.define = __define;
  return module.exports;
});
